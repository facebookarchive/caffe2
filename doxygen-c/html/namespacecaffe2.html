<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffe2 - C++ API: caffe2 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="/static/favicon.png" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo" width="56"><a href="/"><img alt="Logo" src="Caffe2-with-name-55-tall.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffe2 - C++ API
   </div>
   <div id="projectbrief">A deep learning, cross platform ML framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="/doxygen-c/html/classes.html"><span>C++&#160;API</span></a></li>
      <li><a href="/doxygen-python/html/annotated.html"><span>Python&#160;API</span></a></li>
      <li><a href="https://github.com/caffe2/caffe2"><span>GitHub</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">caffe2 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright (c) 2016-present, Facebook, Inc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecaffe2_1_1enforce__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2_1_1enforce__detail.html">enforce_detail</a></td></tr>
<tr class="memdesc:namespacecaffe2_1_1enforce__detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rich logging messages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abs_c_p_u_functor.html">AbsCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abs_gradient_c_p_u_functor.html">AbsGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_lengths_def.html">AbstractLengthsDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_lengths_gradient_op.html">AbstractLengthsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_lengths_op.html">AbstractLengthsOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1_abstract_lengths_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_lengths_with_main_input_and_forward_output_gradient_op.html">AbstractLengthsWithMainInputAndForwardOutputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_lengths_with_main_input_gradient_op.html">AbstractLengthsWithMainInputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_reduce_back_def.html">AbstractReduceBackDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_reduce_front_def.html">AbstractReduceFrontDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_reduce_front_or_back_gradient_op.html">AbstractReduceFrontOrBackGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_reduce_front_or_back_op.html">AbstractReduceFrontOrBackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-segmented reduction over the first few dimensions of the tensor.  <a href="classcaffe2_1_1_abstract_reduce_front_or_back_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_sorted_segment_def.html">AbstractSortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_sorted_segment_gradient_op.html">AbstractSortedSegmentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_sorted_segment_op.html">AbstractSortedSegmentOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1_abstract_sorted_segment_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_sorted_segment_range_def.html">AbstractSortedSegmentRangeDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_sorted_segment_range_gradient_op.html">AbstractSortedSegmentRangeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_sorted_segment_range_op.html">AbstractSortedSegmentRangeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for segment reduction op that leverages continuity of the data.  <a href="classcaffe2_1_1_abstract_sorted_segment_range_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_sparse_lengths_def.html">AbstractSparseLengthsDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_sparse_sorted_segment_def.html">AbstractSparseSortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_sparse_unsorted_segment_def.html">AbstractSparseUnsortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_abstract_unsorted_segment_def.html">AbstractUnsortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_unsorted_segment_gradient_op.html">AbstractUnsortedSegmentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_abstract_unsorted_segment_op.html">AbstractUnsortedSegmentOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsorted segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1_abstract_unsorted_segment_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_accumulate_histogram_op.html">AccumulateHistogramOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_accumulate_input_gradient_op.html">AccumulateInputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_accumulate_op.html">AccumulateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_accuracy_op.html">AccuracyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_adagrad_op.html">AdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_adam_op.html">AdamOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_add_padding_op.html">AddPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_affine_channel_gradient_op.html">AffineChannelGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_affine_channel_op.html">AffineChannelOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_algorithms_cache.html">AlgorithmsCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_alias_op.html">AliasOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias op makes the output and the input share the same underlying storage.  <a href="classcaffe2_1_1_alias_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_aligned_deleter.html">AlignedDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_alloc_aligned.html">AllocAligned</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_alternate_learning_rate.html">AlternateLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_analysis.html">Analysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_a_p_meter_op.html">APMeterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to index into arguments.  <a href="classcaffe2_1_1_argument_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_assert_op.html">AssertOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_async_d_a_g_net.html">AsyncDAGNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_async_net_base.html">AsyncNetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_async_polling_net.html">AsyncPollingNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_async_scheduling_net.html">AsyncSchedulingNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_async_simple_net.html">AsyncSimpleNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_atomic_iter_op.html">AtomicIterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_averaged_loss_gradient.html">AveragedLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_average_pool.html">AveragePool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_avg_exported_stat.html">AvgExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_base_input_accessor.html">BaseInputAccessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_base_reducer.html">BaseReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_base_reducer_gradient.html">BaseReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_box_cox_op.html">BatchBoxCoxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_bucket_one_hot_op.html">BatchBucketOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_dense_to_sparse_op.html">BatchDenseToSparseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_gather_gradient_op.html">BatchGatherGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_gather_op.html">BatchGatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_mat_mul_op.html">BatchMatMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_one_hot_op.html">BatchOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_permutation_gradient_op.html">BatchPermutationGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_permutation_op.html">BatchPermutationOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_sparse_to_dense_op.html">BatchSparseToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_batch_to_space_op.html">BatchToSpaceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_b_box_transform_op.html">BBoxTransformOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_bernoulli_j_s_d_gradient_op.html">BernoulliJSDGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_bernoulli_j_s_d_op.html">BernoulliJSDOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation (e.g.  <a href="classcaffe2_1_1_binary_elementwise_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_blob.html">Blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_blob.html" title="Blob is a general container that hosts a typed pointer. ">Blob</a> is a general container that hosts a typed pointer.  <a href="classcaffe2_1_1_blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_blob_deserializer_base.html">BlobDeserializerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_blob_deserializer_base.html" title="BlobDeserializerBase is an abstract class that deserializes a blob from a BlobProto or a TensorProto...">BlobDeserializerBase</a> is an abstract class that deserializes a blob from a BlobProto or a TensorProto.  <a href="classcaffe2_1_1_blob_deserializer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_blob_serializer_base.html">BlobSerializerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_blob_serializer_base.html" title="BlobSerializerBase is an abstract class that serializes a blob to a string. ">BlobSerializerBase</a> is an abstract class that serializes a blob to a string.  <a href="classcaffe2_1_1_blob_serializer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_blobs_queue.html">BlobsQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_blob_stat_getter.html">BlobStatGetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_blob_stat_registry.html">BlobStatRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_blocking_counter.html">BlockingCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_boolean_mask_op.html">BooleanMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_boolean_unmask_op.html">BooleanUnmaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_box_with_n_m_s_limit_op.html">BoxWithNMSLimitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_b_r_g_n_c_h_w_c_to_packed_int8_b_g_r_a_stylizer_deprocess_op.html">BRGNCHWCToPackedInt8BGRAStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_buffered_tokenizer.html">BufferedTokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_caffe2_flag_parser.html">Caffe2FlagParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_caffe2_module_test_dynamic_dummy_op.html">Caffe2ModuleTestDynamicDummyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cast_op.html">CastOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ceil_op.html">CeilOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_channel_backprop_stats_op.html">ChannelBackpropStatsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_channel_shuffle_gradient_op.html">ChannelShuffleGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_channel_shuffle_op.html">ChannelShuffleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_channel_stats_op.html">ChannelStatsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_char_range.html">CharRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_check_counter_done_op.html">CheckCounterDoneOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_checkpoint_op.html">CheckpointOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_clip_gradient_op.html">ClipGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_clip_op.html">ClipOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_clip_tensor_by_scaling_op.html">ClipTensorByScalingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_close_blobs_queue_op.html">CloseBlobsQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_close_rebatching_queue_op.html">CloseRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_col2_im_op.html">Col2ImOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_common_subexpression_elimination_transform.html">CommonSubexpressionEliminationTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common Subexpression Elimination.  <a href="classcaffe2_1_1_common_subexpression_elimination_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_concat_op.html">ConcatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conditional_op.html">ConditionalOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_constant_fill_op.html">ConstantFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_constant_warmup_learning_rate.html">ConstantWarmupLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_converter.html">Converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_to_n_n_pack_transform.html">ConvToNNPackTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_transpose_gradient_op.html">ConvTransposeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_transpose_op.html">ConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_conv_transpose_unpool_base.html">ConvTransposeUnpoolBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_from_g_l_op.html">CopyFromGLOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_from_open_g_l_op.html">CopyFromOpenGLOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_on_device_like_op.html">CopyOnDeviceLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_on_device_like_op_3_01_c_u_d_a_context_00_01_c_u_d_a_context_00_01_c_u_d_a_context_01_4.html">CopyOnDeviceLikeOp&lt; CUDAContext, CUDAContext, CUDAContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_copy_to_open_g_l_op.html">CopyToOpenGLOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cos_c_p_u_functor.html">CosCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cos_gradient_c_p_u_functor.html">CosGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cosine_embedding_criterion_gradient_op.html">CosineEmbeddingCriterionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cosine_embedding_criterion_op.html">CosineEmbeddingCriterionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cosine_similarity_gradient_op.html">CosineSimilarityGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cosine_similarity_op.html">CosineSimilarityOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_count_down_op.html">CountDownOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_counter.html">Counter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_count_up_op.html">CountUpOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_c_p_u_allocator.html">CPUAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU Context, representing the bare minimum of what a Context class in Caffe2 should implement.  <a href="classcaffe2_1_1_c_p_u_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_c_p_u_event_wrapper.html">CPUEventWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cpu_id.html">CpuId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of an Intel CPU.  <a href="classcaffe2_1_1_cpu_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_c_p_u_sparse_lengths_reduction_op.html">CPUSparseLengthsReductionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cpu_utilization_report_op.html">CpuUtilizationReportOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_blobs_queue_op.html">CreateBlobsQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_counter_op.html">CreateCounterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_d_b_op.html">CreateDBOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_map_op.html">CreateMapOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_rebatching_queue_op.html">CreateRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_scope_op.html">CreateScopeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_create_text_file_reader_op.html">CreateTextFileReaderOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cross_entropy_gradient_op.html">CrossEntropyGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cross_entropy_op.html">CrossEntropyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cuda_device_prop_wrapper.html">CudaDevicePropWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cuda_event_wrapper.html">CudaEventWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_c_u_d_a_recurrent_network_executor.html">CUDARecurrentNetworkExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cuda_r_t_c_function.html">CudaRTCFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_gradient_op.html">CudnnConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_op.html">CudnnConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_op_base.html">CudnnConvOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_transpose_gradient_op.html">CudnnConvTransposeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_transpose_op.html">CudnnConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_conv_transpose_op_base.html">CudnnConvTransposeOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_filter_desc_wrapper.html">cudnnFilterDescWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_l_r_n_gradient_op.html">CuDNNLRNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_l_r_n_op.html">CuDNNLRNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_relu_gradient_op.html">CuDNNReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_relu_op.html">CuDNNReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_softmax_gradient_op.html">CuDNNSoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_softmax_op.html">CuDNNSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_gradient_op.html">CudnnSpatialBNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_op.html">CudnnSpatialBNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_state.html">CuDNNState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_tensor_desc_wrapper.html">cudnnTensorDescWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1cudnn_tensor_desc_wrapper.html" title="cudnnTensorDescWrapper is the placeholder that wraps around a cudnnTensorDescriptor_t, allowing us to do descriptor change as-needed during runtime. ">cudnnTensorDescWrapper</a> is the placeholder that wraps around a cudnnTensorDescriptor_t, allowing us to do descriptor change as-needed during runtime.  <a href="classcaffe2_1_1cudnn_tensor_desc_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_transpose_op.html">CuDNNTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_type_wrapper.html">cudnnTypeWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1cudnn_type_wrapper.html" title="cudnnTypeWrapper is a wrapper class that allows us to refer to the cudnn type in a template function...">cudnnTypeWrapper</a> is a wrapper class that allows us to refer to the cudnn type in a template function.  <a href="classcaffe2_1_1cudnn_type_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_type_wrapper_3_01double_01_4.html">cudnnTypeWrapper&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_type_wrapper_3_01float_01_4.html">cudnnTypeWrapper&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnn_type_wrapper_3_01float16_01_4.html">cudnnTypeWrapper&lt; float16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_cu_d_n_n_workspace.html">CuDNNWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1_cu_d_n_n_workspace.html" title="CuDNNWorkspace is a wrapper around a raw cuda pointer that holds the cudnn scratch space...">CuDNNWorkspace</a> is a wrapper around a raw cuda pointer that holds the cudnn scratch space.  <a href="structcaffe2_1_1_cu_d_n_n_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_cu_d_n_n_wrapper.html">CuDNNWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_cu_d_n_n_wrapper.html" title="CuDNNWrapper is a class that wraps the cudnn handles and cudnn workspaces. ">CuDNNWrapper</a> is a class that wraps the cudnn handles and cudnn workspaces.  <a href="classcaffe2_1_1_cu_d_n_n_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_d_a_g_net.html">DAGNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_d_a_g_net_base.html">DAGNetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_d_b_exists_op.html">DBExistsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_decoded_frame.html">DecodedFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_default_c_p_u_allocator.html">DefaultCPUAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_default_engine.html">DefaultEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_deform_conv_gradient_op.html">DeformConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_deform_conv_op.html">DeformConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_deform_conv_op_base.html">DeformConvOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dequeue_blobs_op.html">DequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dequeue_rebatching_queue_op.html">DequeueRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_detailed_exported_stat.html">DetailedExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_device_guard.html">DeviceGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_device_type_registerer.html">DeviceTypeRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_diagonal_fill_op.html">DiagonalFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_dispatch_helper.html">DispatchHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_dispatch_helper_3_01_fixed_values_3_01_first_val_00_01_values_8_8_8_01_4_00_01_extra_args_8_8_8_01_4.html">DispatchHelper&lt; FixedValues&lt; FirstVal, Values... &gt;, ExtraArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_dispatch_helper_3_01_fixed_values_3_4_00_01_extra_args_8_8_8_01_4.html">DispatchHelper&lt; FixedValues&lt;&gt;, ExtraArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_div_gradient_op.html">DivGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_do_op.html">DoOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dot_product_gradient_op.html">DotProductGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dot_product_op.html">DotProductOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dot_product_with_padding_gradient_op.html">DotProductWithPaddingGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dot_product_with_padding_op.html">DotProductWithPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dropout_gradient_op.html">DropoutGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_dropout_op.html">DropoutOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_eigen_conv_op.html">EigenConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_eigen_pow_functor.html">EigenPowFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_elementwise_linear_gradient_op.html">ElementwiseLinearGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_elementwise_linear_op.html">ElementwiseLinearOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_elementwise_r_t_c_op.html">ElementwiseRTCOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A GPU operator that can generate limited elementwise operations.  <a href="classcaffe2_1_1_elementwise_r_t_c_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_elu_gradient_op.html">EluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_elu_op.html">EluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_enforce_not_met.html">EnforceNotMet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_enqueue_blobs_op.html">EnqueueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_enqueue_rebatching_queue_op.html">EnqueueRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ensure_dense_op.html">EnsureDenseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass inputs to outputs.  <a href="classcaffe2_1_1_ensure_dense_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_event.html">Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_create_function_registerer.html">EventCreateFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_error_message_function_registerer.html">EventErrorMessageFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_finish_function_registerer.html">EventFinishFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_query_function_registerer.html">EventQueryFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_record_function_registerer.html">EventRecordFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_reset_function_registerer.html">EventResetFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_set_finished_function_registerer.html">EventSetFinishedFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_event_wait_function_registerer.html">EventWaitFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_expand_dims_op.html">ExpandDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_exp_c_p_u_functor.html">ExpCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_exp_learning_rate.html">ExpLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_exported_stat.html">ExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_exported_stat_value.html">ExportedStatValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_feed_blob_op.html">FeedBlobOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_file_reader.html">FileReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_file_store_handler.html">FileStoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_file_store_handler_create_op.html">FileStoreHandlerCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_filler_op.html">FillerOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_find_duplicate_elements_op.html">FindDuplicateElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_find_op.html">FindOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fixed_divisor.html">FixedDivisor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fixed_divisor_3_01int32__t_01_4.html">FixedDivisor&lt; int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fixed_learning_rate.html">FixedLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_fixed_values.html">FixedValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_flatten_op.html">FlattenOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_flatten_to_vec_op.html">FlattenToVecOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_flexible_top_k_gradient_op.html">FlexibleTopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_flexible_top_k_op.html">FlexibleTopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_float16_constant_fill_op.html">Float16ConstantFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_float_to_fused8_bit_rowwise_quantized_op.html">FloatToFused8BitRowwiseQuantizedOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_float_to_half_op.html">FloatToHalfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_float_to_rowwise_quantized8_bits_op.html">FloatToRowwiseQuantized8BitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_floor_op.html">FloorOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_for_each.html">ForEach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1_for_each.html" title="ForEach is a unary functor that forwards each element of the input array into the elementwise Functor...">ForEach</a> is a unary functor that forwards each element of the input array into the elementwise Functor provided, and gathers the results of each call into the resulting array.  <a href="structcaffe2_1_1_for_each.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_f_p16_momentum_s_g_d_update_op.html">FP16MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_f_p32_momentum_s_g_d_update_op.html">FP32MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_free_op.html">FreeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ftrl_op.html">FtrlOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_ftrl_params.html">FtrlParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_decomp_gradient_op.html">FullyConnectedDecompGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_gradient_op.html">FullyConnectedGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_op.html">FullyConnectedOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_op___s_p_a_r_s_e.html">FullyConnectedOp_SPARSE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_op_decomp.html">FullyConnectedOpDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_op_prune.html">FullyConnectedOpPrune</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fully_connected_prune_gradient_op.html">FullyConnectedPruneGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fun_hash_gradient_op.html">FunHashGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fun_hash_op.html">FunHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_fused8_bit_rowwise_quantized_to_float_op.html">Fused8BitRowwiseQuantizedToFloatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_by_key_op.html">GatherByKeyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_fused8_bit_rowwise_op.html">GatherFused8BitRowwiseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_op.html">GatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_padding_op.html">GatherPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_ranges_op.html">GatherRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gather_ranges_to_dense_op.html">GatherRangesToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gaussian_fill_op.html">GaussianFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_generate_proposals_op.html">GenerateProposalsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_generic_tensor_implementation.html">GenericTensorImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_abs_gradient.html">GetAbsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_add_padding_gradient.html">GetAddPaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_affine_channel_gradient.html">GetAffineChannelGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_averaged_loss_gradient.html">GetAveragedLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_batch_gather_gradient.html">GetBatchGatherGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_batch_permutation_gradient.html">GetBatchPermutationGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_batch_to_space_gradient.html">GetBatchToSpaceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_bernoulli_j_s_d_gradient.html">GetBernoulliJSDGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_cast_gradient.html">GetCastGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_channel_shuffle_gradient.html">GetChannelShuffleGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_col2_im_gradient.html">GetCol2ImGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_colwise_max_gradient.html">GetColwiseMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_concat_gradient.html">GetConcatGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_conv_gradient.html">GetConvGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_conv_transpose_gradient.html">GetConvTransposeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_cos_gradient.html">GetCosGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_cosine_similarity_gradient.html">GetCosineSimilarityGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_cross_entropy_gradient.html">GetCrossEntropyGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_dot_product_gradient.html">GetDotProductGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_dot_product_with_padding_gradient.html">GetDotProductWithPaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_dropout_gradient.html">GetDropoutGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_elementwise_linear_gradient.html">GetElementwiseLinearGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_elu_gradient.html">GetEluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_exp_gradient.html">GetExpGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_f_c_decomp_gradient.html">GetFCDecompGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_flatten_gradient.html">GetFlattenGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_float_to_half_gradient.html">GetFloatToHalfGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_group_spatial_softmax_gradient.html">GetGroupSpatialSoftmaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_g_r_u_unit_gradient.html">GetGRUUnitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_half_to_float_gradient.html">GetHalfToFloatGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_im2_col_gradient.html">GetIm2ColGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_instance_norm_gradient.html">GetInstanceNormGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_l1_distance_gradient.html">GetL1DistanceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_label_cross_entropy_gradient.html">GetLabelCrossEntropyGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_leaky_relu_gradient.html">GetLeakyReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_log_gradient.html">GetLogGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_l_r_n_gradient.html">GetLRNGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_l_s_t_m_unit_gradient.html">GetLSTMUnitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_make_two_class_gradient.html">GetMakeTwoClassGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_mat_mul_gradient.html">GetMatMulGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_max_gradient.html">GetMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_mean_gradient.html">GetMeanGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_min_gradient.html">GetMinGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_nan_check_gradient.html">GetNanCheckGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_n_c_h_w2_n_h_w_c_gradient.html">GetNCHW2NHWCGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_negate_gradient_gradient.html">GetNegateGradientGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_negative_gradient.html">GetNegativeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_n_h_w_c2_n_c_h_w_gradient.html">GetNHWC2NCHWGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_normalize_gradient.html">GetNormalizeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_pack_segments_gradient.html">GetPackSegmentsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_pad_image_gradient.html">GetPadImageGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_p_relu_gradient.html">GetPReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_prepend_dim_gradient.html">GetPrependDimGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_recurrent_gradient.html">GetRecurrentGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_recurrent_network_gradient.html">GetRecurrentNetworkGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_back_max_gradient.html">GetReduceBackMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_back_mean_gradient.html">GetReduceBackMeanGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_back_sum_gradient.html">GetReduceBackSumGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_front_max_gradient.html">GetReduceFrontMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_front_mean_gradient.html">GetReduceFrontMeanGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reduce_front_sum_gradient.html">GetReduceFrontSumGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_relu_gradient.html">GetReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_remove_padding_gradient.html">GetRemovePaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reshape_gradient.html">GetReshapeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_resize_nearest_gradient.html">GetResizeNearestGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_reverse_packed_segs_gradient.html">GetReversePackedSegsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_ro_i_pool_gradient.html">GetRoIPoolGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_rowwise_max_gradient.html">GetRowwiseMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sample_as_gradient.html">GetSampleAsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_scale_gradient.html">GetScaleGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_select_smooth_l1_loss_gradient.html">GetSelectSmoothL1LossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_selu_gradient.html">GetSeluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sigmoid_cross_entropy_loss_gradient.html">GetSigmoidCrossEntropyLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_sigmoid_cross_entropy_with_logits_gradient.html">GetSigmoidCrossEntropyWithLogitsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sigmoid_focal_loss_gradient.html">GetSigmoidFocalLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sigmoid_gradient.html">GetSigmoidGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sin_gradient.html">GetSinGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_smooth_l1_loss_gradient.html">GetSmoothL1LossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_softmax_focal_loss_gradient.html">GetSoftmaxFocalLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_softmax_gradient.html">GetSoftmaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_softplus_gradient.html">GetSoftplusGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_softsign_gradient.html">GetSoftsignGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_space_to_batch_gradient.html">GetSpaceToBatchGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_spatial_b_n_gradient.html">GetSpatialBNGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_split_gradient.html">GetSplitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sqr_gradient.html">GetSqrGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sqrt_gradient.html">GetSqrtGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_squared_l2_distance_gradient.html">GetSquaredL2DistanceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_square_root_divide_gradient.html">GetSquareRootDivideGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_sum_elements_gradient.html">GetSumElementsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_swish_gradient.html">GetSwishGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_tanh_gradient.html">GetTanhGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_tile_gradient.html">GetTileGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_top_k_gradient.html">GetTopKGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_transpose_gradient.html">GetTransposeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_unpack_segments_gradient.html">GetUnpackSegmentsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_get_upsample_nearest_gradient.html">GetUpsampleNearestGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_weighted_sigmoid_cross_entropy_with_logits_gradient.html">GetWeightedSigmoidCrossEntropyWithLogitsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_get_zero_gradient_op_gradient.html">GetZeroGradientOpGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_average_pool_op.html">GLAveragePoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_concat_op.html">GLConcatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_context.html">GLContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_conv_op.html">GLConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_fully_connected_op.html">GLFullyConnectedOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_max_pool_op.html">GLMaxPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_net.html">GLNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_normalize_planar_y_u_v_op.html">GLNormalizePlanarYUVOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_norm_planar_y_u_v_op.html">GLNormPlanarYUVOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_pool_op.html">GLPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_predictor.html">GLPredictor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_relu_op.html">GLReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_reshape_op.html">GLReshapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_resize_nearest_op.html">GLResizeNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_sigmoid_op.html">GLSigmoidOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_softmax_op.html">GLSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_spatial_b_n_op.html">GLSpatialBNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_sum_op.html">GLSumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_l_tensor.html">GLTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_glu_op.html">GluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_p_u_fallback_op.html">GPUFallbackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated class to allow one to wrap a CPU operator as a CUDA operator.  <a href="classcaffe2_1_1_g_p_u_fallback_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_gradient_maker_base.html">GradientMakerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_gradient_not_implemented_yet.html">GradientNotImplementedYet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the gradient mechanism is not ready.  <a href="structcaffe2_1_1_gradient_not_implemented_yet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_gradient_ops_meta.html">GradientOpsMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that holds the gradient operators and related gradient maps.  <a href="structcaffe2_1_1_gradient_ops_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_gradient_wrapper.html">GradientWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_group_spatial_softmax_gradient_op.html">GroupSpatialSoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_group_spatial_softmax_op.html">GroupSpatialSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_r_u_unit_gradient_op.html">GRUUnitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_g_r_u_unit_op.html">GRUUnitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_half_to_float_op.html">HalfToFloatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_has_elements_op.html">HasElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_has_scope_op.html">HasScopeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_hill_learning_rate.html">HillLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_h_softmax_gradient_op.html">HSoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_h_softmax_op.html">HSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_h_softmax_op_base.html">HSoftmaxOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_h_softmax_search_op.html">HSoftmaxSearchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_huffman_tree_hierarchy_op.html">HuffmanTreeHierarchyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_if_op.html">IfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_im2_col_op.html">Im2ColOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_image_allocator.html">ImageAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_image_input_op.html">ImageInputOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_index.html">Index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_index_base.html">IndexBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_create_op.html">IndexCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_deserializer.html">IndexDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_freeze_op.html">IndexFreezeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_get_op.html">IndexGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_hash_op.html">IndexHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_load_op.html">IndexLoadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_serializer.html">IndexSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_size_op.html">IndexSizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_index_store_op.html">IndexStoreOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_init_registerer.html">InitRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_instance_norm_gradient_op.html">InstanceNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_instance_norm_op.html">InstanceNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_inv_learning_rate.html">InvLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_is_empty_op.html">IsEmptyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_is_member_of_op.html">IsMemberOfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_is_member_of_value_holder.html">IsMemberOfValueHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_iter_op.html">IterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_key_split_op.html">KeySplitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_key_value_to_map_op.html">KeyValueToMapOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l1_distance_gradient_op.html">L1DistanceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l1_distance_op.html">L1DistanceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_label_cross_entropy_gradient_op.html">LabelCrossEntropyGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_label_cross_entropy_op.html">LabelCrossEntropyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lambda_rank_ndcg_gradient_op.html">LambdaRankNdcgGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lambda_rank_ndcg_op.html">LambdaRankNdcgOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lars_op.html">LarsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_layer_norm_gradient_op.html">LayerNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_layer_norm_op.html">LayerNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_leaky_relu_gradient_op.html">LeakyReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_leaky_relu_op.html">LeakyReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_learning_rate_functor.html">LearningRateFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_learning_rate_op.html">LearningRateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_gather_op.html">LengthsGatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_lengths_op_get_gradient.html">LengthsOpGetGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_partition_op.html">LengthsPartitionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_range_fill_op.html">LengthsRangeFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_tile_op.html">LengthsTileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_top_k_gradient_op.html">LengthsTopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_top_k_op.html">LengthsTopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_to_ranges_op.html">LengthsToRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_to_segment_ids_op.html">LengthsToSegmentIdsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_to_shape_op.html">LengthsToShapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lengths_to_weights_op.html">LengthsToWeightsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_linear_warmup_learning_rate.html">LinearWarmupLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_load_op.html">LoadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_log_c_p_u_functor.html">LogCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_logger_voidify.html">LoggerVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_logit_c_p_u_functor.html">LogitCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_logit_gradient_op.html">LogitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_mean_exp_range_reducer.html">LogMeanExpRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_mean_exp_range_reducer_3_01_t_00_01_c_p_u_context_01_4.html">LogMeanExpRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_log_mean_exp_range_reducer_def.html">LogMeanExpRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_mean_exp_range_reducer_gradient.html">LogMeanExpRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_sum_exp_range_reducer.html">LogSumExpRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_sum_exp_range_reducer_3_01_t_00_01_c_p_u_context_01_4.html">LogSumExpRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_log_sum_exp_range_reducer_def.html">LogSumExpRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_log_sum_exp_range_reducer_gradient.html">LogSumExpRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lp_norm_gradient_op.html">LpNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lp_norm_op.html">LpNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_lp_pool.html">LpPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l_r_n_gradient_op.html">LRNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l_r_n_op.html">LRNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l_r_n_op_base.html">LRNOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l_s_t_m_unit_gradient_op.html">LSTMUnitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_l_s_t_m_unit_op.html">LSTMUnitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_make_aligned.html">MakeAligned</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_make_two_class_gradient_op.html">MakeTwoClassGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_make_two_class_op.html">MakeTwoClassOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_map_deserializer.html">MapDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_map_serializer.html">MapSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_map_to_key_value_op.html">MapToKeyValueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_map_type_traits.html">MapTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_margin_ranking_criterion_gradient_op.html">MarginRankingCriterionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_margin_ranking_criterion_op.html">MarginRankingCriterionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mat_mul_op.html">MatMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_gradient_op.html">MaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_min_op_base.html">MaxMinOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_op.html">MaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_pool.html">MaxPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_pool_gradient_r_t_c_op.html">MaxPoolGradientRTCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_pool_r_t_c_op.html">MaxPoolRTCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_pool_with_index_gradient_op.html">MaxPoolWithIndexGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_pool_with_index_op.html">MaxPoolWithIndexOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_range_reducer.html">MaxRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_range_reducer_3_01_t_00_01_c_p_u_context_01_4.html">MaxRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_max_range_reducer_def.html">MaxRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_range_reducer_gradient.html">MaxRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reduce_dims_gradient_op.html">MaxReduceDimsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reduce_dims_op.html">MaxReduceDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reducer.html">MaxReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reducer_3_01_t_00_01_c_p_u_context_01_4.html">MaxReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_max_reducer_def.html">MaxReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reducer_gradient.html">MaxReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reduction_gradient_op.html">MaxReductionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_max_reduction_op.html">MaxReductionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_gradient_op.html">MeanGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_op.html">MeanOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_range_reducer.html">MeanRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_range_reducer_3_01_t_00_01_c_p_u_context_01_4.html">MeanRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_mean_range_reducer_def.html">MeanRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_range_reducer_gradient.html">MeanRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_reducer.html">MeanReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_reducer_3_01_t_00_01_c_p_u_context_01_4.html">MeanReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_mean_reducer_def.html">MeanReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mean_reducer_gradient.html">MeanReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_memory_allocation_reporter.html">MemoryAllocationReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_merge_dim_op.html">MergeDimOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_merge_id_lists_op.html">MergeIdListsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_message_logger.html">MessageLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_min_gradient_op.html">MinGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_min_op.html">MinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_m_k_l_context.html">MKLContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MKL Context, which is largely the same as the <a class="el" href="classcaffe2_1_1_c_p_u_context.html" title="The CPU Context, representing the bare minimum of what a Context class in Caffe2 should implement...">CPUContext</a>.  <a href="classcaffe2_1_1_m_k_l_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mod_op.html">ModOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_module_schema.html">ModuleSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module schema that can be used to store specific information about different modules.  <a href="classcaffe2_1_1_module_schema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_momentum_s_g_d_op.html">MomentumSGDOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_momentum_s_g_d_update_op.html">MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_m_p_i_common_world_wrapper.html">MPICommonWorldWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper over an MPI common world.  <a href="classcaffe2_1_1_m_p_i_common_world_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_m_p_i_data_type_wrapper.html">MPIDataTypeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_m_p_s_c_n_n_context.html">MPSCNNContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_m_s_r_a_fill_op.html">MSRAFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_multi_class_accuracy_op.html">MultiClassAccuracyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mutex_deserializer.html">MutexDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_mutex_serializer.html">MutexSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_nan_check_op.html">NanCheckOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_n_c_h_w2_n_h_w_c_op.html">NCHW2NHWCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_negate_gradient_op.html">NegateGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_negative_c_p_u_functor.html">NegativeCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_net_observer_reporter.html">NetObserverReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_net_observer_reporter_print.html">NetObserverReporterPrint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_n_gram_from_categorical_op.html">NGramFromCategoricalOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_n_h_w_c2_n_c_h_w_op.html">NHWC2NCHWOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_n_n_api.html">NNApi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_n_n_p_a_c_k_conv_op.html">NNPACKConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to denote that an op does not have a default engine.  <a href="classcaffe2_1_1_no_default_engine_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_no_gradient.html">NoGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the operator does not need gradient computation.  <a href="classcaffe2_1_1_no_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_normalize_gradient_op.html">NormalizeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_normalize_l1_op.html">NormalizeL1Op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_normalize_op.html">NormalizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_not_functor.html">NotFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_observable.html">Observable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit to make your class observable.  <a href="classcaffe2_1_1_observable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_observer_base.html">ObserverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to implement a Observer using the Observer Pattern template.  <a href="classcaffe2_1_1_observer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_observer_config.html">ObserverConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_one_hot_op.html">OneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_o_n_n_x_while_op.html">ONNXWhileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_add_op.html">OpenGLAddOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_concat_op.html">OpenGLConcatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_conv_op.html">OpenGLConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_conv_transpose_op.html">OpenGLConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_instance_norm_p_relu_op.html">OpenGLInstanceNormPReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_mul_op.html">OpenGLMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_pad_image_op.html">OpenGLPadImageOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_p_relu_op.html">OpenGLPReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_resize_nearest_op.html">OpenGLResizeNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_sigmoid_op.html">OpenGLSigmoidOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_sub_op.html">OpenGLSubOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_tensor_to_texture_stylizer_preprocess_op.html">OpenGLTensorToTextureStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_texture_to_tensor_stylizer_deprocess_op.html">OpenGLTextureToTensorStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_texture_to_texture_stylizer_deprocess_op.html">OpenGLTextureToTextureStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_open_g_l_texture_to_texture_stylizer_preprocess_op.html">OpenGLTextureToTextureStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_operator.html">Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_operator_attaching_net_observer.html">OperatorAttachingNetObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to record the schema of an op.  <a href="classcaffe2_1_1_op_schema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_op_schema_registry.html">OpSchemaRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry to hold all the operator schemas.  <a href="classcaffe2_1_1_op_schema_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_op_task.html">OpTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for a scheduled task in the task queue.  <a href="structcaffe2_1_1_op_task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_packed_int8_b_g_r_a_n_h_w_c_to_n_c_h_w_c_stylizer_preprocess_op.html">PackedInt8BGRANHWCToNCHWCStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pack_r_n_n_sequence_op_base.html">PackRNNSequenceOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pack_segments_op.html">PackSegmentsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pad_empty_samples_op.html">PadEmptySamplesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pad_image_gradient_op.html">PadImageGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pad_image_op.html">PadImageOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pair_wise_loss_gradient_op.html">PairWiseLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pair_wise_loss_op.html">PairWiseLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_params.html">Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_partition_op.html">PartitionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_partition_op_base.html">PartitionOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pattern_net_transform.html">PatternNetTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_pattern_net_transform.html" title="PatternNetTransform allows you to create transforms using a simple interface. ">PatternNetTransform</a> allows you to create transforms using a simple interface.  <a href="classcaffe2_1_1_pattern_net_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_percentile_op.html">PercentileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_perf_net_observer.html">PerfNetObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_perf_operator_observer.html">PerfOperatorObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_perplexity_op.html">PerplexityOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_piecewise_linear_transform_op.html">PiecewiseLinearTransformOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_pinned_c_p_u_allocator.html">PinnedCPUAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that does the CPU memory allocation with pinned memory.  <a href="structcaffe2_1_1_pinned_c_p_u_allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_plan_execution_time.html">PlanExecutionTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_poly_learning_rate.html">PolyLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_pow_op.html">PowOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_predictor.html">Predictor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_prefetch_operator.html">PrefetchOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_p_relu_gradient_op.html">PReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_p_relu_op.html">PReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_prepend_dim_op.html">PrependDimOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_print_op.html">PrintOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_p_s_ro_i_pool_gradient_op.html">PSRoIPoolGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_p_s_ro_i_pool_op.html">PSRoIPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_q_conv_op.html">QConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_q_conv_state.html">QConvState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_q_tensor.html">QTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_q_tensor_deserializer.html">QTensorDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_q_tensor_serializer.html">QTensorSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_quant_decode_gradient_op.html">QuantDecodeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_quant_decode_op.html">QuantDecodeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_quant_decomp_zstd_op.html">QuantDecompZstdOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_range_fill_op.html">RangeFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_range_op.html">RangeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_rebatching_queue.html">RebatchingQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_base_op.html">RecurrentBaseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_gradient_op.html">RecurrentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_network_blob_fetcher_op.html">RecurrentNetworkBlobFetcherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_network_executor_base.html">RecurrentNetworkExecutorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RecurrentNetworkExecutor is a specialized runtime for recurrent neural networks (RNNs).  <a href="classcaffe2_1_1_recurrent_network_executor_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_network_gradient_op.html">RecurrentNetworkGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_network_op.html">RecurrentNetworkOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_op.html">RecurrentOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_recurrent_param_access_op.html">RecurrentParamAccessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_redis_store_handler.html">RedisStoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_redis_store_handler_create_op.html">RedisStoreHandlerCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_reduce_tail_sum_op.html">ReduceTailSumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_registerer.html">Registerer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class that allows one to register classes by keys.  <a href="classcaffe2_1_1_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_relu_gradient_op.html">ReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_relu_op.html">ReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_remove_data_blocks_op.html">RemoveDataBlocksOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_remove_padding_op.html">RemovePaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_replace_na_n_op.html">ReplaceNaNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_reset_counter_op.html">ResetCounterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_reshape_op.html">ReshapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_resize_like_op.html">ResizeLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_resize_nearest_gradient_op.html">ResizeNearestGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_resize_nearest_op.html">ResizeNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_retrieve_count_op.html">RetrieveCountOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_reverse_packed_segs_op.html">ReversePackedSegsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_r_m_a_c_regions_op.html">RMACRegionsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_rms_prop_op.html">RmsPropOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_r_n_n_apply_link_op.html">RNNApplyLinkOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_r_n_n_net_operator.html">RNNNetOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for operator in a timestep and its dependenceis.  <a href="structcaffe2_1_1_r_n_n_net_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_align_gradient_op.html">RoIAlignGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_align_op.html">RoIAlignOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_pool_f_gradient_op.html">RoIPoolFGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_pool_f_op.html">RoIPoolFOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_pool_gradient_op.html">RoIPoolGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_ro_i_pool_op.html">RoIPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_row_mul_op.html">RowMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_rowwise8_bit_quantized_to_float_op.html">Rowwise8BitQuantizedToFloatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_row_wise_sparse_adagrad_op.html">RowWiseSparseAdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_row_wise_sparse_adam_op.html">RowWiseSparseAdamOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_run_count_net_observer.html">RunCountNetObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_run_count_operator_observer.html">RunCountOperatorObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_safe_dequeue_blobs_op.html">SafeDequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_safe_enqueue_blobs_op.html">SafeEnqueueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sample_as_gradient_op.html">SampleAsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sample_as_op.html">SampleAsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sample_interval.html">SampleInterval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_save_op.html">SaveOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_scale_op.html">ScaleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_scatter_assign_op.html">ScatterAssignOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update slices of the tensor in-place by overriding.  <a href="classcaffe2_1_1_scatter_assign_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_scatter_weighted_sum_op.html">ScatterWeightedSumOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update slices of the tensor in-place with weighted sum.  <a href="classcaffe2_1_1_scatter_weighted_sum_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_segment_ids_to_lengths_op.html">SegmentIdsToLengthsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_segment_ids_to_ranges_op.html">SegmentIdsToRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_segment_one_hot_op.html">SegmentOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_segment_op_get_gradient.html">SegmentOpGetGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_select_gradient_op_base.html">SelectGradientOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_select_smooth_l1_loss_gradient_op.html">SelectSmoothL1LossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_select_smooth_l1_loss_op.html">SelectSmoothL1LossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_selu_gradient_op.html">SeluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_selu_op.html">SeluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sequence_mask_op.html">SequenceMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_shape_op.html">ShapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sigmoid_c_p_u_functor.html">SigmoidCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_loss_gradient_op.html">SigmoidCrossEntropyLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_loss_op.html">SigmoidCrossEntropyLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_with_logits_gradient_op.html">SigmoidCrossEntropyWithLogitsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_with_logits_op.html">SigmoidCrossEntropyWithLogitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_focal_loss_gradient_op.html">SigmoidFocalLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sigmoid_focal_loss_op.html">SigmoidFocalLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sigmoid_gradient_c_p_u_functor.html">SigmoidGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_signal_handler.html">SignalHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sign_c_p_u_functor.html">SignCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_simple_net.html">SimpleNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_simple_queue.html">SimpleQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sin_c_p_u_functor.html">SinCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_single_op_transform.html">SingleOpTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single Op <a class="el" href="classcaffe2_1_1_transform.html" title="The Transform Base Object. ">Transform</a> Base class.  <a href="classcaffe2_1_1_single_op_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sin_gradient_c_p_u_functor.html">SinGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sinusoid_position_encoding_op.html">SinusoidPositionEncodingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_size_op.html">SizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_skip_indices.html">SkipIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_skip_indices_3_4.html">SkipIndices&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_slice_gradient_op.html">SliceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_slice_op.html">SliceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_smart_tensor_printer.html">SmartTensorPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_smooth_l1_loss_gradient_op.html">SmoothL1LossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_smooth_l1_loss_op.html">SmoothL1LossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_s_n_p_e_op.html">SNPEOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_focal_loss_gradient_op.html">SoftmaxFocalLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_focal_loss_op.html">SoftmaxFocalLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_gradient_op.html">SoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_op.html">SoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_with_loss_gradient_op.html">SoftmaxWithLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softmax_with_loss_op.html">SoftmaxWithLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softplus_gradient_op.html">SoftplusGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_softplus_op.html">SoftplusOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_softsign_c_p_u_functor.html">SoftsignCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_softsign_gradient_c_p_u_functor.html">SoftsignGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_space_batch_op_base.html">SpaceBatchOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_space_to_batch_op.html">SpaceToBatchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_adagrad_op.html">SparseAdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_adam_op.html">SparseAdamOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_ftrl_op.html">SparseFtrlOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_fun_hash_gradient_op.html">SparseFunHashGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_fun_hash_op.html">SparseFunHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_lengths8_bits_rowwise_op.html">SparseLengths8BitsRowwiseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_lengths_fused8_bit_rowwise_op.html">SparseLengthsFused8BitRowwiseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_matrix_reshape_op.html">SparseMatrixReshapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_momentum_s_g_d_update_op.html">SparseMomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_normalize_op.html">SparseNormalizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_to_dense_mask_base.html">SparseToDenseMaskBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_to_dense_mask_gradient_op.html">SparseToDenseMaskGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_to_dense_mask_op.html">SparseToDenseMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sparse_to_dense_op.html">SparseToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_b_n_gradient_op.html">SpatialBNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_b_n_op.html">SpatialBNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_narrow_as_gradient.html">SpatialNarrowAsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_narrow_as_gradient_op.html">SpatialNarrowAsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_narrow_as_op.html">SpatialNarrowAsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_softmax_with_loss_gradient_op.html">SpatialSoftmaxWithLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_spatial_softmax_with_loss_op.html">SpatialSoftmaxWithLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_split_op.html">SplitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sqr_c_p_u_functor.html">SqrCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sqrt_c_p_u_functor.html">SqrtCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_squared_l2_distance_gradient_op.html">SquaredL2DistanceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_squared_l2_distance_op.html">SquaredL2DistanceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_square_root_divide_op.html">SquareRootDivideOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_squeeze_op.html">SqueezeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_stat.html">Stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_static_linking_protector.html">StaticLinkingProtector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a map of atomic counters keyed by name.  <a href="classcaffe2_1_1_stat_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stat_registry_create_op.html">StatRegistryCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stat_registry_export_op.html">StatRegistryExportOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stat_registry_update_op.html">StatRegistryUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stat_value.html">StatValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_std_dev_exported_stat.html">StdDevExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_step_learning_rate.html">StepLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_stop_gradient_op.html">StopGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_stop_on_signal.html">StopOnSignal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_store_add_op.html">StoreAddOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_store_get_op.html">StoreGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_store_handler_timeout_exception.html">StoreHandlerTimeoutException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_store_set_op.html">StoreSetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_store_wait_op.html">StoreWaitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_string_deserializer.html">StringDeserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_string_deserializer.html" title="StringDeserializer is the deserializer for Strings. ">StringDeserializer</a> is the deserializer for Strings.  <a href="classcaffe2_1_1_string_deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_string_join_op.html">StringJoinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_string_provider.html">StringProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_string_serializer.html">StringSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_string_serializer.html" title="StringSerializer is the serializer for String. ">StringSerializer</a> is the serializer for String.  <a href="classcaffe2_1_1_string_serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_elements_gradient_op.html">SumElementsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_elements_op.html">SumElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_summarize_op.html">SummarizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_op.html">SumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_range_reducer.html">SumRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_range_reducer_3_01_t_00_01_c_p_u_context_01_4.html">SumRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sum_range_reducer_def.html">SumRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_range_reducer_gradient.html">SumRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reduce_dims_gradient_op.html">SumReduceDimsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reduce_dims_op.html">SumReduceDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reduce_like_op.html">SumReduceLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reducer.html">SumReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reducer_3_01_t_00_01_c_p_u_context_01_4.html">SumReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_sum_reducer_def.html">SumReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_reducer_gradient.html">SumReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_sum_sqr_elements_op.html">SumSqrElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_swish_c_p_u_functor.html">SwishCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_swish_gradient_op.html">SwishGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_tanh_c_p_u_functor.html">TanhCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_tanh_gradient_c_p_u_functor.html">TanhGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_task.html">Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_task_thread_pool.html">TaskThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_tensor.html" title="Tensor is the basic class in Caffe2 that stores a contiguous memory with its shape information...">Tensor</a> is the basic class in Caffe2 that stores a contiguous memory with its shape information.  <a href="classcaffe2_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tensor_deserializer.html">TensorDeserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_tensor_deserializer.html" title="TensorDeserializer is the deserializer for Tensors. ">TensorDeserializer</a> is the deserializer for Tensors.  <a href="classcaffe2_1_1_tensor_deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tensor_printer.html">TensorPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tensor_serializer.html">TensorSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_tensor_serializer.html" title="TensorSerializer is the serializer for Tensors. ">TensorSerializer</a> is the serializer for Tensors.  <a href="classcaffe2_1_1_tensor_serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_tensor_types2.html">TensorTypes2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_text_file_reader_instance.html">TextFileReaderInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_text_file_reader_read_op.html">TextFileReaderReadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_threaded_recurrent_network_executor.html">ThreadedRecurrentNetworkExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_thread_local_c_u_d_a_objects.html">ThreadLocalCUDAObjects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to host thread-local cuda objects.  <a href="classcaffe2_1_1_thread_local_c_u_d_a_objects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_thresholded_relu_gradient_op.html">ThresholdedReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_thresholded_relu_op.html">ThresholdedReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_throw_in_the_towel_if_gradient_is_called.html">ThrowInTheTowelIfGradientIsCalled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the operator should have no gradient.  <a href="structcaffe2_1_1_throw_in_the_towel_if_gradient_is_called.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tile_gradient_op.html">TileGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tile_op.html">TileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_time_counter.html">TimeCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_time_observer.html">TimeObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_time_operator_observer.html">TimeOperatorObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple timer object for measuring time.  <a href="classcaffe2_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_timer_begin_op.html">TimerBeginOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_timer_end_op.html">TimerEndOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_timer_get_and_end_op.html">TimerGetAndEndOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_timer_get_op.html">TimerGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_timer_instance.html">TimerInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_token.html">Token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tokenized_string.html">TokenizedString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_tokenizer.html">Tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_top_k_gradient_op.html">TopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_top_k_op.html">TopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_transform.html">Transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classcaffe2_1_1_transform.html" title="The Transform Base Object. ">Transform</a> Base Object.  <a href="classcaffe2_1_1_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_transpose_op.html">TransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_contraction_gradient_op.html">TTContractionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_contraction_op.html">TTContractionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_linear_gradient_op.html">TTLinearGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_linear_op.html">TTLinearOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_pad_gradient_op.html">TTPadGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_t_t_pad_op.html">TTPadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_type_meta.html">TypeMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_type_meta.html" title="TypeMeta is a thin class that allows us to store the type of a container such as a blob...">TypeMeta</a> is a thin class that allows us to store the type of a container such as a blob, or the data type of a tensor, with a unique run-time id.  <a href="classcaffe2_1_1_type_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_type_name_registerer.html">TypeNameRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_type_name_traits.html">TypeNameTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_type_name_traits_3_01int32__t_01_4.html">TypeNameTraits&lt; int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_type_name_traits_3_01int64__t_01_4.html">TypeNameTraits&lt; int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_uniform_fill_op.html">UniformFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unique_op.html">UniqueOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduplicates input indices vector and optionally produces reverse remapping.  <a href="classcaffe2_1_1_unique_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unique_uniform_fill_op.html">UniqueUniformFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unpack_segments_op.html">UnpackSegmentsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unsafe_coalesce_op.html">UnsafeCoalesceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_unsupported_operator_feature.html">UnsupportedOperatorFeature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_upsample_nearest_gradient_op.html">UpsampleNearestGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_upsample_nearest_op.html">UpsampleNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_variable_length_sequence_padding_op.html">VariableLengthSequencePaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_video_decoder.html">VideoDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_video_input_op.html">VideoInputOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_video_i_o_context.html">VideoIOContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_video_meta.html">VideoMeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_wall_clock_time_op.html">WallClockTimeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sample_dequeue_blobs_op.html">WeightedSampleDequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sample_op.html">WeightedSampleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sigmoid_cross_entropy_with_logits_gradient_op.html">WeightedSigmoidCrossEntropyWithLogitsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sigmoid_cross_entropy_with_logits_op.html">WeightedSigmoidCrossEntropyWithLogitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sum_gradient_op.html">WeightedSumGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sum_op.html">WeightedSumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sum_reducer.html">WeightedSumReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sum_reducer_3_01_t_00_01_c_p_u_context_01_4.html">WeightedSumReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_weighted_sum_reducer_def.html">WeightedSumReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_weighted_sum_reducer_gradient.html">WeightedSumReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_where_op.html">WhereOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_while_op.html">WhileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_with_default_constructor.html">WithDefaultConstructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1_with_default_constructor.html" title="WithDefaultConstructor is a functor that can be used as the functor of an UnaryElementwiseWithArgsOp...">WithDefaultConstructor</a> is a functor that can be used as the functor of an <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>.  <a href="structcaffe2_1_1_with_default_constructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_worker.html">Worker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_workers_pool.html">WorkersPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1_workspace.html" title="Workspace is a class that holds all the related objects created during runtime: (1) all blobs...">Workspace</a> is a class that holds all the related objects created during runtime: (1) all blobs, and (2) all instantiated networks.  <a href="classcaffe2_1_1_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_xavier_fill_op.html">XavierFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_yellow_fin_op.html">YellowFinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_zero_gradient_op.html">ZeroGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_zmq_context.html">ZmqContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_zmq_message.html">ZmqMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1_zmq_socket.html">ZmqSocket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aef39c024cb7f37c6cff2725d7a701189"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef39c024cb7f37c6cff2725d7a701189"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryDeleter</b> = void(*)(void *)</td></tr>
<tr class="separator:aef39c024cb7f37c6cff2725d7a701189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6a9203ab54d205dc23184848d9581b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f6a9203ab54d205dc23184848d9581b"></a>
typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>TIndex</b></td></tr>
<tr class="separator:a8f6a9203ab54d205dc23184848d9581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3fb8907c4895c3f71c924e41fa6c87e"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CaffeMap</b> = std::map&lt; Key, Value &gt;</td></tr>
<tr class="separator:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f586aeb42d1018592e68c17f1e07f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6f586aeb42d1018592e68c17f1e07f4"></a>
typedef <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TensorCUDA</b></td></tr>
<tr class="separator:ac6f586aeb42d1018592e68c17f1e07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40511c6a34816a79b326a1145d2142b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad40511c6a34816a79b326a1145d2142b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateFunction</b>) (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:ad40511c6a34816a79b326a1145d2142b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff8832a06132655c341ee77e8e23d9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ff8832a06132655c341ee77e8e23d9d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordFunction</b>) (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *, const void *, const char *)</td></tr>
<tr class="separator:a9ff8832a06132655c341ee77e8e23d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a3d0f77afbc3e3bd658ca02345a11c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11a3d0f77afbc3e3bd658ca02345a11c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitFunction</b>) (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *, void *)</td></tr>
<tr class="separator:a11a3d0f77afbc3e3bd658ca02345a11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8905aa87e0470ae1fbdfea83397c5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c8905aa87e0470ae1fbdfea83397c5f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishFunction</b>) (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a6c8905aa87e0470ae1fbdfea83397c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207a754e7e771e2cb7f4a94db2975d14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a207a754e7e771e2cb7f4a94db2975d14"></a>
typedef EventStatus(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryFunction</b>) (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a207a754e7e771e2cb7f4a94db2975d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29abe9cc13481e767ef952a877feb7c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29abe9cc13481e767ef952a877feb7c7"></a>
typedef const std::string &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageFunction</b>) (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a29abe9cc13481e767ef952a877feb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8890d6156fb78e8999a89d62beb259f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8890d6156fb78e8999a89d62beb259f0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedFunction</b>) (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *, const char *)</td></tr>
<tr class="separator:a8890d6156fb78e8999a89d62beb259f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a783d65faf77c762f145c1dd4c7e4bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a783d65faf77c762f145c1dd4c7e4bd"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetFunction</b>) (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a9a783d65faf77c762f145c1dd4c7e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67383b45c782e11815cbe59f1eac9a36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67383b45c782e11815cbe59f1eac9a36"></a>
typedef <a class="el" href="classcaffe2_1_1_observer_base.html">ObserverBase</a>&lt; <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NetObserver</b></td></tr>
<tr class="separator:a67383b45c782e11815cbe59f1eac9a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45628c528e48494f9eda62134261812a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45628c528e48494f9eda62134261812a"></a>
typedef std::function&lt; std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_observer_base.html">NetObserver</a> &gt;<a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NetObserverCreator</b></td></tr>
<tr class="separator:a45628c528e48494f9eda62134261812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef186a62d2ad09644bf50c3862e23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66ef186a62d2ad09644bf50c3862e23b"></a>
typedef <a class="el" href="classcaffe2_1_1_observer_base.html">ObserverBase</a>&lt; <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorObserver</b></td></tr>
<tr class="separator:a66ef186a62d2ad09644bf50c3862e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbef9a00ccdc1ee24311b5d26560d8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cbef9a00ccdc1ee24311b5d26560d8b"></a>
typedef <a class="el" href="classcaffe2_1_1_registry.html">Registry</a>&lt; std::string, std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a> &gt;, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> * &gt; *(*&#160;</td><td class="memItemRight" valign="bottom"><b>RegistryFunction</b>) ()</td></tr>
<tr class="separator:a4cbef9a00ccdc1ee24311b5d26560d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f8d16aa5d76f9f5363279130144d4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f8d16aa5d76f9f5363279130144d4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EnginePrefType</b> = std::vector&lt; std::string &gt;</td></tr>
<tr class="separator:a32f8d16aa5d76f9f5363279130144d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74488e9c3d6f6c317007ba43ad002bb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74488e9c3d6f6c317007ba43ad002bb7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PerOpEnginePrefType</b> = CaffeMap&lt; int, CaffeMap&lt; std::string, EnginePrefType &gt;&gt;</td></tr>
<tr class="separator:a74488e9c3d6f6c317007ba43ad002bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753fdc5b230c2f5b265e6ff694585353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a753fdc5b230c2f5b265e6ff694585353"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalEnginePrefType</b> = CaffeMap&lt; int, EnginePrefType &gt;</td></tr>
<tr class="separator:a753fdc5b230c2f5b265e6ff694585353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4d01f9e389d63213b288f4743b53c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f4d01f9e389d63213b288f4743b53c9"></a>
typedef std::function&lt; bool(int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ShouldContinue</b></td></tr>
<tr class="separator:a2f4d01f9e389d63213b288f4743b53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1578901c4027246db0d3e46305c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb1578901c4027246db0d3e46305c7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8eb1578901c4027246db0d3e46305c7f">ExportedStatList</a> = std::vector&lt; <a class="el" href="structcaffe2_1_1_exported_stat_value.html">ExportedStatValue</a> &gt;</td></tr>
<tr class="memdesc:a8eb1578901c4027246db0d3e46305c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds names and values of counters exported from a <a class="el" href="classcaffe2_1_1_stat_registry.html" title="Holds a map of atomic counters keyed by name. ">StatRegistry</a>. <br /></td></tr>
<tr class="separator:a8eb1578901c4027246db0d3e46305c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bc270d52b7b38692a572f374d13a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22bc270d52b7b38692a572f374d13a23"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExportedStatMap</b> = std::unordered_map&lt; std::string, int64_t &gt;</td></tr>
<tr class="separator:a22bc270d52b7b38692a572f374d13a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725818e3725cb338845b526d265a4b76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a725818e3725cb338845b526d265a4b76"></a>
typedef <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TensorCPU</b></td></tr>
<tr class="separator:a725818e3725cb338845b526d265a4b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019bdb3c7f9b31b06dbf91c93d245757"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a019bdb3c7f9b31b06dbf91c93d245757"></a>
typedef <a class="el" href="classcaffe2_1_1_type_meta.html">TypeMeta</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>TypeCall</b>) (const void *)</td></tr>
<tr class="separator:a019bdb3c7f9b31b06dbf91c93d245757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e88de5199d57a1f161561d6986bf53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e88de5199d57a1f161561d6986bf53"></a>
typedef vector&lt; TIndex &gt;(*&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInfoCall</b>) (const void *, bool *shares_data, size_t *capacity, DeviceOption *device)</td></tr>
<tr class="separator:af7e88de5199d57a1f161561d6986bf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f724c12ed347567a888cc1ef67d8b4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f724c12ed347567a888cc1ef67d8b4b"></a>
typedef intptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>CaffeTypeId</b></td></tr>
<tr class="separator:a2f724c12ed347567a888cc1ef67d8b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a25b5e5d3ab5a66a7f164a78abf0230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a25b5e5d3ab5a66a7f164a78abf0230"></a>
typedef half_float::half&#160;</td><td class="memItemRight" valign="bottom"><b>half</b></td></tr>
<tr class="separator:a7a25b5e5d3ab5a66a7f164a78abf0230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff77b5c650e323b6c60396dd8e3ef68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acff77b5c650e323b6c60396dd8e3ef68"></a>
typedef half&#160;</td><td class="memItemRight" valign="bottom"><b>DataType</b></td></tr>
<tr class="separator:acff77b5c650e323b6c60396dd8e3ef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f9d1cc1eb3ff7f371541e2dbf1cb3b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16f9d1cc1eb3ff7f371541e2dbf1cb3b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16f9d1cc1eb3ff7f371541e2dbf1cb3b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deleted_unique_ptr</b> = std::unique_ptr&lt; T, std::function&lt; void(T *)&gt;&gt;</td></tr>
<tr class="separator:a16f9d1cc1eb3ff7f371541e2dbf1cb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b09ff1b7f933ccafee91a37166f1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a843b09ff1b7f933ccafee91a37166f1f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParallelFor</b> = std::function&lt; void(size_t, std::function&lt; void(size_t)&gt;)&gt;</td></tr>
<tr class="separator:a843b09ff1b7f933ccafee91a37166f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea6e82ca849db18c8787d3b6120234c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea6e82ca849db18c8787d3b6120234c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NumericTypes</b> = <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; int32_t, int64_t, float, double &gt;</td></tr>
<tr class="separator:a2ea6e82ca849db18c8787d3b6120234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045ba250e9944f3f7811fd99dedaae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab045ba250e9944f3f7811fd99dedaae7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntTypes</b> = <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; int32_t, int64_t &gt;</td></tr>
<tr class="separator:ab045ba250e9944f3f7811fd99dedaae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa97ad24133ca3efbf5f8994d62f25c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aa97ad24133ca3efbf5f8994d62f25c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BoolTypes</b> = <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; bool &gt;</td></tr>
<tr class="separator:a0aa97ad24133ca3efbf5f8994d62f25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803395e5d8f74b61b36d4f92a6bb3c5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803395e5d8f74b61b36d4f92a6bb3c5b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntBoolTypes</b> = <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; int32_t, int64_t, bool &gt;</td></tr>
<tr class="separator:a803395e5d8f74b61b36d4f92a6bb3c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c84075c5d69ce9499450fbbb3f72965"><td class="memTemplParams" colspan="2">template&lt;typename InputTypes , class Context , class Functor , class OutputType  = SameTypeAsInput&gt; </td></tr>
<tr class="memitem:a3c84075c5d69ce9499450fbbb3f72965"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a> = <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>&lt; InputTypes, Context, <a class="el" href="structcaffe2_1_1_with_default_constructor.html">WithDefaultConstructor</a>&lt; Functor &gt;, OutputType &gt;</td></tr>
<tr class="memdesc:a3c84075c5d69ce9499450fbbb3f72965"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnaryElementwiseOp is a wrapper around <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>, with the difference that it takes a functor with default constructor, e.g.  <a href="#a3c84075c5d69ce9499450fbbb3f72965">More...</a><br /></td></tr>
<tr class="separator:a3c84075c5d69ce9499450fbbb3f72965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c51741b6fb1fcad46fd018a21f25cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3c51741b6fb1fcad46fd018a21f25cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>n</b> = 2</td></tr>
<tr class="separator:ad3c51741b6fb1fcad46fd018a21f25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af498b94e8bf308ff2f7a23dc58fb49e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af498b94e8bf308ff2f7a23dc58fb49e6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType64To64</b> = <a class="el" href="structcaffe2_1_1_map_type_traits.html">MapTypeTraits</a>&lt; int64_t, int64_t &gt;::MapType</td></tr>
<tr class="separator:af498b94e8bf308ff2f7a23dc58fb49e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d525a7195f5527ce4a3205004c76599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d525a7195f5527ce4a3205004c76599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType64To32</b> = <a class="el" href="structcaffe2_1_1_map_type_traits.html">MapTypeTraits</a>&lt; int64_t, int32_t &gt;::MapType</td></tr>
<tr class="separator:a8d525a7195f5527ce4a3205004c76599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63037963716071ea7e8f7b177542599"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab63037963716071ea7e8f7b177542599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType32To32</b> = <a class="el" href="structcaffe2_1_1_map_type_traits.html">MapTypeTraits</a>&lt; int32_t, int32_t &gt;::MapType</td></tr>
<tr class="separator:ab63037963716071ea7e8f7b177542599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37567932357954efed10a870ed2e6512"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37567932357954efed10a870ed2e6512"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType32To64</b> = <a class="el" href="structcaffe2_1_1_map_type_traits.html">MapTypeTraits</a>&lt; int32_t, int64_t &gt;::MapType</td></tr>
<tr class="separator:a37567932357954efed10a870ed2e6512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41406072a99cf57e0f8700827ce061c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af41406072a99cf57e0f8700827ce061c"></a>
template&lt;typename ScalarFunctor , typename TypeMap  = FixedType&lt;std::string&gt;&gt; </td></tr>
<tr class="memitem:af41406072a99cf57e0f8700827ce061c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StringElementwiseOp</b> = <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; std::string &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_for_each.html">ForEach</a>&lt; ScalarFunctor &gt;, TypeMap &gt;</td></tr>
<tr class="separator:af41406072a99cf57e0f8700827ce061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55da53004c68821d605bc203b85329d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55da53004c68821d605bc203b85329d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RebatchingQueuePtr</b> = std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_rebatching_queue.html">RebatchingQueue</a> &gt;</td></tr>
<tr class="separator:a55da53004c68821d605bc203b85329d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a30cf33f52b2ac8ede56c7b9eade8714e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EArrXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca06381eb83d01882f3ddcf1ea9f85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05ca06381eb83d01882f3ddcf1ea9f85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXf</b> = Eigen::ArrayXf</td></tr>
<tr class="separator:a05ca06381eb83d01882f3ddcf1ea9f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9efee42e9d5416a76af6cbf52fef267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9efee42e9d5416a76af6cbf52fef267"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXd</b> = Eigen::ArrayXd</td></tr>
<tr class="separator:aa9efee42e9d5416a76af6cbf52fef267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bfd31737ed431da40d4c2d531fcab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57bfd31737ed431da40d4c2d531fcab4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXi</b> = Eigen::ArrayXi</td></tr>
<tr class="separator:a57bfd31737ed431da40d4c2d531fcab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423d78fd9e1ec22dc24119a52ffda491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a423d78fd9e1ec22dc24119a52ffda491"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXb</b> = EArrXt&lt; bool &gt;</td></tr>
<tr class="separator:a423d78fd9e1ec22dc24119a52ffda491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9545a4bb09336e69fb899e5b26268f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9545a4bb09336e69fb899e5b26268f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9545a4bb09336e69fb899e5b26268f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EArrXXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac9545a4bb09336e69fb899e5b26268f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0489b43c6cb59022a125b7d2f7f3b60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0489b43c6cb59022a125b7d2f7f3b60"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXXf</b> = Eigen::ArrayXXf</td></tr>
<tr class="separator:ae0489b43c6cb59022a125b7d2f7f3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668da8c72dfbee70c634752ddfc2cca2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a668da8c72dfbee70c634752ddfc2cca2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a668da8c72dfbee70c634752ddfc2cca2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ERArrXXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a668da8c72dfbee70c634752ddfc2cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858fbd0105e125f947d8e0c7cc6fa2f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858fbd0105e125f947d8e0c7cc6fa2f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERArrXXf</b> = ERArrXXt&lt; float &gt;</td></tr>
<tr class="separator:a858fbd0105e125f947d8e0c7cc6fa2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac860d4911dfc0d4a14d04ab836a115ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EVecXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28be7f7774b322d8713c8cab499bb0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28be7f7774b322d8713c8cab499bb0f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EVecXd</b> = Eigen::VectorXd</td></tr>
<tr class="separator:af28be7f7774b322d8713c8cab499bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91be26e88343892f4a0f864167a8cb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac91be26e88343892f4a0f864167a8cb0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EVecXf</b> = Eigen::VectorXf</td></tr>
<tr class="separator:ac91be26e88343892f4a0f864167a8cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb33befb475f7d9486815061285e6d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb33befb475f7d9486815061285e6d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERVecXd</b> = Eigen::RowVectorXd</td></tr>
<tr class="separator:a7fb33befb475f7d9486815061285e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e9747ffe824ff7d21b13fdbac6fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b2e9747ffe824ff7d21b13fdbac6fd6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERVecXf</b> = Eigen::RowVectorXf</td></tr>
<tr class="separator:a5b2e9747ffe824ff7d21b13fdbac6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ddc117686768238b132b3cb9928d30"><td class="memTemplParams" colspan="2"><a class="anchor" id="a03ddc117686768238b132b3cb9928d30"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03ddc117686768238b132b3cb9928d30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EMatXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a03ddc117686768238b132b3cb9928d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2568e3d8fe1b68cb6e98b9f14c7c26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b2568e3d8fe1b68cb6e98b9f14c7c26"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EMatXd</b> = Eigen::MatrixXd</td></tr>
<tr class="separator:a4b2568e3d8fe1b68cb6e98b9f14c7c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675336bbaa8dedbc5a26b534f90b41e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675336bbaa8dedbc5a26b534f90b41e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EMatXf</b> = Eigen::MatrixXf</td></tr>
<tr class="separator:a675336bbaa8dedbc5a26b534f90b41e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22b24c4c79d9860bef56bcdfe2a9ee6a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ERMatXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c0c7b7a26e639dd9be7d459a1bd529"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77c0c7b7a26e639dd9be7d459a1bd529"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERMatXd</b> = ERMatXt&lt; double &gt;</td></tr>
<tr class="separator:a77c0c7b7a26e639dd9be7d459a1bd529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545c2cf90bb5aa1136ddfdf1b755038"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5545c2cf90bb5aa1136ddfdf1b755038"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERMatXf</b> = ERMatXt&lt; float &gt;</td></tr>
<tr class="separator:a5545c2cf90bb5aa1136ddfdf1b755038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa01f0e599fb011f4cd55ea0a7e1169e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenMatrixMap</b> = Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70478f546b3044ecfcc2a2ab379153b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a70478f546b3044ecfcc2a2ab379153b2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70478f546b3044ecfcc2a2ab379153b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenArrayMap</b> = Eigen::Map&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:a70478f546b3044ecfcc2a2ab379153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8bb2d742f2156267399d8fea975888"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d8bb2d742f2156267399d8fea975888"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d8bb2d742f2156267399d8fea975888"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorMap</b> = Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a7d8bb2d742f2156267399d8fea975888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781edb0b02a5558c8baa2075b048c13a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a781edb0b02a5558c8baa2075b048c13a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a781edb0b02a5558c8baa2075b048c13a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorArrayMap</b> = Eigen::Map&lt; Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a781edb0b02a5558c8baa2075b048c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04585a2e7965b83d474a987672b6445"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae04585a2e7965b83d474a987672b6445"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae04585a2e7965b83d474a987672b6445"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenMatrixMap</b> = Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:ae04585a2e7965b83d474a987672b6445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b1f5212067cc87214b2049548314e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a062b1f5212067cc87214b2049548314e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a062b1f5212067cc87214b2049548314e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenArrayMap</b> = Eigen::Map&lt; const Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:a062b1f5212067cc87214b2049548314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a9803232f8e9983dcd413b34e9675"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac78a9803232f8e9983dcd413b34e9675"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac78a9803232f8e9983dcd413b34e9675"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenVectorMap</b> = Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:ac78a9803232f8e9983dcd413b34e9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9463d86090bda53ec0ff21a03596332e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9463d86090bda53ec0ff21a03596332e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9463d86090bda53ec0ff21a03596332e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenVectorArrayMap</b> = Eigen::Map&lt; const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a9463d86090bda53ec0ff21a03596332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac973c115b0c808cb638fe0262823ec48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac973c115b0c808cb638fe0262823ec48"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CudaMemoryPoolType</b> { <b>NONE</b> = 0, 
<b>CUB</b> = 1
 }</td></tr>
<tr class="separator:ac973c115b0c808cb638fe0262823ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636c061e50a818d89fa07008067420ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a636c061e50a818d89fa07008067420ff"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventStatus</b> { <b>EVENT_INITIALIZED</b> = 0, 
<b>EVENT_SCHEDULED</b> = 1, 
<b>EVENT_SUCCESS</b> = 2, 
<b>EVENT_FAILED</b> = 3
 }</td></tr>
<tr class="separator:a636c061e50a818d89fa07008067420ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e17b4d7a08766797f73811bf8fd21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25e17b4d7a08766797f73811bf8fd21"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StorageOrder</b> { <b>UNKNOWN</b> = 0, 
<b>NHWC</b> = 1, 
<b>NCHW</b> = 2
 }</td></tr>
<tr class="separator:aa25e17b4d7a08766797f73811bf8fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2d911d4adc1f538c19797d44660e7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f2d911d4adc1f538c19797d44660e7d"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>ALGO_FWD</b> = 0, 
<b>ALGO_WGRAD</b> = 1, 
<b>ALGO_DGRAD</b> = 2
 }</td></tr>
<tr class="separator:a1f2d911d4adc1f538c19797d44660e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18517bbe9b4899f83107e74f7a8e7544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18517bbe9b4899f83107e74f7a8e7544"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PadMode</b> { <b>CONSTANT</b> = 0, 
<b>REFLECT</b> = 1, 
<b>EDGE</b> = 2
 }</td></tr>
<tr class="separator:a18517bbe9b4899f83107e74f7a8e7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d3588b4cedfae0bc093b8c14038db4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d3588b4cedfae0bc093b8c14038db4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>QuantDecodeRunTy</b> { <b>RUN_ALWAYS</b>, 
<b>RUN_ONCE</b>
 }</td></tr>
<tr class="separator:ae6d3588b4cedfae0bc093b8c14038db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf872d0c5886a30aa362374395abd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68bf872d0c5886a30aa362374395abd4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RecurrentParamOpMode</b> { <b>SET_PARAM</b>, 
<b>GET_PARAM</b>
 }</td></tr>
<tr class="separator:a68bf872d0c5886a30aa362374395abd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7be8290b439c790c5f304286cc877a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d7be8290b439c790c5f304286cc877a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FLowAlgType</b> { <b>FarnebackOpticalFlow</b> = 0, 
<b>DensePyrLKOpticalFlow</b> = 1, 
<b>BroxOpticalFlow</b> = 2, 
<b>OpticalFlowDual_TVL1</b> = 3
 }</td></tr>
<tr class="separator:a6d7be8290b439c790c5f304286cc877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed100c8a2b5b0cab3470d046f5fb8ee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed100c8a2b5b0cab3470d046f5fb8ee5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FlowDataType</b> { <b>Flow2C</b> = 0, 
<b>Flow3C</b> = 1, 
<b>FlowWithGray</b> = 2, 
<b>FlowWithRGB</b> = 3
 }</td></tr>
<tr class="separator:aed100c8a2b5b0cab3470d046f5fb8ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af665e0722cfd3ab685a8c41d47dc9d77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af665e0722cfd3ab685a8c41d47dc9d77"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpecialFps</b> { <b>SAMPLE_NO_FRAME</b> = 0, 
<b>SAMPLE_ALL_FRAMES</b> = -1, 
<b>SAMPLE_TIMESTAMP_ONLY</b> = -2
 }</td></tr>
<tr class="separator:af665e0722cfd3ab685a8c41d47dc9d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefa7f39f0186e26042ce8ac22b7cb83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acefa7f39f0186e26042ce8ac22b7cb83"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>VideoResType</b> { <b>USE_WIDTH_HEIGHT</b> = 0, 
<b>USE_MINIMAL_WIDTH_HEIGHT</b> = 1, 
<b>ORIGINAL_RES</b> = 2
 }</td></tr>
<tr class="separator:acefa7f39f0186e26042ce8ac22b7cb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340bb1b8d1972f340913e1eefb06e8de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340bb1b8d1972f340913e1eefb06e8de"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DecodeType</b> { <b>DO_TMP_JITTER</b> = 0, 
<b>DO_UNIFORM_SMP</b> = 1, 
<b>USE_START_FRM</b> = 2
 }</td></tr>
<tr class="separator:a340bb1b8d1972f340913e1eefb06e8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58b6a67aa6f46d1518d6752955ab92fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58b6a67aa6f46d1518d6752955ab92fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertToRawDataset</b> (const string &amp;input_db_name, const string &amp;output_db_name)</td></tr>
<tr class="separator:a58b6a67aa6f46d1518d6752955ab92fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d283b84e27caae9f7e8160fa9dd0d91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d283b84e27caae9f7e8160fa9dd0d91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReadImage</b> (std::ifstream *file, int *label, char *buffer)</td></tr>
<tr class="separator:a7d283b84e27caae9f7e8160fa9dd0d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718615c5cb01902ac0d530fa190f6a29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a718615c5cb01902ac0d530fa190f6a29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteToDB</b> (const string &amp;filename, const int num_items, const int &amp;offset, <a class="el" href="classcaffe2_1_1db_1_1_d_b.html">db::DB</a> *db)</td></tr>
<tr class="separator:a718615c5cb01902ac0d530fa190f6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57ad87163474085d886931920e539c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af57ad87163474085d886931920e539c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertCIFAR</b> ()</td></tr>
<tr class="separator:af57ad87163474085d886931920e539c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8458f4e5bd1f3f8147feb42fcba53338"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8458f4e5bd1f3f8147feb42fcba53338"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertImageDataset</b> (const string &amp;input_folder, const string &amp;list_filename, const string &amp;output_db_name, const bool)</td></tr>
<tr class="separator:a8458f4e5bd1f3f8147feb42fcba53338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1098b342cfbdc5ed5ff70419d50b38bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1098b342cfbdc5ed5ff70419d50b38bb"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>swap_endian</b> (uint32_t val)</td></tr>
<tr class="separator:a1098b342cfbdc5ed5ff70419d50b38bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed294171c927c0538aff40a864baded9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed294171c927c0538aff40a864baded9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert_dataset</b> (const char *image_filename, const char *label_filename, const char *db_path, const int data_limit)</td></tr>
<tr class="separator:aed294171c927c0538aff40a864baded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da950463d9578262d08f0909123b89d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4da950463d9578262d08f0909123b89d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> ()</td></tr>
<tr class="separator:a4da950463d9578262d08f0909123b89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4acc031c77a7a52474ecebb27d4c12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d4acc031c77a7a52474ecebb27d4c12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NoDelete</b> (void *)</td></tr>
<tr class="separator:a5d4acc031c77a7a52474ecebb27d4c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e1860b04c0c9d04bd656d81153b88f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e1860b04c0c9d04bd656d81153b88f"></a>
<a class="el" href="structcaffe2_1_1_c_p_u_allocator.html">CPUAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetCPUAllocator</b> ()</td></tr>
<tr class="separator:aa2e1860b04c0c9d04bd656d81153b88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ecddad3e5d38fc82a87f24dd5612d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c2ecddad3e5d38fc82a87f24dd5612d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCPUAllocator</b> (<a class="el" href="structcaffe2_1_1_c_p_u_allocator.html">CPUAllocator</a> *alloc)</td></tr>
<tr class="separator:a0c2ecddad3e5d38fc82a87f24dd5612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ba5ddb3cab35a4fef6962b772a704d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5ba5ddb3cab35a4fef6962b772a704d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classcaffe2_1_1_blob.html">Blob</a> &amp;lhs, <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> &amp;rhs)</td></tr>
<tr class="separator:af5ba5ddb3cab35a4fef6962b772a704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4cd40abba15199fddb90a70b9721aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d4cd40abba15199fddb90a70b9721aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_TYPED_REGISTRY</b> (BlobSerializerRegistry, CaffeTypeId, <a class="el" href="classcaffe2_1_1_blob_serializer_base.html">BlobSerializerBase</a>, std::unique_ptr)</td></tr>
<tr class="separator:a8d4cd40abba15199fddb90a70b9721aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7339c9cdaff1557f10b6e6e60dfd69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade7339c9cdaff1557f10b6e6e60dfd69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (BlobDeserializerRegistry, <a class="el" href="classcaffe2_1_1_blob_deserializer_base.html">BlobDeserializerBase</a>)</td></tr>
<tr class="separator:ade7339c9cdaff1557f10b6e6e60dfd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c55429ea913c64ad677f1dadc17dfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c55429ea913c64ad677f1dadc17dfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_TYPED_REGISTRY</b> (BlobSerializerRegistry, CaffeTypeId, <a class="el" href="classcaffe2_1_1_blob_serializer_base.html">BlobSerializerBase</a>, std::unique_ptr)</td></tr>
<tr class="separator:a98c55429ea913c64ad677f1dadc17dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad66001d7ab648f9e6a07ebb9e914e93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad66001d7ab648f9e6a07ebb9e914e93"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1_blob_serializer_base.html">BlobSerializerBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSerializer</b> (CaffeTypeId id)</td></tr>
<tr class="separator:aad66001d7ab648f9e6a07ebb9e914e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746ef482c7ec2bd96d0569cb55e8f74a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746ef482c7ec2bd96d0569cb55e8f74a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (BlobDeserializerRegistry, <a class="el" href="classcaffe2_1_1_blob_deserializer_base.html">BlobDeserializerBase</a>)</td></tr>
<tr class="separator:a746ef482c7ec2bd96d0569cb55e8f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab22598778f6a6b1817b0081f79a8195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab22598778f6a6b1817b0081f79a8195"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1_blob_deserializer_base.html">BlobDeserializerBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateDeserializer</b> (const string &amp;type)</td></tr>
<tr class="separator:aab22598778f6a6b1817b0081f79a8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7615da9e915dc78d5bec46fd6be778e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7615da9e915dc78d5bec46fd6be778e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasCudaRuntime</b> ()</td></tr>
<tr class="separator:a7615da9e915dc78d5bec46fd6be778e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198d55b1f81063933bfff4f66ff819e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a198d55b1f81063933bfff4f66ff819e4"></a>
const std::map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBuildOptions</b> ()</td></tr>
<tr class="separator:a198d55b1f81063933bfff4f66ff819e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceeaed4853a8fe83f17f6f5754d5de5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ceeaed4853a8fe83f17f6f5754d5de5"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a9ceeaed4853a8fe83f17f6f5754d5de5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a9ceeaed4853a8fe83f17f6f5754d5de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34b77c9dbea4e60718a4f2cf2c7a6b06"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (const size_t n)</td></tr>
<tr class="separator:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af206045e6c725a1a3819e9647fae85bc"><td class="memTemplParams" colspan="2"><a class="anchor" id="af206045e6c725a1a3819e9647fae85bc"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af206045e6c725a1a3819e9647fae85bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::extent&lt; T &gt;::value!=0, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;...)=delete</td></tr>
<tr class="separator:af206045e6c725a1a3819e9647fae85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc93877ba8e3cb6ad6f874582a22da80"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc93877ba8e3cb6ad6f874582a22da80"></a>
template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:acc93877ba8e3cb6ad6f874582a22da80"><td class="memTemplItemLeft" align="right" valign="top">Dst&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_cast_if_rtti</b> (Src ptr)</td></tr>
<tr class="separator:acc93877ba8e3cb6ad6f874582a22da80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4413739415b39b948f054531e05544e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4413739415b39b948f054531e05544e0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cudnnCompiledVersion</b> ()</td></tr>
<tr class="separator:a4413739415b39b948f054531e05544e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea2b165a0f944edbd54cf85fe841b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eea2b165a0f944edbd54cf85fe841b4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cudnnRuntimeVersion</b> ()</td></tr>
<tr class="separator:a0eea2b165a0f944edbd54cf85fe841b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd772f611b05663e9ea099d31e6bb53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbd772f611b05663e9ea099d31e6bb53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckCuDNNVersions</b> ()</td></tr>
<tr class="separator:adbd772f611b05663e9ea099d31e6bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87a6f5f6d9bed583a8e4db51d96c854b"></a>
cudnnTensorFormat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a87a6f5f6d9bed583a8e4db51d96c854b">GetCudnnTensorFormat</a> (const StorageOrder &amp;order)</td></tr>
<tr class="memdesc:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function to convert the Caffe storage order to cudnn storage order enum values. <br /></td></tr>
<tr class="separator:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d0dba0f4c170fc7d3c588d1e57b8329"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a6d0dba0f4c170fc7d3c588d1e57b8329">NumCudaDevices</a> ()</td></tr>
<tr class="memdesc:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of devices. <br /></td></tr>
<tr class="separator:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461eced97a6ba2c1959ba262f1a3a3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad461eced97a6ba2c1959ba262f1a3a3c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetDefaultGPUID</b> (const int deviceid)</td></tr>
<tr class="separator:ad461eced97a6ba2c1959ba262f1a3a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cd1e125dba2165f692bc0b681cf0a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7cd1e125dba2165f692bc0b681cf0a5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetDefaultGPUID</b> ()</td></tr>
<tr class="separator:af7cd1e125dba2165f692bc0b681cf0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6850a4a5f4298a5c825238cfb0de688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af6850a4a5f4298a5c825238cfb0de688">CaffeCudaGetDevice</a> ()</td></tr>
<tr class="memdesc:af6850a4a5f4298a5c825238cfb0de688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current GPU id.  <a href="#af6850a4a5f4298a5c825238cfb0de688">More...</a><br /></td></tr>
<tr class="separator:af6850a4a5f4298a5c825238cfb0de688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff145698c872153a4e117f0e2101f09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aff145698c872153a4e117f0e2101f09a">CaffeCudaSetDevice</a> (const int id)</td></tr>
<tr class="memdesc:aff145698c872153a4e117f0e2101f09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current GPU id.  <a href="#aff145698c872153a4e117f0e2101f09a">More...</a><br /></td></tr>
<tr class="separator:aff145698c872153a4e117f0e2101f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fded6ff24bcf074e5c78701ebe70f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47fded6ff24bcf074e5c78701ebe70f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a47fded6ff24bcf074e5c78701ebe70f2">GetGPUIDForPointer</a> (const void *ptr)</td></tr>
<tr class="memdesc:a47fded6ff24bcf074e5c78701ebe70f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GPU id that the current pointer is located at. <br /></td></tr>
<tr class="separator:a47fded6ff24bcf074e5c78701ebe70f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461b286b4d2322c82a6f43fa00c8034"><td class="memItemLeft" align="right" valign="top">const cudaDeviceProp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad461b286b4d2322c82a6f43fa00c8034">GetDeviceProperty</a> (const int device)</td></tr>
<tr class="memdesc:ad461b286b4d2322c82a6f43fa00c8034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device property for the given device.  <a href="#ad461b286b4d2322c82a6f43fa00c8034">More...</a><br /></td></tr>
<tr class="separator:ad461b286b4d2322c82a6f43fa00c8034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3575c7b3b60d12fd9323082093708d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3575c7b3b60d12fd9323082093708d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#adc3575c7b3b60d12fd9323082093708d">DeviceQuery</a> (const int deviceid)</td></tr>
<tr class="memdesc:adc3575c7b3b60d12fd9323082093708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a device query function and prints out the results to LOG(INFO). <br /></td></tr>
<tr class="separator:adc3575c7b3b60d12fd9323082093708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446da244aca2a8c6808963912cd5cdfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a446da244aca2a8c6808963912cd5cdfc">GetCudaPeerAccessPattern</a> (vector&lt; vector&lt; bool &gt; &gt; *pattern)</td></tr>
<tr class="memdesc:a446da244aca2a8c6808963912cd5cdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a peer access pattern by returning a matrix (in the format of a nested vector) of boolean values specifying whether peer access is possible.  <a href="#a446da244aca2a8c6808963912cd5cdfc">More...</a><br /></td></tr>
<tr class="separator:a446da244aca2a8c6808963912cd5cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9185fa7304a1a5553a05fee40830c43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9185fa7304a1a5553a05fee40830c43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ac9185fa7304a1a5553a05fee40830c43">TensorCoreAvailable</a> ()</td></tr>
<tr class="memdesc:ac9185fa7304a1a5553a05fee40830c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the availability of TensorCores for math. <br /></td></tr>
<tr class="separator:ac9185fa7304a1a5553a05fee40830c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab643532704982b9c6cd53fefb8c9015d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab643532704982b9c6cd53fefb8c9015d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ab643532704982b9c6cd53fefb8c9015d">cublasGetErrorString</a> (cublasStatus_t error)</td></tr>
<tr class="memdesc:ab643532704982b9c6cd53fefb8c9015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human readable cublas error string. <br /></td></tr>
<tr class="separator:ab643532704982b9c6cd53fefb8c9015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cd40a0417e6ec30c62f7fb8b49aa031"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8cd40a0417e6ec30c62f7fb8b49aa031">curandGetErrorString</a> (curandStatus_t error)</td></tr>
<tr class="memdesc:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human readable curand error string. <br /></td></tr>
<tr class="separator:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad503e334918c94362ff2758be80b0f56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad503e334918c94362ff2758be80b0f56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad503e334918c94362ff2758be80b0f56">CudaVersion</a> ()</td></tr>
<tr class="memdesc:ad503e334918c94362ff2758be80b0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime function to report the cuda version that Caffe2 is built with. <br /></td></tr>
<tr class="separator:ad503e334918c94362ff2758be80b0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48638afbef9a25309bf7ef40a6e97919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a48638afbef9a25309bf7ef40a6e97919">HasCudaGPU</a> ()</td></tr>
<tr class="memdesc:a48638afbef9a25309bf7ef40a6e97919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current running session has a cuda gpu present.  <a href="#a48638afbef9a25309bf7ef40a6e97919">More...</a><br /></td></tr>
<tr class="separator:a48638afbef9a25309bf7ef40a6e97919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bf47b9067ef9d15605a5d8746fddd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7bf47b9067ef9d15605a5d8746fddd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#afa7bf47b9067ef9d15605a5d8746fddd">CAFFE_GET_BLOCKS</a> (const int N)</td></tr>
<tr class="memdesc:afa7bf47b9067ef9d15605a5d8746fddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of blocks needed to run N threads. <br /></td></tr>
<tr class="separator:afa7bf47b9067ef9d15605a5d8746fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c78e5303c2458a8799e4e9293b8d9ff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a6c78e5303c2458a8799e4e9293b8d9ff">RandomNumberSeed</a> ()</td></tr>
<tr class="memdesc:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to generate a random number seed that is unique in a best-effort basis, using an ever-incrementing seed and the current time. <br /></td></tr>
<tr class="separator:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37066071313fa865f8b2d22b900b3a3"><td class="memItemLeft" align="right" valign="top">CudaMemoryPoolType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad37066071313fa865f8b2d22b900b3a3">GetCudaMemoryPoolType</a> ()</td></tr>
<tr class="memdesc:ad37066071313fa865f8b2d22b900b3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current memory pool type used by Caffe2.  <a href="#ad37066071313fa865f8b2d22b900b3a3">More...</a><br /></td></tr>
<tr class="separator:ad37066071313fa865f8b2d22b900b3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bf17d6878d8180468f6127da0470a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19bf17d6878d8180468f6127da0470a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1db_1_1_d_b_reader.html">db::DBReader</a>)</td></tr>
<tr class="separator:a19bf17d6878d8180468f6127da0470a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9fe276cadd651f79cbaee58b726b6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade9fe276cadd651f79cbaee58b726b6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1db_1_1_cursor.html">db::Cursor</a>)</td></tr>
<tr class="separator:ade9fe276cadd651f79cbaee58b726b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4b1ea830ff2a0a9974aa19e3e03278"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4b1ea830ff2a0a9974aa19e3e03278"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateCPU</b> (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a9d4b1ea830ff2a0a9974aa19e3e03278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7d1b36073478d998eb6cdcfc4fe4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75f7d1b36073478d998eb6cdcfc4fe4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordCPU</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, const void *, const char *err_msg)</td></tr>
<tr class="separator:a75f7d1b36073478d998eb6cdcfc4fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd03a6ca080d94dabbe360bd9758bb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affd03a6ca080d94dabbe360bd9758bb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:affd03a6ca080d94dabbe360bd9758bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99f40be4b3bad6406d09e22e8186c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c99f40be4b3bad6406d09e22e8186c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCPUCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, void *)</td></tr>
<tr class="separator:a5c99f40be4b3bad6406d09e22e8186c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eae3b94f5eb50129a2bae2d0062652d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eae3b94f5eb50129a2bae2d0062652d"></a>
EventStatus&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a3eae3b94f5eb50129a2bae2d0062652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf052f727ddbc93e195ea78ed514fca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf052f727ddbc93e195ea78ed514fca2"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:acf052f727ddbc93e195ea78ed514fca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0984479c946c8930de5f673a0f08b688"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0984479c946c8930de5f673a0f08b688"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, const char *err_msg)</td></tr>
<tr class="separator:a0984479c946c8930de5f673a0f08b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b96d1579b04ccabf7b36290922ff49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92b96d1579b04ccabf7b36290922ff49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetCPU</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a92b96d1579b04ccabf7b36290922ff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a5e31dbda40b6d4b59e79fa1f4a690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a5e31dbda40b6d4b59e79fa1f4a690"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (CPU, EventCreateCPU)</td></tr>
<tr class="separator:a00a5e31dbda40b6d4b59e79fa1f4a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc4485f5e8424c1b31a81e3bd72942e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dc4485f5e8424c1b31a81e3bd72942e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (CPU, EventRecordCPU)</td></tr>
<tr class="separator:a6dc4485f5e8424c1b31a81e3bd72942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4981591aaa121f0fff77ec2053c7db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4981591aaa121f0fff77ec2053c7db1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, CPU, EventWaitCPUCPU)</td></tr>
<tr class="separator:ab4981591aaa121f0fff77ec2053c7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6346ec5ed3c38916277dc2924697cd97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6346ec5ed3c38916277dc2924697cd97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (CPU, EventFinishCPU)</td></tr>
<tr class="separator:a6346ec5ed3c38916277dc2924697cd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2260c24ce5245586014356a3ef7fd7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2260c24ce5245586014356a3ef7fd7e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (CPU, EventQueryCPU)</td></tr>
<tr class="separator:a2260c24ce5245586014356a3ef7fd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139290fdee69ebbe8e58a01bb13335c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac139290fdee69ebbe8e58a01bb13335c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (CPU, EventErrorMessageCPU)</td></tr>
<tr class="separator:ac139290fdee69ebbe8e58a01bb13335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09e628a4b0f62bc690c400226f4e7ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae09e628a4b0f62bc690c400226f4e7ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (CPU, EventSetFinishedCPU)</td></tr>
<tr class="separator:ae09e628a4b0f62bc690c400226f4e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414fc5a843cacb019fddc19c8187f25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3414fc5a843cacb019fddc19c8187f25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (CPU, EventResetCPU)</td></tr>
<tr class="separator:a3414fc5a843cacb019fddc19c8187f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e593e92c534d0f613b2af800cf9884"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2e593e92c534d0f613b2af800cf9884"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EventCanScheduleCPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *, const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:af2e593e92c534d0f613b2af800cf9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de9b96755ed2723ceb0ff02f00fbc23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de9b96755ed2723ceb0ff02f00fbc23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateCUDA</b> (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a3de9b96755ed2723ceb0ff02f00fbc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794d72658b8f476fba85fb48907a7adb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a794d72658b8f476fba85fb48907a7adb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordCUDA</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, const void *context, const char *err_msg)</td></tr>
<tr class="separator:a794d72658b8f476fba85fb48907a7adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fd1eefd56e92d17a96827f412c8b97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69fd1eefd56e92d17a96827f412c8b97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishCUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a69fd1eefd56e92d17a96827f412c8b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7285207a6b79ac4af4472864e576eca8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7285207a6b79ac4af4472864e576eca8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCUDACUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a7285207a6b79ac4af4472864e576eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3dca82a96fb8e14eb7583b939d8833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b3dca82a96fb8e14eb7583b939d8833"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCPUCUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a5b3dca82a96fb8e14eb7583b939d8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d45b996821cb7a03ab14362677c4901"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d45b996821cb7a03ab14362677c4901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCUDACPU</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a5d45b996821cb7a03ab14362677c4901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8672bcd27a7661125fb9431a1ddf5e44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8672bcd27a7661125fb9431a1ddf5e44"></a>
EventStatus&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryCUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a8672bcd27a7661125fb9431a1ddf5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72aee3b598a5be153cd54ff7b0a6c2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae72aee3b598a5be153cd54ff7b0a6c2e"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageCUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:ae72aee3b598a5be153cd54ff7b0a6c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0efdbd1ae450464c4ab064a5a96a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6f0efdbd1ae450464c4ab064a5a96a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedCUDA</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *event, const char *err_msg)</td></tr>
<tr class="separator:ad6f0efdbd1ae450464c4ab064a5a96a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0679eb8b591c7cdaa9dca7fd22623"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24f0679eb8b591c7cdaa9dca7fd22623"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetCUDA</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *event)</td></tr>
<tr class="separator:a24f0679eb8b591c7cdaa9dca7fd22623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29709ed5cbb863dcef6dc6f0f9a431c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab29709ed5cbb863dcef6dc6f0f9a431c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (CUDA, EventCreateCUDA)</td></tr>
<tr class="separator:ab29709ed5cbb863dcef6dc6f0f9a431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff021463f822f8104037da552a9da48c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff021463f822f8104037da552a9da48c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (CUDA, EventRecordCUDA)</td></tr>
<tr class="separator:aff021463f822f8104037da552a9da48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9838e883f710f448e898c734b08ce625"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9838e883f710f448e898c734b08ce625"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, CUDA, EventWaitCUDACUDA)</td></tr>
<tr class="separator:a9838e883f710f448e898c734b08ce625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31748deb693ec49b1cd132be1805154b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31748deb693ec49b1cd132be1805154b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, CUDA, EventWaitCPUCUDA)</td></tr>
<tr class="separator:a31748deb693ec49b1cd132be1805154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeeb42807c3d26a7acbf45b9b3bd429"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfeeb42807c3d26a7acbf45b9b3bd429"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, CPU, EventWaitCUDACPU)</td></tr>
<tr class="separator:abfeeb42807c3d26a7acbf45b9b3bd429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eac45930baf700f459675b6168bc06f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eac45930baf700f459675b6168bc06f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (CUDA, EventFinishCUDA)</td></tr>
<tr class="separator:a1eac45930baf700f459675b6168bc06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5d1cbe96083f03045fd24c70315fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb5d1cbe96083f03045fd24c70315fe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (CUDA, EventQueryCUDA)</td></tr>
<tr class="separator:acb5d1cbe96083f03045fd24c70315fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601ead593addd6ab87afa33b4f4f07da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a601ead593addd6ab87afa33b4f4f07da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (CUDA, EventErrorMessageCUDA)</td></tr>
<tr class="separator:a601ead593addd6ab87afa33b4f4f07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740e501891c7ea922b6749a34ee3786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af740e501891c7ea922b6749a34ee3786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (CUDA, EventSetFinishedCUDA)</td></tr>
<tr class="separator:af740e501891c7ea922b6749a34ee3786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffea44cea509815a7d0f847fc19249"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17ffea44cea509815a7d0f847fc19249"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (CUDA, EventResetCUDA)</td></tr>
<tr class="separator:a17ffea44cea509815a7d0f847fc19249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb30314b2436a9057a0e3f2d879e7a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb30314b2436a9057a0e3f2d879e7a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, CUDA, EventWaitCPUCUDA)</td></tr>
<tr class="separator:a7eb30314b2436a9057a0e3f2d879e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf69c6112545964ab825636acdea35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bf69c6112545964ab825636acdea35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, MKLDNN, EventWaitCUDACPU)</td></tr>
<tr class="separator:a07bf69c6112545964ab825636acdea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c918914ad19dfdc4de9104e1d857ce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c918914ad19dfdc4de9104e1d857ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (Caffe2FlagsRegistry, <a class="el" href="classcaffe2_1_1_caffe2_flag_parser.html">Caffe2FlagParser</a>, const string &amp;)</td></tr>
<tr class="separator:a8c918914ad19dfdc4de9104e1d857ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7137b079a7505ca39c44d7441c3296"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace7137b079a7505ca39c44d7441c3296"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ace7137b079a7505ca39c44d7441c3296">SetUsageMessage</a> (const string &amp;str)</td></tr>
<tr class="memdesc:ace7137b079a7505ca39c44d7441c3296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the usage message when a commandline tool is called with "--help". <br /></td></tr>
<tr class="separator:ace7137b079a7505ca39c44d7441c3296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5df9421b2b851cffabdd3fa2bd728c9f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5df9421b2b851cffabdd3fa2bd728c9f">UsageMessage</a> ()</td></tr>
<tr class="memdesc:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage message for the commandline tool set by SetUsageMessage. <br /></td></tr>
<tr class="separator:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a658a8d4d5b33a86502f0fbc5d2b82541">ParseCaffeCommandLineFlags</a> (int *pargc, char ***pargv)</td></tr>
<tr class="memdesc:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the commandline flags.  <a href="#a658a8d4d5b33a86502f0fbc5d2b82541">More...</a><br /></td></tr>
<tr class="separator:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b58d2c0360268ab3b52443589b80e9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b58d2c0360268ab3b52443589b80e9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3b58d2c0360268ab3b52443589b80e9c">CommandLineFlagsHasBeenParsed</a> ()</td></tr>
<tr class="memdesc:a3b58d2c0360268ab3b52443589b80e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the commandline flags has already been passed. <br /></td></tr>
<tr class="separator:a3b58d2c0360268ab3b52443589b80e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d573fad756ed21b40fe73fd2eadbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b4d573fad756ed21b40fe73fd2eadbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (Caffe2FlagsRegistry, <a class="el" href="classcaffe2_1_1_caffe2_flag_parser.html">Caffe2FlagParser</a>, const string &amp;)</td></tr>
<tr class="separator:a5b4d573fad756ed21b40fe73fd2eadbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161731ce245f3b733e2e1fd555a5326"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3161731ce245f3b733e2e1fd555a5326"></a>
OperatorDef *&#160;</td><td class="memItemRight" valign="bottom"><b>AddOp</b> (NetDef *netdef_ptr, string op_type, std::vector&lt; string &gt; inputs, std::vector&lt; string &gt; outputs)</td></tr>
<tr class="separator:a3161731ce245f3b733e2e1fd555a5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ae0b7e581ccd292b6b16296966cfbd7ff">MatchStrings</a> (string p, string s)</td></tr>
<tr class="memdesc:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows for the use of * and | to match operator types, engines, or any other property that is represented by strings.  <a href="#ae0b7e581ccd292b6b16296966cfbd7ff">More...</a><br /></td></tr>
<tr class="separator:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9693edd3666311a6d33e4418d7303"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b9693edd3666311a6d33e4418d7303"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a31b9693edd3666311a6d33e4418d7303">MatchArguments</a> (const OperatorDef &amp;p_op, const OperatorDef &amp;g_op)</td></tr>
<tr class="memdesc:a31b9693edd3666311a6d33e4418d7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ensures that each named arg that exists in the pattern exists in g_op, is equal in value. <br /></td></tr>
<tr class="separator:a31b9693edd3666311a6d33e4418d7303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af70b04a01a1779ddd61f9ef1e0a141b7">GlobalInit</a> (int *pargc, char ***argv)</td></tr>
<tr class="memdesc:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global environment of <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>.  <a href="#af70b04a01a1779ddd61f9ef1e0a141b7">More...</a><br /></td></tr>
<tr class="separator:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d56bd971638247dfed4ab7cd97fa6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9d56bd971638247dfed4ab7cd97fa6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Caffe2CheckIntrinsicsFeatures</b> (int *, char ***)</td></tr>
<tr class="separator:ad9d56bd971638247dfed4ab7cd97fa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6b100b9f9e1f38454aaf02fe09b62c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd6b100b9f9e1f38454aaf02fe09b62c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CAFFE2_INIT_FUNCTION</b> (Caffe2CheckIntrinsicsFeatures,&amp;Caffe2CheckIntrinsicsFeatures,&quot;Check intrinsics compatibility between the CPU feature and the binary.&quot;)</td></tr>
<tr class="separator:acd6b100b9f9e1f38454aaf02fe09b62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30ff68cebc0cbd475fc10144dcc3d56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab30ff68cebc0cbd475fc10144dcc3d56"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StripBasename</b> (const std::string &amp;full_path)</td></tr>
<tr class="separator:ab30ff68cebc0cbd475fc10144dcc3d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0125f70cf6a3e4b808a2dc917d117d18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0125f70cf6a3e4b808a2dc917d117d18"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceAll</b> (string &amp;s, const char *from, const char *to)</td></tr>
<tr class="separator:a0125f70cf6a3e4b808a2dc917d117d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51eae6c817ddb0658764ae96a87abcb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa51eae6c817ddb0658764ae96a87abcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStackTraceFetcher</b> (std::function&lt; string(void)&gt; fetcher)</td></tr>
<tr class="separator:aa51eae6c817ddb0658764ae96a87abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f5cade048cd641b438e217c5ffd53c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f5cade048cd641b438e217c5ffd53c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOperatorLogger</b> (std::function&lt; void(const OperatorDef &amp;)&gt; tracer)</td></tr>
<tr class="separator:a55f5cade048cd641b438e217c5ffd53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689f1461c549e57d526c5ee85345262"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0689f1461c549e57d526c5ee85345262"></a>
std::function&lt; void(const OperatorDef &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOperatorLogger</b> ()</td></tr>
<tr class="separator:a0689f1461c549e57d526c5ee85345262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad579e08bebd7b6f0460c6f21b17b23cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad579e08bebd7b6f0460c6f21b17b23cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>InitCaffeLogging</b> (int *argc, char **argv)</td></tr>
<tr class="separator:ad579e08bebd7b6f0460c6f21b17b23cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3123faf5c57e6b67b0d01cd2daa05bf1">ShowLogInfoToStderr</a> ()</td></tr>
<tr class="memdesc:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to allow one to show log info to stderr after the program starts.  <a href="#a3123faf5c57e6b67b0d01cd2daa05bf1">More...</a><br /></td></tr>
<tr class="separator:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532f6f77ac87359a65bcba171dc2850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6532f6f77ac87359a65bcba171dc2850"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsUsingGoogleLogging</b> ()</td></tr>
<tr class="separator:a6532f6f77ac87359a65bcba171dc2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ace8110cf57450540aee9097f037b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3ace8110cf57450540aee9097f037b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;)</td></tr>
<tr class="separator:aaf3ace8110cf57450540aee9097f037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc0a52fb0742a9008866bb4530534c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="acfc0a52fb0742a9008866bb4530534c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfc0a52fb0742a9008866bb4530534c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;ss, const T &amp;t)</td></tr>
<tr class="separator:acfc0a52fb0742a9008866bb4530534c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e6f8e360dedeb6a0fc1613a47b1b62"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad8e6f8e360dedeb6a0fc1613a47b1b62"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ad8e6f8e360dedeb6a0fc1613a47b1b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;ss, const T &amp;t, const Args &amp;...args)</td></tr>
<tr class="separator:ad8e6f8e360dedeb6a0fc1613a47b1b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2caef9c30393794fbfa7260e266688"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed2caef9c30393794fbfa7260e266688"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aed2caef9c30393794fbfa7260e266688"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeString</b> (const Args &amp;...args)</td></tr>
<tr class="separator:aed2caef9c30393794fbfa7260e266688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b98316c6bc179f2e613d013687ad8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a19b98316c6bc179f2e613d013687ad8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19b98316c6bc179f2e613d013687ad8b"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeString</b> (const string &amp;str)</td></tr>
<tr class="separator:a19b98316c6bc179f2e613d013687ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d804ca3a4903efe2d9dd279db8fb5cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d804ca3a4903efe2d9dd279db8fb5cb"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>MakeString</b> (const char *c_str)</td></tr>
<tr class="separator:a6d804ca3a4903efe2d9dd279db8fb5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memTemplParams" colspan="2"><a class="anchor" id="a96bc19c4fdfa9421b6ddc53e69c2ed31"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Join</b> (const string &amp;delimiter, const Container &amp;v)</td></tr>
<tr class="separator:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e169f501e34306201fc481d47e1f904"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6e169f501e34306201fc481d47e1f904"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e169f501e34306201fc481d47e1f904"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LogMessageFatal</b> (const char *file, int line, const T &amp;message)</td></tr>
<tr class="separator:a6e169f501e34306201fc481d47e1f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2fbbe4713ad513f94b1389d4382e6b2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNullCommon</b> (const char *file, int line, const char *names, T &amp;t)</td></tr>
<tr class="separator:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae139da428aa4dd23516a0529815b9df8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae139da428aa4dd23516a0529815b9df8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae139da428aa4dd23516a0529815b9df8"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, T *t)</td></tr>
<tr class="separator:ae139da428aa4dd23516a0529815b9df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b78bd9f94be2e50aae5c959e7277a20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, T &amp;t)</td></tr>
<tr class="separator:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc23f310480e7d6e08c93e09e138708"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dc23f310480e7d6e08c93e09e138708"></a>
template&lt;class First , class Second &gt; </td></tr>
<tr class="memitem:a7dc23f310480e7d6e08c93e09e138708"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const std::pair&lt; First, Second &gt; &amp;p)</td></tr>
<tr class="separator:a7dc23f310480e7d6e08c93e09e138708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05e41e92838629e3ec5f859ccfcd3f13"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintSequence</b> (std::ostream &amp;ss, Iter begin, Iter end)</td></tr>
<tr class="separator:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="memItemLeft" align="right" valign="top">const CaffeMap&lt; string, const <a class="el" href="classcaffe2_1_1_module_schema.html">ModuleSchema</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a2015a66b1fe9fccf95985a1b9de6d31c">CurrentModules</a> ()</td></tr>
<tr class="memdesc:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current Modules present in the Caffe2 runtime.  <a href="#a2015a66b1fe9fccf95985a1b9de6d31c">More...</a><br /></td></tr>
<tr class="separator:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af176563dd119f7e7ee812ec70f4bf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8af176563dd119f7e7ee812ec70f4bf3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8af176563dd119f7e7ee812ec70f4bf3">HasModule</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a8af176563dd119f7e7ee812ec70f4bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a module is already present in the current binary. <br /></td></tr>
<tr class="separator:a8af176563dd119f7e7ee812ec70f4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f3bdc17d263b9070079af7c9248b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad9f3bdc17d263b9070079af7c9248b97">LoadModule</a> (const string &amp;name, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="memdesc:ad9f3bdc17d263b9070079af7c9248b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a module.  <a href="#ad9f3bdc17d263b9070079af7c9248b97">More...</a><br /></td></tr>
<tr class="separator:ad9f3bdc17d263b9070079af7c9248b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c59304364bbaa259c9b30b3294da8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a751c59304364bbaa259c9b30b3294da8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (NetRegistry, <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a>, const std::shared_ptr&lt; const NetDef &gt; &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a751c59304364bbaa259c9b30b3294da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697f38e38b51fbbda15ef83ab230e4c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a697f38e38b51fbbda15ef83ab230e4c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGlobalNetObserverCreator</b> (NetObserverCreator creator)</td></tr>
<tr class="separator:a697f38e38b51fbbda15ef83ab230e4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9463003c6ef9000d089ffeaf9296c05"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aa9463003c6ef9000d089ffeaf9296c05">CreateNet</a> (const NetDef &amp;net_def, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws)</td></tr>
<tr class="memdesc:aa9463003c6ef9000d089ffeaf9296c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a network, accessing / creating blobs in the given workspace.  <a href="#aa9463003c6ef9000d089ffeaf9296c05">More...</a><br /></td></tr>
<tr class="separator:aa9463003c6ef9000d089ffeaf9296c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bfc9582bb7aa109644e735171daae2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59bfc9582bb7aa109644e735171daae2"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateNet</b> (const std::shared_ptr&lt; const NetDef &gt; &amp;net_def, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a59bfc9582bb7aa109644e735171daae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d89a2290430e2cb676ad99b0e80b44a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d89a2290430e2cb676ad99b0e80b44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (NetRegistry, <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a>, const std::shared_ptr&lt; const NetDef &gt; &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a9d89a2290430e2cb676ad99b0e80b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc4bc640e2b7153cc1df6deb8a67271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc4bc640e2b7153cc1df6deb8a67271"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classcaffe2_1_1_task_thread_pool.html">TaskThreadPool</a>, const DeviceOption &amp;)</td></tr>
<tr class="separator:afcc4bc640e2b7153cc1df6deb8a67271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525018a21de8af6d36e5ca1f9a50b71e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a525018a21de8af6d36e5ca1f9a50b71e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_CREATOR</b> (ThreadPoolRegistry, CPU, AsyncNetCPUThreadPoolCreator)</td></tr>
<tr class="separator:a525018a21de8af6d36e5ca1f9a50b71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac045377eef49487e3e7456afbbfae9c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac045377eef49487e3e7456afbbfae9c3"></a>
std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1_task_thread_pool.html">TaskThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAsyncNetCPUThreadPool</b> (int numa_node_id)</td></tr>
<tr class="separator:ac045377eef49487e3e7456afbbfae9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768f50803e433c71e4f974d176fcb75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1768f50803e433c71e4f974d176fcb75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classcaffe2_1_1_task_thread_pool.html">TaskThreadPool</a>, const DeviceOption &amp;)</td></tr>
<tr class="separator:a1768f50803e433c71e4f974d176fcb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f954d1c88be22fb0fab68dfe8441cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6f954d1c88be22fb0fab68dfe8441cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_dag, <a class="el" href="classcaffe2_1_1_async_d_a_g_net.html">AsyncDAGNet</a>)</td></tr>
<tr class="separator:ab6f954d1c88be22fb0fab68dfe8441cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e014e91c62ad94bd3cacaac10c63c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e014e91c62ad94bd3cacaac10c63c69"></a>
std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1_task_thread_pool.html">TaskThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAsyncNetGPUThreadPool</b> (int gpu_id)</td></tr>
<tr class="separator:a6e014e91c62ad94bd3cacaac10c63c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cbd1540ea3d2c44e31470fe25551f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac5cbd1540ea3d2c44e31470fe25551f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_CREATOR</b> (ThreadPoolRegistry, CUDA, AsyncNetGPUThreadPoolCreator)</td></tr>
<tr class="separator:aac5cbd1540ea3d2c44e31470fe25551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c236f566e2186c6096a009c72400b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc3c236f566e2186c6096a009c72400b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_polling, <a class="el" href="classcaffe2_1_1_async_polling_net.html">AsyncPollingNet</a>)</td></tr>
<tr class="separator:adc3c236f566e2186c6096a009c72400b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6bd426853583761f4055254769f34f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6bd426853583761f4055254769f34f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_scheduling, <a class="el" href="classcaffe2_1_1_async_scheduling_net.html">AsyncSchedulingNet</a>)</td></tr>
<tr class="separator:a9f6bd426853583761f4055254769f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd90465ba94ce04ce171dd6d74e610e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdd90465ba94ce04ce171dd6d74e610e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (dag, <a class="el" href="classcaffe2_1_1_d_a_g_net.html">DAGNet</a>)</td></tr>
<tr class="separator:afdd90465ba94ce04ce171dd6d74e610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb93ef2d3c7b8c671bb07f042d6be9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3fb93ef2d3c7b8c671bb07f042d6be9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (simple, <a class="el" href="classcaffe2_1_1_simple_net.html">SimpleNet</a>)</td></tr>
<tr class="separator:ad3fb93ef2d3c7b8c671bb07f042d6be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5898a33286d03553bcc1b2076a35998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5898a33286d03553bcc1b2076a35998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_simple, <a class="el" href="classcaffe2_1_1_async_simple_net.html">AsyncSimpleNet</a>)</td></tr>
<tr class="separator:ab5898a33286d03553bcc1b2076a35998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4246ecacbc1eca9eddbe8dc3c2f65ac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4246ecacbc1eca9eddbe8dc3c2f65ac2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsNUMAEnabled</b> ()</td></tr>
<tr class="separator:a4246ecacbc1eca9eddbe8dc3c2f65ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae190af34adf46c3aea00a96f41ce045e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae190af34adf46c3aea00a96f41ce045e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NUMABind</b> (int numa_node_id)</td></tr>
<tr class="separator:ae190af34adf46c3aea00a96f41ce045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c9beec93e2aaa0f5e03ef0e2c6cd5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5c9beec93e2aaa0f5e03ef0e2c6cd5e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetNUMANode</b> (const void *ptr)</td></tr>
<tr class="separator:aa5c9beec93e2aaa0f5e03ef0e2c6cd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7754607c8d5e11fae9c28bada38e3f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7754607c8d5e11fae9c28bada38e3f4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumNUMANodes</b> ()</td></tr>
<tr class="separator:ad7754607c8d5e11fae9c28bada38e3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86f6a19ca640011886d4608cf93585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d86f6a19ca640011886d4608cf93585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NUMAMove</b> (void *ptr, size_t size, int numa_node_id)</td></tr>
<tr class="separator:a2d86f6a19ca640011886d4608cf93585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece30635af176262e2fa4e8d51b8b154"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aece30635af176262e2fa4e8d51b8b154"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetCurrentNUMANode</b> ()</td></tr>
<tr class="separator:aece30635af176262e2fa4e8d51b8b154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58edd0227c0c3e3d7dbe86941a1ef5a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58edd0227c0c3e3d7dbe86941a1ef5a2"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>OpRegistryKey</b> (const std::string &amp;op_type, const std::string &amp;engine)</td></tr>
<tr class="separator:a58edd0227c0c3e3d7dbe86941a1ef5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd73e617c2d8838a9bb0e962d36d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addddd73e617c2d8838a9bb0e962d36d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPerOpEnginePref</b> (const PerOpEnginePrefType &amp;per_op_engine_pref)</td></tr>
<tr class="separator:addddd73e617c2d8838a9bb0e962d36d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c401de140947a3313cf157382ad53b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c401de140947a3313cf157382ad53b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGlobalEnginePref</b> (const GlobalEnginePrefType &amp;global_engine_pref)</td></tr>
<tr class="separator:a6c401de140947a3313cf157382ad53b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb970ff1429fa32f114459ffbd5a20dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb970ff1429fa32f114459ffbd5a20dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEnginePref</b> (const PerOpEnginePrefType &amp;per_op_engine_pref, const GlobalEnginePrefType &amp;global_engine_pref)</td></tr>
<tr class="separator:aeb970ff1429fa32f114459ffbd5a20dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94ee55b0cdd0af9c161f467f1bd8888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab94ee55b0cdd0af9c161f467f1bd8888"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOpEnginePref</b> (const std::string &amp;op_type, const CaffeMap&lt; int, EnginePrefType &gt; &amp;op_pref)</td></tr>
<tr class="separator:ab94ee55b0cdd0af9c161f467f1bd8888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe5fbabd4ed39bcb3d1cf3dda65120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1fe5fbabd4ed39bcb3d1cf3dda65120"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateOperator</b> (const OperatorDef &amp;operator_def, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, int net_position)</td></tr>
<tr class="separator:af1fe5fbabd4ed39bcb3d1cf3dda65120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae95e80dc70afcb193bf36f1b797073b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae95e80dc70afcb193bf36f1b797073b"></a>
std::map&lt; int32_t, OperatorRegistry * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>gDeviceTypeRegistry</b> ()</td></tr>
<tr class="separator:aae95e80dc70afcb193bf36f1b797073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccce96415b7bc739e592db48b1a799"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ccce96415b7bc739e592db48b1a799"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (CPUOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a18ccce96415b7bc739e592db48b1a799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0183c10eb1de0e508a17ac16db32d324"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0183c10eb1de0e508a17ac16db32d324"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_DEVICE_TYPE</b> (DeviceType::CPU, CPUOperatorRegistry)</td></tr>
<tr class="separator:a0183c10eb1de0e508a17ac16db32d324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e181d42b6611b65f471704b8c954a81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e181d42b6611b65f471704b8c954a81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (CUDAOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a9e181d42b6611b65f471704b8c954a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaea084dc8c55e43149d0becb508dcdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaea084dc8c55e43149d0becb508dcdc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_DEVICE_TYPE</b> (DeviceType::CUDA, CUDAOperatorRegistry)</td></tr>
<tr class="separator:adaea084dc8c55e43149d0becb508dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c198acf57d3e0880cc9bd8d8af0b5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c198acf57d3e0880cc9bd8d8af0b5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (GradientRegistry, <a class="el" href="classcaffe2_1_1_gradient_maker_base.html">GradientMakerBase</a>, const OperatorDef &amp;, const vector&lt; <a class="el" href="structcaffe2_1_1_gradient_wrapper.html">GradientWrapper</a> &gt; &amp;)</td></tr>
<tr class="separator:ae5c198acf57d3e0880cc9bd8d8af0b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346efe7dfdcad2d65571bde97b3fc04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7346efe7dfdcad2d65571bde97b3fc04"></a>
<a class="el" href="structcaffe2_1_1_gradient_ops_meta.html">GradientOpsMeta</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a7346efe7dfdcad2d65571bde97b3fc04">GetGradientForOp</a> (const OperatorDef &amp;def, const vector&lt; <a class="el" href="structcaffe2_1_1_gradient_wrapper.html">GradientWrapper</a> &gt; &amp;g_output)</td></tr>
<tr class="memdesc:a7346efe7dfdcad2d65571bde97b3fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structcaffe2_1_1_gradient_ops_meta.html" title="A struct that holds the gradient operators and related gradient maps. ">GradientOpsMeta</a> for the given operator def. <br /></td></tr>
<tr class="separator:a7346efe7dfdcad2d65571bde97b3fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6666b1d285ffa56a211c30a9cfa52e10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6666b1d285ffa56a211c30a9cfa52e10"></a>
TensorShape&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorShapeOfBlob</b> (const <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> *b)</td></tr>
<tr class="separator:a6666b1d285ffa56a211c30a9cfa52e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898074bc24cb7ebae42f3f6d34b636f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a898074bc24cb7ebae42f3f6d34b636f6"></a>
TensorShapes&#160;</td><td class="memItemRight" valign="bottom"><b>InferBlobShapesAndTypesFromWorkspace</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, const vector&lt; std::unique_ptr&lt; NetDef &gt;&gt; &amp;nets)</td></tr>
<tr class="separator:a898074bc24cb7ebae42f3f6d34b636f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b62b3f41036c69569f008cde937ee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36b62b3f41036c69569f008cde937ee7"></a>
TensorShapes&#160;</td><td class="memItemRight" valign="bottom"><b>InferBlobShapesAndTypesFromMap</b> (const CaffeMap&lt; std::string, std::vector&lt; TIndex &gt;&gt; &amp;blob_dimensions, const vector&lt; std::unique_ptr&lt; NetDef &gt;&gt; &amp;nets)</td></tr>
<tr class="separator:a36b62b3f41036c69569f008cde937ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f3de4444365b0671e00491c0a37f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d3f3de4444365b0671e00491c0a37f2"></a>
std::map&lt; string, std::pair&lt; DeviceOption, DeviceOption &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidateTensorDevices</b> (<a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a> &amp;op, const OperatorDef &amp;op_def)</td></tr>
<tr class="separator:a1d3f3de4444365b0671e00491c0a37f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39bea8fb8ad1e59402332904277db99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39bea8fb8ad1e59402332904277db99"></a>
std::set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRegisteredOperators</b> ()</td></tr>
<tr class="separator:af39bea8fb8ad1e59402332904277db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25724da2473cdc552f28a790fdc71d57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25724da2473cdc552f28a790fdc71d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE2_DEFINE_TENSOR_TYPES_DISPATCHER</b> (<a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>, DoRunWithType, DoRunWithOtherType) CAFFE2_DEFINE_TENSOR_TYPES_DISPATCHER(<a class="el" href="structcaffe2_1_1_tensor_types2.html">TensorTypes2</a></td></tr>
<tr class="separator:a25724da2473cdc552f28a790fdc71d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eec8f63b0fcc386aa60145bedbca91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4eec8f63b0fcc386aa60145bedbca91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (CPUOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:ac4eec8f63b0fcc386aa60145bedbca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d5fd929969e3cc4d0b8b3621e4d1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab71d5fd929969e3cc4d0b8b3621e4d1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (CUDAOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:ab71d5fd929969e3cc4d0b8b3621e4d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b084aeace402eedb94e1f3d390a437"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10b084aeace402eedb94e1f3d390a437"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (GradientRegistry, <a class="el" href="classcaffe2_1_1_gradient_maker_base.html">GradientMakerBase</a>, const OperatorDef &amp;, const vector&lt; <a class="el" href="structcaffe2_1_1_gradient_wrapper.html">GradientWrapper</a> &gt; &amp;)</td></tr>
<tr class="separator:a10b084aeace402eedb94e1f3d390a437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38723124ff21e43fde4bca605606d0a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38723124ff21e43fde4bca605606d0a3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a> &amp;schema)</td></tr>
<tr class="separator:a38723124ff21e43fde4bca605606d0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff64e1d73f88f95e8d87c5284d06138"><td class="memTemplParams" colspan="2"><a class="anchor" id="adff64e1d73f88f95e8d87c5284d06138"></a>
template&lt;typename T_I  = int&gt; </td></tr>
<tr class="memitem:adff64e1d73f88f95e8d87c5284d06138"><td class="memTemplItemLeft" align="right" valign="top">TensorShape&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateTensorShape</b> (vector&lt; T_I &gt; dims,::caffe2::TensorProto_DataType dt)</td></tr>
<tr class="separator:adff64e1d73f88f95e8d87c5284d06138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e1b3df7861a894d5a1371b2980044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a547e1b3df7861a894d5a1371b2980044"></a>
vector&lt; TIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDimsVector</b> (const TensorShape &amp;shape)</td></tr>
<tr class="separator:a547e1b3df7861a894d5a1371b2980044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e0910770fec5599962a43c497111c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e0910770fec5599962a43c497111c0"></a>
std::pair&lt; std::vector&lt; DeviceOption &gt;, std::vector&lt; DeviceOption &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InferOpInputOutputDevice</b> (const OperatorDef &amp;op)</td></tr>
<tr class="separator:aa6e0910770fec5599962a43c497111c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a411bcb87b2fa7b8e4f543076adf911cf"></a>
template&lt;uint64_t OpsPerPoint&gt; </td></tr>
<tr class="memitem:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcaffe2_1_1_op_schema_1_1_cost.html">OpSchema::Cost</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PointwiseCostInference</b> (const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;inputs)</td></tr>
<tr class="separator:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a8b5bc38099521c1af0be567ce1b1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5a8b5bc38099521c1af0be567ce1b1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RunPlanOnWorkspace</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, const PlanDef &amp;plan, ShouldContinue shouldContinue)</td></tr>
<tr class="separator:ae5a8b5bc38099521c1af0be567ce1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ad3249e176dfbae42646227a62e80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a688ad3249e176dfbae42646227a62e80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_q_tensor.html">QTensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a688ad3249e176dfbae42646227a62e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac8a97f1ca3d23760951c4556f99aaec4"></a>
template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintOffendingKey</b> (const KeyType &amp;key)</td></tr>
<tr class="separator:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac30032d5ee3b8af7dc1c7ddc05b770e6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintOffendingKey</b> (const string &amp;key)</td></tr>
<tr class="separator:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca6146615d44e0893a020304848c3d1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a0ca6146615d44e0893a020304848c3d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1detail_1_1_scope_guard_impl.html">detail::ScopeGuardImplDecay</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a0ca6146615d44e0893a020304848c3d1">MakeGuard</a> (F &amp;&amp;f) noexcept(noexcept(<a class="el" href="classcaffe2_1_1detail_1_1_scope_guard_impl.html">detail::ScopeGuardImplDecay</a>&lt; F &gt;(static_cast&lt; F &amp;&amp; &gt;(f))))</td></tr>
<tr class="memdesc:a0ca6146615d44e0893a020304848c3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ScopeGuard is a general implementation of the "Initialization is
Resource Acquisition" idiom.  <a href="#a0ca6146615d44e0893a020304848c3d1">More...</a><br /></td></tr>
<tr class="separator:a0ca6146615d44e0893a020304848c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540f11fb3a2140dda5a6fae356774d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae540f11fb3a2140dda5a6fae356774d7"></a>
ExportedStatMap&#160;</td><td class="memItemRight" valign="bottom"><b>toMap</b> (const <a class="el" href="namespacecaffe2.html#a8eb1578901c4027246db0d3e46305c7f">ExportedStatList</a> &amp;stats)</td></tr>
<tr class="separator:ae540f11fb3a2140dda5a6fae356774d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d23c3fec40e8669e8ce130a588bd7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38d23c3fec40e8669e8ce130a588bd7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38d23c3fec40e8669e8ce130a588bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eec530d92a9d3ad68c2e6ddf9b887d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31eec530d92a9d3ad68c2e6ddf9b887d"></a>
TypeCall&#160;</td><td class="memItemRight" valign="bottom"><b>GetTypeCallFunction</b> (CaffeTypeId id)</td></tr>
<tr class="separator:a31eec530d92a9d3ad68c2e6ddf9b887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edcdb3b2b8630f92646c7189387a7d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8edcdb3b2b8630f92646c7189387a7d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterTypeCallFunction</b> (CaffeTypeId id, TypeCall c)</td></tr>
<tr class="separator:a8edcdb3b2b8630f92646c7189387a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303032ee4249c4513e4e30d23c0e94ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a303032ee4249c4513e4e30d23c0e94ea"></a>
TensorInfoCall&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorInfoFunction</b> (CaffeTypeId id)</td></tr>
<tr class="separator:a303032ee4249c4513e4e30d23c0e94ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ebcac892ada72e7c21ffcd79a5d80c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46ebcac892ada72e7c21ffcd79a5d80c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterTensorInfoFunction</b> (CaffeTypeId id, TensorInfoCall c)</td></tr>
<tr class="separator:a46ebcac892ada72e7c21ffcd79a5d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591122a8091d7c58df32810129874cb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a591122a8091d7c58df32810129874cb2"></a>
vector&lt; TIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a591122a8091d7c58df32810129874cb2">ToVectorTIndex</a> (const std::vector&lt; int &gt; &amp;src)</td></tr>
<tr class="memdesc:a591122a8091d7c58df32810129874cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to convert vector&lt;int&gt; to vector&lt;TIndex&gt;. <br /></td></tr>
<tr class="separator:a591122a8091d7c58df32810129874cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add14fa17af46b7f9a8a81cd9651456d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add14fa17af46b7f9a8a81cd9651456d6"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#add14fa17af46b7f9a8a81cd9651456d6">size_from_dim_</a> (int k, const vector&lt; TIndex &gt; &amp;dims)</td></tr>
<tr class="memdesc:add14fa17af46b7f9a8a81cd9651456d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of all dimensions starting from K. <br /></td></tr>
<tr class="separator:add14fa17af46b7f9a8a81cd9651456d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098d3bdc9ea3c61153eda4324dbbcc54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a098d3bdc9ea3c61153eda4324dbbcc54"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>size_to_dim_</b> (int k, const vector&lt; TIndex &gt; &amp;dims)</td></tr>
<tr class="separator:a098d3bdc9ea3c61153eda4324dbbcc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec10f0de76fa6db703e61baa25c3ac24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec10f0de76fa6db703e61baa25c3ac24"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>size_between_dim_</b> (int k, int l, const vector&lt; TIndex &gt; &amp;dims)</td></tr>
<tr class="separator:aec10f0de76fa6db703e61baa25c3ac24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355be215dea0c5371219749fa6f79801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a355be215dea0c5371219749fa6f79801"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_index_</b> (int axis_index, int ndims)</td></tr>
<tr class="separator:a355be215dea0c5371219749fa6f79801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a819f43601a5f85d722aa863ba2f8c5c9"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1_type_meta.html">TypeMeta</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetTensorType</b> (const void *c)</td></tr>
<tr class="separator:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2018f4cb3ab9f5347fba64c846285c0"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; TIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetTensorInfo</b> (const void *c, bool *shares_data, size_t *capacity, DeviceOption *device)</td></tr>
<tr class="separator:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8008ca85768ac0b118e11d26c9421582"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8008ca85768ac0b118e11d26c9421582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (TransformRegistry, <a class="el" href="classcaffe2_1_1_transform.html">Transform</a>)</td></tr>
<tr class="separator:a8008ca85768ac0b118e11d26c9421582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d4878f94b93ac50c461c3a50f44a06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2d4878f94b93ac50c461c3a50f44a06"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1_transform.html">Transform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateTransform</b> (string key)</td></tr>
<tr class="separator:ac2d4878f94b93ac50c461c3a50f44a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9114a03c171856d17fb868af046ac8af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9114a03c171856d17fb868af046ac8af"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyTransform</b> (const string &amp;key, const NetDef &amp;netdef)</td></tr>
<tr class="separator:a9114a03c171856d17fb868af046ac8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f7e2a2d404e67e6fdc0ce986dd0d48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20f7e2a2d404e67e6fdc0ce986dd0d48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>average_net_run_duration</b> (const NetDef &amp;netdef, const NetDef &amp;init_netdef, const int warmup_runs, const int main_runs)</td></tr>
<tr class="separator:a20f7e2a2d404e67e6fdc0ce986dd0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa047c11708af221b50899fb3c7d04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaa047c11708af221b50899fb3c7d04b"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyTransformIfFaster</b> (const string &amp;key, const NetDef &amp;netdef, const NetDef &amp;init_netdef, const int warmup_runs, const int main_runs, const double improvement_threshold)</td></tr>
<tr class="separator:acaa047c11708af221b50899fb3c7d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0e232312c328538bc6968378481583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b0e232312c328538bc6968378481583"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (TransformRegistry, <a class="el" href="classcaffe2_1_1_transform.html">Transform</a>)</td></tr>
<tr class="separator:a1b0e232312c328538bc6968378481583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cd0fc9f0b5a43bdbc428623415003"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad0cd0fc9f0b5a43bdbc428623415003"></a>
std::map&lt; CaffeTypeId, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gTypeNames</b> ()</td></tr>
<tr class="separator:aad0cd0fc9f0b5a43bdbc428623415003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130e812030acddeb238a5b5757ab9674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a130e812030acddeb238a5b5757ab9674"></a>
std::set&lt; string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gRegisteredTypeNames</b> ()</td></tr>
<tr class="separator:a130e812030acddeb238a5b5757ab9674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e122b63ebfcd08897660f43e6f302"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7e122b63ebfcd08897660f43e6f302"></a>
std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gCaffe2TypeRegistrationMutex</b> ()</td></tr>
<tr class="separator:aad7e122b63ebfcd08897660f43e6f302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392e317fd2c720edc0239431d6db3763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a392e317fd2c720edc0239431d6db3763"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>Demangle</b> (const char *name)</td></tr>
<tr class="separator:a392e317fd2c720edc0239431d6db3763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae840bee8278a15d265af6d1a61e50af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae840bee8278a15d265af6d1a61e50af3"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>GetExceptionString</b> (const std::exception &amp;e)</td></tr>
<tr class="separator:ae840bee8278a15d265af6d1a61e50af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c983e857641138000f973df762bbb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c983e857641138000f973df762bbb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (float)</td></tr>
<tr class="separator:a51c983e857641138000f973df762bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995c84c4bb43b29031202d257f4d447"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8995c84c4bb43b29031202d257f4d447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int)</td></tr>
<tr class="separator:a8995c84c4bb43b29031202d257f4d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7925ba5e84f7102ed481f2ac488f7acb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7925ba5e84f7102ed481f2ac488f7acb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::string)</td></tr>
<tr class="separator:a7925ba5e84f7102ed481f2ac488f7acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ebb3c0a4e3810919e373eb775ef37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba2ebb3c0a4e3810919e373eb775ef37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (bool)</td></tr>
<tr class="separator:aba2ebb3c0a4e3810919e373eb775ef37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9730c3506017b0184c2b661bbb75a7a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9730c3506017b0184c2b661bbb75a7a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (uint8_t)</td></tr>
<tr class="separator:a9730c3506017b0184c2b661bbb75a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5772e6c8dd480e999ed64dcd03158397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5772e6c8dd480e999ed64dcd03158397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int8_t)</td></tr>
<tr class="separator:a5772e6c8dd480e999ed64dcd03158397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d367fb77a2fd456b892867555c79d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66d367fb77a2fd456b892867555c79d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (uint16_t)</td></tr>
<tr class="separator:a66d367fb77a2fd456b892867555c79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7198280bd7f56a495098d54e497c52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7198280bd7f56a495098d54e497c52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int16_t)</td></tr>
<tr class="separator:afa7198280bd7f56a495098d54e497c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3ca7fc046c557c2d2def8887f241e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a3ca7fc046c557c2d2def8887f241e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int64_t)</td></tr>
<tr class="separator:a4a3ca7fc046c557c2d2def8887f241e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4463c309242c58740964e0b78b76e831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4463c309242c58740964e0b78b76e831"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (float16)</td></tr>
<tr class="separator:a4463c309242c58740964e0b78b76e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b979cd9e22d61ab7222f2d4384f344"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8b979cd9e22d61ab7222f2d4384f344"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (double)</td></tr>
<tr class="separator:ad8b979cd9e22d61ab7222f2d4384f344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a221cc9f7e8adebd6cfa16b9055260a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a221cc9f7e8adebd6cfa16b9055260a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (char)</td></tr>
<tr class="separator:a0a221cc9f7e8adebd6cfa16b9055260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7cc4446a72ffc28ef0111ff16b2276"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc7cc4446a72ffc28ef0111ff16b2276"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; std::mutex &gt;)</td></tr>
<tr class="separator:abc7cc4446a72ffc28ef0111ff16b2276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825294fc2cbf1971625491a0900b9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7825294fc2cbf1971625491a0900b9e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; std::atomic&lt; bool &gt;&gt;)</td></tr>
<tr class="separator:a7825294fc2cbf1971625491a0900b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65b6b7297f9731bc45e0854eab78be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad65b6b7297f9731bc45e0854eab78be8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::vector&lt; int64_t &gt;)</td></tr>
<tr class="separator:ad65b6b7297f9731bc45e0854eab78be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770016f922f09c039b1a5fb544437ef6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a770016f922f09c039b1a5fb544437ef6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::vector&lt; unsigned long &gt;)</td></tr>
<tr class="separator:a770016f922f09c039b1a5fb544437ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69da1013fe9462e68be1bc242791ae0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae69da1013fe9462e68be1bc242791ae0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (bool *)</td></tr>
<tr class="separator:ae69da1013fe9462e68be1bc242791ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5897a3cd04ba8bb49851ce026adbb7c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5897a3cd04ba8bb49851ce026adbb7c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (char *)</td></tr>
<tr class="separator:a5897a3cd04ba8bb49851ce026adbb7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efbc72153701c1e5283610874d15e06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5efbc72153701c1e5283610874d15e06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int *)</td></tr>
<tr class="separator:a5efbc72153701c1e5283610874d15e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cd66de2686592e3e83f6fdb7a0ec2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52cd66de2686592e3e83f6fdb7a0ec2a"></a>
TensorProto::DataType&#160;</td><td class="memItemRight" valign="bottom"><b>TypeMetaToDataType</b> (const <a class="el" href="classcaffe2_1_1_type_meta.html">TypeMeta</a> &amp;meta)</td></tr>
<tr class="separator:a52cd66de2686592e3e83f6fdb7a0ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847a88c5009fa01818909600b736cc30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a847a88c5009fa01818909600b736cc30"></a>
const <a class="el" href="classcaffe2_1_1_type_meta.html">TypeMeta</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>DataTypeToTypeMeta</b> (const TensorProto::DataType &amp;dt)</td></tr>
<tr class="separator:a847a88c5009fa01818909600b736cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bbd44760a61e661c53c6cdaa7baf6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86bbd44760a61e661c53c6cdaa7baf6d"></a>
StorageOrder&#160;</td><td class="memItemRight" valign="bottom"><b>StringToStorageOrder</b> (const string &amp;str)</td></tr>
<tr class="separator:a86bbd44760a61e661c53c6cdaa7baf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae297cfca76b377a990a2a4bff4795150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae297cfca76b377a990a2a4bff4795150"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>NameScopeSeparator</b> ()</td></tr>
<tr class="separator:ae297cfca76b377a990a2a4bff4795150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591260a9560d754c1a17a0603b4d5c53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a591260a9560d754c1a17a0603b4d5c53"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE2_ALIGNED</b> (2) __f16</td></tr>
<tr class="separator:a591260a9560d754c1a17a0603b4d5c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1492d6608aa1f2b649828d333a6910"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb1492d6608aa1f2b649828d333a6910"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb1492d6608aa1f2b649828d333a6910"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_type</b> ()</td></tr>
<tr class="separator:afb1492d6608aa1f2b649828d333a6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176793571dce6525db610f6d826494f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a176793571dce6525db610f6d826494f9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a176793571dce6525db610f6d826494f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_type&lt; float16 &gt;</b> ()</td></tr>
<tr class="separator:a176793571dce6525db610f6d826494f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0306aadcb419780516c195f5b435897c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0306aadcb419780516c195f5b435897c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueName</b> ()</td></tr>
<tr class="separator:a0306aadcb419780516c195f5b435897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b557447becfb20d0d39ff544fe9bf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b557447becfb20d0d39ff544fe9bf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateDB, <a class="el" href="classcaffe2_1_1_create_d_b_op.html">CreateDBOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a28b557447becfb20d0d39ff544fe9bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc1dfc6eddc86232b2f37132a028d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdcc1dfc6eddc86232b2f37132a028d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateDB).NumInputs(0).NumOutputs(1)</td></tr>
<tr class="separator:acdcc1dfc6eddc86232b2f37132a028d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2a9a202be73d0b77dfddc91f9d677"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc2a9a202be73d0b77dfddc91f9d677"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateDB)</td></tr>
<tr class="separator:a5bc2a9a202be73d0b77dfddc91f9d677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16173d7eb43a9222a6fddb7f4da601cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16173d7eb43a9222a6fddb7f4da601cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateDB, <a class="el" href="classcaffe2_1_1_create_d_b_op.html">CreateDBOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a16173d7eb43a9222a6fddb7f4da601cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76be045297e05130e27811a26458603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af76be045297e05130e27811a26458603"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FileStoreHandlerCreate, <a class="el" href="classcaffe2_1_1_file_store_handler_create_op.html">FileStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af76be045297e05130e27811a26458603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c423cab9613187844b36167c39a8826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c423cab9613187844b36167c39a8826"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0).NumOutputs(1).SetDoc(R&quot;DOC( Creates a unique_ptr&lt;<a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a>&gt; that uses the filesystem as backing store (typically a filesystem shared between many nodes</td></tr>
<tr class="separator:a3c423cab9613187844b36167c39a8826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae379e84b3fcdab738b362c50beb88a89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae379e84b3fcdab738b362c50beb88a89"></a>
such as NFS This store handler is not built to be fast Its recommended use is for integration tests and prototypes where extra dependencies are cumbersome Use an ephemeral path to ensure multiple processes or runs don t interfere DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;path&quot;,&quot;base path used by the <a class="el" href="classcaffe2_1_1_file_store_handler.html">FileStoreHandler</a>&quot;).Arg(&quot;prefix&quot;</td></tr>
<tr class="separator:ae379e84b3fcdab738b362c50beb88a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3335c9ce4b9bd6a2ac65b8fbb0511dec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3335c9ce4b9bd6a2ac65b8fbb0511dec"></a>
such as NFS This store handler is not built to be fast Its recommended use is for integration tests and prototypes where extra dependencies are cumbersome Use an ephemeral path to ensure multiple processes or runs don t interfere DOC prefix for all keys used by this store&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;handler&quot;,&quot;unique_ptr&lt;<a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a>&gt;&quot;)</td></tr>
<tr class="separator:a3335c9ce4b9bd6a2ac65b8fbb0511dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24607d1dba5a15796277e7fe9f50490f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24607d1dba5a15796277e7fe9f50490f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_file_store_handler_create_op.html">FileStoreHandlerCreateOp</a>)</td></tr>
<tr class="separator:a24607d1dba5a15796277e7fe9f50490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea7d9f58907b76a7f6572dd83d7791f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ea7d9f58907b76a7f6572dd83d7791f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FileStoreHandlerCreate, <a class="el" href="classcaffe2_1_1_file_store_handler_create_op.html">FileStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9ea7d9f58907b76a7f6572dd83d7791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb7f7164de654982fdb560ec12e4520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb7f7164de654982fdb560ec12e4520"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RedisStoreHandlerCreate, <a class="el" href="classcaffe2_1_1_redis_store_handler_create_op.html">RedisStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abdb7f7164de654982fdb560ec12e4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e30dfbbc07178061a2ccecae695faa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3e30dfbbc07178061a2ccecae695faa"></a>
host name of Redis server&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;port&quot;,&quot;port number of Redis server&quot;).Arg(&quot;prefix&quot;</td></tr>
<tr class="separator:ae3e30dfbbc07178061a2ccecae695faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8dd644c361881494e3250228459e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51a8dd644c361881494e3250228459e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_redis_store_handler_create_op.html">RedisStoreHandlerCreateOp</a>)</td></tr>
<tr class="separator:a51a8dd644c361881494e3250228459e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc556e15840343912103bdcd7554f921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc556e15840343912103bdcd7554f921"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RedisStoreHandlerCreate, <a class="el" href="classcaffe2_1_1_redis_store_handler_create_op.html">RedisStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abc556e15840343912103bdcd7554f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01323d7c66e4cd79858fe8baf05b95a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01323d7c66e4cd79858fe8baf05b95a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a> &gt;)</td></tr>
<tr class="separator:a01323d7c66e4cd79858fe8baf05b95a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b16134e5567469a265c9b9502ecc6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b16134e5567469a265c9b9502ecc6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreSet, <a class="el" href="classcaffe2_1_1_store_set_op.html">StoreSetOp</a>)</td></tr>
<tr class="separator:a16b16134e5567469a265c9b9502ecc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7d08c6d6bb46706f9a0b23bed317e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e7d08c6d6bb46706f9a0b23bed317e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2).NumOutputs(0).SetDoc(R&quot;DOC( Set a blob in a store. The key is the input blob's name and the value is the data in that blob. The key can be overridden by specifying the 'blob_name' argument. )DOC&quot;).Arg(&quot;blob_name&quot; = Ai * Bi</td></tr>
<tr class="separator:ac4e7d08c6d6bb46706f9a0b23bed317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cd5402bcae1f749878299a2f151ca4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6cd5402bcae1f749878299a2f151ca4"></a>
alternative key for the&#160;</td><td class="memItemRight" valign="bottom"><b>blob</b> (optional)&quot;) .Input(0</td></tr>
<tr class="separator:ac6cd5402bcae1f749878299a2f151ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11abbdffde28097c12f0f3f0219fa4cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11abbdffde28097c12f0f3f0219fa4cf"></a>
alternative key for the unique_ptr&lt; <a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;data&quot;,&quot;data blob&quot;)</td></tr>
<tr class="separator:a11abbdffde28097c12f0f3f0219fa4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6b861e79f3fcd9f7d74f15fd6e9a01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba6b861e79f3fcd9f7d74f15fd6e9a01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreGet, <a class="el" href="classcaffe2_1_1_store_get_op.html">StoreGetOp</a>)</td></tr>
<tr class="separator:aba6b861e79f3fcd9f7d74f15fd6e9a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f1d78ea2217ed0f39d7fbc8e32097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa22f1d78ea2217ed0f39d7fbc8e32097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1).NumOutputs(1).SetDoc(R&quot;DOC( Get a blob from a store. The key is the output blob's name. The key can be overridden by specifying the 'blob_name' argument. )DOC&quot;).Arg(&quot;blob_name&quot;</td></tr>
<tr class="separator:aa22f1d78ea2217ed0f39d7fbc8e32097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc93be35c9a6501b24702fb1244ade69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc93be35c9a6501b24702fb1244ade69"></a>
alternative key for the unique_ptr&lt; <a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;data&quot;,&quot;data blob&quot;)</td></tr>
<tr class="separator:acc93be35c9a6501b24702fb1244ade69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b8e7e21d84dd25c023dec167d81dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c8b8e7e21d84dd25c023dec167d81dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreAdd, <a class="el" href="classcaffe2_1_1_store_add_op.html">StoreAddOp</a>)</td></tr>
<tr class="separator:a7c8b8e7e21d84dd25c023dec167d81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d16e214b8d0cdce86eb0f4d0e144d58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d16e214b8d0cdce86eb0f4d0e144d58"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;blob_name&quot;,&quot;key of the counter (required)&quot;).Arg(&quot;add_value&quot;</td></tr>
<tr class="separator:a7d16e214b8d0cdce86eb0f4d0e144d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68207b990da32191700d23970ce4f3f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68207b990da32191700d23970ce4f3f6"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC value that is&#160;</td><td class="memItemRight" valign="bottom"><b>added</b> (optional, default:1)&quot;) .Input(0</td></tr>
<tr class="separator:a68207b990da32191700d23970ce4f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d408f06a5859408823a620efeb620a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d408f06a5859408823a620efeb620a0"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC value that is unique_ptr&lt; <a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;value&quot;,&quot;the current value of the counter&quot;)</td></tr>
<tr class="separator:a7d408f06a5859408823a620efeb620a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab0bd265fa66d0e05d7655cb8906ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeab0bd265fa66d0e05d7655cb8906ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreWait, <a class="el" href="classcaffe2_1_1_store_wait_op.html">StoreWaitOp</a>)</td></tr>
<tr class="separator:abeab0bd265fa66d0e05d7655cb8906ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc5fb2cd658d554bec156620367ea85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cc5fb2cd658d554bec156620367ea85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 2).NumOutputs(0).SetDoc(R&quot;DOC( Wait for the specified blob names to be set. The blob names can be passed either as an input blob with blob names or as an argument. )DOC&quot;).Arg(&quot;blob_names&quot;</td></tr>
<tr class="separator:a0cc5fb2cd658d554bec156620367ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24287b57b151acb2377d03fe2e3fa277"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24287b57b151acb2377d03fe2e3fa277"></a>
names of the blobs to wait&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (optional)&quot;) .Input(0</td></tr>
<tr class="separator:a24287b57b151acb2377d03fe2e3fa277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff958ac079c49c5000ddab94348778e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff958ac079c49c5000ddab94348778e7"></a>
names of the blobs to wait unique_ptr&lt; <a class="el" href="classcaffe2_1_1_store_handler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;names&quot;,&quot;names of the blobs to wait for (optional)&quot;)</td></tr>
<tr class="separator:aff958ac079c49c5000ddab94348778e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fff4d0d6ba530c8ea01d6fde5fc25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a5fff4d0d6ba530c8ea01d6fde5fc25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1_fully_connected_op_decomp.html">FullyConnectedOpDecomp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0a5fff4d0d6ba530c8ea01d6fde5fc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911bf3beaf2f596dcc1ca5967f7475e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a911bf3beaf2f596dcc1ca5967f7475e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCGradient_Decomp, <a class="el" href="classcaffe2_1_1_fully_connected_decomp_gradient_op.html">FullyConnectedDecompGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a911bf3beaf2f596dcc1ca5967f7475e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df82fe1d8375465476614a523cfea82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df82fe1d8375465476614a523cfea82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FC_Decomp).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:a6df82fe1d8375465476614a523cfea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f43040b9fb5df046e5f903083cfc03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65f43040b9fb5df046e5f903083cfc03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCGradient_Decomp).NumInputs(4).NumOutputs(3</td></tr>
<tr class="separator:a65f43040b9fb5df046e5f903083cfc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906e13e62402b32f21970ef8eb411544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a906e13e62402b32f21970ef8eb411544"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1_get_f_c_decomp_gradient.html">GetFCDecompGradient</a>)</td></tr>
<tr class="separator:a906e13e62402b32f21970ef8eb411544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d7a26f4a4525a258e2d4f64242d694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d7a26f4a4525a258e2d4f64242d694"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1_fully_connected_op_decomp.html">FullyConnectedOpDecomp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a75d7a26f4a4525a258e2d4f64242d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf49694959b5633212aa434c41b5649"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf49694959b5633212aa434c41b5649"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCGradient_Decomp, <a class="el" href="classcaffe2_1_1_fully_connected_decomp_gradient_op.html">FullyConnectedDecompGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aedf49694959b5633212aa434c41b5649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a8f898a7f3db2661f2488368a171b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2a8f898a7f3db2661f2488368a171b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TTContraction, <a class="el" href="classcaffe2_1_1_t_t_contraction_op.html">TTContractionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1d2a8f898a7f3db2661f2488368a171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f61fa72acba74a260f314be17b09a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f61fa72acba74a260f314be17b09a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (TTContraction, <a class="el" href="classcaffe2_1_1_t_t_contraction_op.html">TTContractionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a19f61fa72acba74a260f314be17b09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af3ee2be947562ddcd01e0b3441548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9af3ee2be947562ddcd01e0b3441548"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (TTContractionGradient, <a class="el" href="classcaffe2_1_1_t_t_contraction_gradient_op.html">TTContractionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae9af3ee2be947562ddcd01e0b3441548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46881f29cd0505bf48b9dc10758d6e2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46881f29cd0505bf48b9dc10758d6e2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ImageInput, <a class="el" href="classcaffe2_1_1_image_input_op.html">ImageInputOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a46881f29cd0505bf48b9dc10758d6e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2459389cb3e05cc347abd30f6480c74f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2459389cb3e05cc347abd30f6480c74f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, 1).NumOutputs(2</td></tr>
<tr class="separator:a2459389cb3e05cc347abd30f6480c74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af281b4f674ddcc7a0ff297cbd260cf40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af281b4f674ddcc7a0ff297cbd260cf40"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;){vector&lt; TensorShape &gt; out(2);<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);int batch_size=helper.GetSingleArgument&lt; int &gt;(&quot;batch_size&quot;, 0);int crop=helper.GetSingleArgument&lt; int &gt;(&quot;crop&quot;,-1);int color=helper.GetSingleArgument&lt; int &gt;(&quot;color&quot;, 1);CHECK_GT(crop, 0);out[0]=CreateTensorShape(vector&lt; int &gt;{batch_size, crop, crop, color?3:1}, TensorProto::FLOAT);out[1]=CreateTensorShape(vector&lt; int &gt;{1, batch_size}, TensorProto::INT32);return out;}).SetDoc(R&quot;DOC( Imports and processes images from a database. For each run of the operator</td></tr>
<tr class="separator:af281b4f674ddcc7a0ff297cbd260cf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0843dd8927171f2edb82e96bf38bfbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0843dd8927171f2edb82e96bf38bfbe"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial&#160;</td><td class="memItemRight" valign="bottom"><b>image</b> (optional)-The image is rescaled either up or down(with the scale argument) or just up(with the minsize argument)-The image is randomly cropped(crop size is passed as an argument but the location of the crop is random except if is_test is passed in which case the image in cropped at the center)-The image is normalized.Each of its color channels can have separate normalization values The dimension of the output image will always be cropxcrop) DOC&quot;) .Arg(&quot;batch_size&quot;</td></tr>
<tr class="separator:ab0843dd8927171f2edb82e96bf38bfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb023f040c85fd09a39fe4051d18a52b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb023f040c85fd09a39fe4051d18a52b"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the&#160;</td><td class="memItemRight" valign="bottom"><b>operator&quot; &quot;.Must be 1 or greater&quot;) .Arg</b> (&quot;color&quot;,&quot;Number of color channels (1 or 3). Defaults to 1&quot;).Arg(&quot;color_jitter&quot;</td></tr>
<tr class="separator:acb023f040c85fd09a39fe4051d18a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad046b4618a8495950dece292ee948c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad046b4618a8495950dece292ee948c5"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;img_saturation&quot;,&quot;Image saturation scale used in color jittering. &quot;&quot;Defaults to 0.4&quot;).Arg(&quot;img_brightness&quot;</td></tr>
<tr class="separator:aad046b4618a8495950dece292ee948c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5436c4be3acff2f04096a1d3d0c6c1c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5436c4be3acff2f04096a1d3d0c6c1c8"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;img_contrast&quot;,&quot;Image contrast scale used in color jittering. &quot;&quot;Defaults to 0.4&quot;).Arg(&quot;color_lighting&quot;</td></tr>
<tr class="separator:a5436c4be3acff2f04096a1d3d0c6c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d265c24d83412451a4d338f2379b14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d265c24d83412451a4d338f2379b14e"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;color_lighting_std&quot;,&quot;Std of normal distribution where color lighting&quot;&quot; scaling factor is sampled. Defaults to 0.1&quot;).Arg(&quot;scale_jitter_type&quot;</td></tr>
<tr class="separator:a7d265c24d83412451a4d338f2379b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4b36418e11522d5a8ae8e8be982b12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4b36418e11522d5a8ae8e8be982b12"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;minsize&quot;,&quot;Scale the size of the smallest dimension of the image to&quot;&quot; this only if the size is initially smaller. Scale and minsize are&quot;&quot; mutually exclusive. Must be larger than crop.&quot;).Arg(&quot;warp&quot;</td></tr>
<tr class="separator:a9a4b36418e11522d5a8ae8e8be982b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca7edede62cb26a92b3084c689740ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ca7edede62cb26a92b3084c689740ff"></a>
the other dimension is proportionally scaled Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;crop&quot;,&quot;Size to crop the image to. Must be provided&quot;).Arg(&quot;mirror&quot;</td></tr>
<tr class="separator:a2ca7edede62cb26a92b3084c689740ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a1069ccf5b3b27514cc8706b436a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a1069ccf5b3b27514cc8706b436a46"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;mean&quot;,&quot;Mean by which to normalize color channels.&quot;&quot; Defaults to 0.&quot;).Arg(&quot;mean_per_channel&quot;</td></tr>
<tr class="separator:a10a1069ccf5b3b27514cc8706b436a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b770c25ba279f06d4960b325974282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68b770c25ba279f06d4960b325974282"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> (1 or 3 elements).Defaults to mean argument.Channel order BGR&quot;) .Arg(&quot;std&quot;</td></tr>
<tr class="separator:a68b770c25ba279f06d4960b325974282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c409a294449a26bbddc45823681a26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69c409a294449a26bbddc45823681a26"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;std_per_channel&quot;,&quot;Vector of standard dev. per color channel &quot;&quot; (1 or 3 elements). Defaults to std argument. Channel order is BGR&quot;).Arg(&quot;bounding_ymin&quot;</td></tr>
<tr class="separator:a69c409a294449a26bbddc45823681a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431ce06d86fcbe00461cc50c8481b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2431ce06d86fcbe00461cc50c8481b72"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (none)&quot;) .Arg(&quot;bounding_xmin&quot;</td></tr>
<tr class="separator:a2431ce06d86fcbe00461cc50c8481b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1996aff9870b81551069115ccde9acea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1996aff9870b81551069115ccde9acea"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;use_gpu_transform&quot;,&quot;1 if GPU acceleration should be used.&quot;&quot; Defaults to 0. Can only be 1 in a <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>&quot;).Arg(&quot;decode_threads&quot;</td></tr>
<tr class="separator:a1996aff9870b81551069115ccde9acea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08beef7f94f925858f4b0cd0edafca10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08beef7f94f925858f4b0cd0edafca10"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;output_type&quot;,&quot;If gpu_transform, can set to FLOAT or FLOAT16.&quot;).Arg(&quot;db&quot;</td></tr>
<tr class="separator:a08beef7f94f925858f4b0cd0edafca10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb64afecbbe1ab0bc24bc583fb36bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81eb64afecbbe1ab0bc24bc583fb36bb"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the&#160;</td><td class="memItemRight" valign="bottom"><b>database</b> (if not passed as input)&quot;) .Arg(&quot;db_type&quot;</td></tr>
<tr class="separator:a81eb64afecbbe1ab0bc24bc583fb36bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44828c60e4c07e998cd551589e3e96b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44828c60e4c07e998cd551589e3e96b9"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and&#160;</td><td class="memItemRight" valign="bottom"><b>label</b> (should have a number of elements equal to the number of additional&quot;
         &quot;outputs)&quot;) .Arg(&quot;random_scale&quot;</td></tr>
<tr class="separator:a44828c60e4c07e998cd551589e3e96b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddbc9ea90ecffa3f431ad2544844c4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adddbc9ea90ecffa3f431ad2544844c4a"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to[-1,-1] or no random resize desired&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;reader&quot;,&quot;The input reader (a <a class="el" href="classcaffe2_1_1db_1_1_d_b_reader.html">db::DBReader</a>)&quot;).Output(0</td></tr>
<tr class="separator:adddbc9ea90ecffa3f431ad2544844c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee15142475f6490a021e4f59d3f6386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abee15142475f6490a021e4f59d3f6386"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to[-1,-1] or no random resize desired <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> containing the images&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;label&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> containing the labels&quot;).Output(2</td></tr>
<tr class="separator:abee15142475f6490a021e4f59d3f6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eeee1953b1fa22979df2625afd8f7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42eeee1953b1fa22979df2625afd8f7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (ImageInput)</td></tr>
<tr class="separator:a42eeee1953b1fa22979df2625afd8f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89ed831fcf3c45cda4c13ca8baf29456"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RandomSizedCropping</b> (cv::Mat *img, const int crop, std::mt19937 *randgen)</td></tr>
<tr class="separator:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dfb9938be59968250a613bb0df5dfd"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3dfb9938be59968250a613bb0df5dfd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:af3dfb9938be59968250a613bb0df5dfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Saturation</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:af3dfb9938be59968250a613bb0df5dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eca9236fea93a23767520aa5c92d6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a48eca9236fea93a23767520aa5c92d6e"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a48eca9236fea93a23767520aa5c92d6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Brightness</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:a48eca9236fea93a23767520aa5c92d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae8f235bf145f6e8fc9b93d9856001e1d"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Contrast</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd0925c4621b7decc472ecf1416797"><td class="memTemplParams" colspan="2"><a class="anchor" id="aacbd0925c4621b7decc472ecf1416797"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aacbd0925c4621b7decc472ecf1416797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorJitter</b> (float *img, const int img_size, const float saturation, const float brightness, const float contrast, std::mt19937 *randgen)</td></tr>
<tr class="separator:aacbd0925c4621b7decc472ecf1416797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab1a4c3e3844f779fc095a5b90bfebe33"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorLighting</b> (float *img, const int img_size, const float alpha_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;eigvecs, const std::vector&lt; float &gt; &amp;eigvals, std::mt19937 *randgen)</td></tr>
<tr class="separator:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4838fab94fdeefe86e8c1d4db05557"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef4838fab94fdeefe86e8c1d4db05557"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aef4838fab94fdeefe86e8c1d4db05557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorNormalization</b> (float *img, const int img_size, const int channels, const std::vector&lt; float &gt; &amp;mean, const std::vector&lt; float &gt; &amp;std)</td></tr>
<tr class="separator:aef4838fab94fdeefe86e8c1d4db05557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0c8852b2d4c964022bc7b3ff2c71edd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TransformImage</b> (const cv::Mat &amp;scaled_img, const int channels, float *image_data, const bool color_jitter, const float saturation, const float brightness, const float contrast, const bool color_lighting, const float color_lighting_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;color_lighting_eigvecs, const std::vector&lt; float &gt; &amp;color_lighting_eigvals, const int crop, const bool mirror, const std::vector&lt; float &gt; &amp;mean, const std::vector&lt; float &gt; &amp;std, std::mt19937 *randgen, std::bernoulli_distribution *mirror_this_image, bool is_test=false)</td></tr>
<tr class="separator:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c152792102363f875e27d079a3fdfd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a54c152792102363f875e27d079a3fdfd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a54c152792102363f875e27d079a3fdfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CropTransposeImage</b> (const cv::Mat &amp;scaled_img, const int channels, uint8_t *cropped_data, const int crop, const bool mirror, std::mt19937 *randgen, std::bernoulli_distribution *mirror_this_image, bool is_test=false)</td></tr>
<tr class="separator:a54c152792102363f875e27d079a3fdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf18ece7cf2c9bb50c5cb238f692a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5bf18ece7cf2c9bb50c5cb238f692a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ImageInput, <a class="el" href="classcaffe2_1_1_image_input_op.html">ImageInputOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af5bf18ece7cf2c9bb50c5cb238f692a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eded0041845df14bb24e2e9edd82cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7eded0041845df14bb24e2e9edd82cc"></a>
template&lt;typename T_IN , typename T_OUT , class Context &gt; </td></tr>
<tr class="memitem:ae7eded0041845df14bb24e2e9edd82cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TransformOnGPU</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;X, <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; *Y, <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;mean, <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;std, Context *context)</td></tr>
<tr class="separator:ae7eded0041845df14bb24e2e9edd82cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5f57840ab96c4ec38c8831b662ba57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad5f57840ab96c4ec38c8831b662ba57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (MKLDNN, EventCreateCPU)</td></tr>
<tr class="separator:aad5f57840ab96c4ec38c8831b662ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aa0030e5fcb0b6c0f20ccb7ec49275"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5aa0030e5fcb0b6c0f20ccb7ec49275"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (MKLDNN, EventRecordCPU)</td></tr>
<tr class="separator:ab5aa0030e5fcb0b6c0f20ccb7ec49275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac5594bb0068f68bda8863861d1144"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ac5594bb0068f68bda8863861d1144"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, MKLDNN, EventWaitCPUCPU)</td></tr>
<tr class="separator:a63ac5594bb0068f68bda8863861d1144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6addeaedf8705a1d9281ad40b743639a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6addeaedf8705a1d9281ad40b743639a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, CPU, EventWaitCPUCPU)</td></tr>
<tr class="separator:a6addeaedf8705a1d9281ad40b743639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75caa31f34f4d11f311d9ca6401abd60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75caa31f34f4d11f311d9ca6401abd60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, MKLDNN, EventWaitCPUCPU)</td></tr>
<tr class="separator:a75caa31f34f4d11f311d9ca6401abd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50411ff1422d82b4863deb6f4c616080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50411ff1422d82b4863deb6f4c616080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (MKLDNN, EventFinishCPU)</td></tr>
<tr class="separator:a50411ff1422d82b4863deb6f4c616080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25685d648d88f77d9375c5a6a5b8a761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25685d648d88f77d9375c5a6a5b8a761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (MKLDNN, EventQueryCPU)</td></tr>
<tr class="separator:a25685d648d88f77d9375c5a6a5b8a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c813b5b1da377c7fbd761b5b75a690c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c813b5b1da377c7fbd761b5b75a690c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (MKLDNN, EventErrorMessageCPU)</td></tr>
<tr class="separator:a8c813b5b1da377c7fbd761b5b75a690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede83d8b15b0a97818783031abf3ea8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede83d8b15b0a97818783031abf3ea8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (MKLDNN, EventSetFinishedCPU)</td></tr>
<tr class="separator:aede83d8b15b0a97818783031abf3ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76329d4e6074ba478dc9edd7fabd163e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76329d4e6074ba478dc9edd7fabd163e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (MKLDNN, EventResetCPU)</td></tr>
<tr class="separator:a76329d4e6074ba478dc9edd7fabd163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1648d6337dc12709f38fc025a2fc2993"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1648d6337dc12709f38fc025a2fc2993"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (MKLOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a1648d6337dc12709f38fc025a2fc2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba908ba77a72fa0ea27d0d6fdc6377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3ba908ba77a72fa0ea27d0d6fdc6377"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_g_l_tensor.html">GLTensor</a>&lt; GLfloat &gt;)</td></tr>
<tr class="separator:ab3ba908ba77a72fa0ea27d0d6fdc6377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cb6ebc0819b6792d58c98d5c299880"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7cb6ebc0819b6792d58c98d5c299880"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_g_l_tensor.html">GLTensor</a>&lt; GLhalf &gt;)</td></tr>
<tr class="separator:aa7cb6ebc0819b6792d58c98d5c299880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa309f220397b78b27d6c820fe78d9dd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa309f220397b78b27d6c820fe78d9dd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_g_l_tensor.html">GLTensor</a>&lt; half &gt;)</td></tr>
<tr class="separator:aa309f220397b78b27d6c820fe78d9dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55d7ff6a7f56cf1c0d73befe1874d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae55d7ff6a7f56cf1c0d73befe1874d81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_g_l_context.html">GLContext</a> &gt;)</td></tr>
<tr class="separator:ae55d7ff6a7f56cf1c0d73befe1874d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc477cee826d3073dca18cb5322f31e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc477cee826d3073dca18cb5322f31e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateOPENGL</b> (const DeviceOption &amp;, <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:abc477cee826d3073dca18cb5322f31e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeca13f5d16fbea9f95f9ac7aa8460cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeeca13f5d16fbea9f95f9ac7aa8460cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordOPENGL</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *, const void *, const char *)</td></tr>
<tr class="separator:aeeca13f5d16fbea9f95f9ac7aa8460cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab69988867dd9d6373e7f5784870c535"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab69988867dd9d6373e7f5784870c535"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitOPENGLOPENGL</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *, void *)</td></tr>
<tr class="separator:aab69988867dd9d6373e7f5784870c535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b96ac41ea08748ee1ab143412eb831"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41b96ac41ea08748ee1ab143412eb831"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishOPENGL</b> (const <a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a41b96ac41ea08748ee1ab143412eb831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834de1f1fedf3751f04d476eb8a5e5e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834de1f1fedf3751f04d476eb8a5e5e4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetOPENGL</b> (<a class="el" href="classcaffe2_1_1_event.html">Event</a> *)</td></tr>
<tr class="separator:a834de1f1fedf3751f04d476eb8a5e5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af490340467e528b714ab0b7290ca6ada"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af490340467e528b714ab0b7290ca6ada"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (OPENGL, EventCreateOPENGL)</td></tr>
<tr class="separator:af490340467e528b714ab0b7290ca6ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bba971eef58b7e086a2e2dd6a9bee25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bba971eef58b7e086a2e2dd6a9bee25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (OPENGL, EventRecordOPENGL)</td></tr>
<tr class="separator:a7bba971eef58b7e086a2e2dd6a9bee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1d1318135b6f64a3db1b3722f5ae11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe1d1318135b6f64a3db1b3722f5ae11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (OPENGL, OPENGL, EventWaitOPENGLOPENGL)</td></tr>
<tr class="separator:afe1d1318135b6f64a3db1b3722f5ae11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaf58e124b18796ce7a548d92808767"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdaf58e124b18796ce7a548d92808767"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (OPENGL, EventFinishOPENGL)</td></tr>
<tr class="separator:acdaf58e124b18796ce7a548d92808767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb9a5dc875d8d2d98baa309a669be17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb9a5dc875d8d2d98baa309a669be17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (OPENGL, EventResetOPENGL)</td></tr>
<tr class="separator:acdb9a5dc875d8d2d98baa309a669be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13b531b1ace7f9c33e24c22f232a72d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac13b531b1ace7f9c33e24c22f232a72d"></a>
template&lt;typename T  = half&gt; </td></tr>
<tr class="memitem:ac13b531b1ace7f9c33e24c22f232a72d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getTensorCPU</b> (const <a class="el" href="classcaffe2_1_1_g_l_tensor.html">GLTensor</a>&lt; T &gt; &amp;g_, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;g)</td></tr>
<tr class="separator:ac13b531b1ace7f9c33e24c22f232a72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cb6402154080fe0d33c880e9ac9a4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68cb6402154080fe0d33c880e9ac9a4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (opengl, <a class="el" href="classcaffe2_1_1_g_l_net.html">GLNet</a>)</td></tr>
<tr class="separator:a68cb6402154080fe0d33c880e9ac9a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d74019d2a2081bbc7fdcc9c923890d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0d74019d2a2081bbc7fdcc9c923890d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (GLOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:ac0d74019d2a2081bbc7fdcc9c923890d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527f5d72b1cec56f4d16e3735827aefb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a527f5d72b1cec56f4d16e3735827aefb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_DEVICE_TYPE</b> (DeviceType::OPENGL, GLOperatorRegistry)</td></tr>
<tr class="separator:a527f5d72b1cec56f4d16e3735827aefb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d78525fee9e0264e7e76de984bb4fc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d78525fee9e0264e7e76de984bb4fc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (GLOperatorRegistry, <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a3d78525fee9e0264e7e76de984bb4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae502118ed31ba84378019d9569a62dcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae502118ed31ba84378019d9569a62dcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpDefForOpenGL</b> (const NetDef &amp;d)</td></tr>
<tr class="separator:ae502118ed31ba84378019d9569a62dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10edc482cc8349e5a832edde86785572"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10edc482cc8349e5a832edde86785572"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>rewritePredictNetForOpenGL</b> (const NetDef &amp;predictNet, bool runFusion, std::unordered_set&lt; std::string &gt; cpuOps)</td></tr>
<tr class="separator:a10edc482cc8349e5a832edde86785572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fba5b1e4639c36a5bd8afb428bb0b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fba5b1e4639c36a5bd8afb428bb0b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToOpenGL</b> (const NetDef &amp;predictNet, NetDef *glPredictNet, bool runFusion, std::unordered_set&lt; std::string &gt; cpuOps)</td></tr>
<tr class="separator:a40fba5b1e4639c36a5bd8afb428bb0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3851f3d184880dd2bf3f35ab0f1c70d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3851f3d184880dd2bf3f35ab0f1c70d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Relu, <a class="el" href="classcaffe2_1_1_g_l_relu_op.html">GLReluOp</a>&lt; half &gt;)</td></tr>
<tr class="separator:ae3851f3d184880dd2bf3f35ab0f1c70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3beecdabdb8136736ab31e9924019c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3beecdabdb8136736ab31e9924019c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Sigmoid, <a class="el" href="classcaffe2_1_1_g_l_sigmoid_op.html">GLSigmoidOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:ad3beecdabdb8136736ab31e9924019c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f2232b3c6b510787dfc61dce24a463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8f2232b3c6b510787dfc61dce24a463"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Concat, <a class="el" href="classcaffe2_1_1_g_l_concat_op.html">GLConcatOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:ac8f2232b3c6b510787dfc61dce24a463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a5ba42a4ca69c4975ec21ae3d31e3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a5ba42a4ca69c4975ec21ae3d31e3d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1_g_l_conv_op.html">GLConvOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:ae8a5ba42a4ca69c4975ec21ae3d31e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7139309d3762c206cd6dd682a4fed1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf7139309d3762c206cd6dd682a4fed1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (CopyFromGL, <a class="el" href="classcaffe2_1_1_copy_from_g_l_op.html">CopyFromGLOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:aaf7139309d3762c206cd6dd682a4fed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191752618f73a9f7e381553895180718"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a191752618f73a9f7e381553895180718"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Sum, <a class="el" href="classcaffe2_1_1_g_l_sum_op.html">GLSumOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a191752618f73a9f7e381553895180718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7b60f5546e57544da937dc7d7e5041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b7b60f5546e57544da937dc7d7e5041"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Add, <a class="el" href="classcaffe2_1_1_g_l_sum_op.html">GLSumOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a3b7b60f5546e57544da937dc7d7e5041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ae716c35ab3e58b7d3dca7a9b1cb31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46ae716c35ab3e58b7d3dca7a9b1cb31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (FC, <a class="el" href="classcaffe2_1_1_g_l_fully_connected_op.html">GLFullyConnectedOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a46ae716c35ab3e58b7d3dca7a9b1cb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19eb6a8d669c89d8860f0b01fec586c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab19eb6a8d669c89d8860f0b01fec586c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (NormalizePlanarYUV, <a class="el" href="classcaffe2_1_1_g_l_normalize_planar_y_u_v_op.html">GLNormalizePlanarYUVOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:ab19eb6a8d669c89d8860f0b01fec586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966353881d52d6e1892902622523081d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a966353881d52d6e1892902622523081d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (AveragePool, <a class="el" href="classcaffe2_1_1_g_l_average_pool_op.html">GLAveragePoolOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a966353881d52d6e1892902622523081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3873cdcf379c865a8bb4d34c3d1d2961"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3873cdcf379c865a8bb4d34c3d1d2961"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (MaxPool, <a class="el" href="classcaffe2_1_1_g_l_max_pool_op.html">GLMaxPoolOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a3873cdcf379c865a8bb4d34c3d1d2961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a60612f8f5c167c6a645ddfe62a1bf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a60612f8f5c167c6a645ddfe62a1bf3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Reshape, <a class="el" href="classcaffe2_1_1_g_l_reshape_op.html">GLReshapeOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a3a60612f8f5c167c6a645ddfe62a1bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb8c96227310f9b8c7177d906c83e01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fb8c96227310f9b8c7177d906c83e01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (ResizeNearest, <a class="el" href="classcaffe2_1_1_g_l_resize_nearest_op.html">GLResizeNearestOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a8fb8c96227310f9b8c7177d906c83e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7452d116a7434001f2973d5e56e3ddab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7452d116a7434001f2973d5e56e3ddab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (Softmax, <a class="el" href="classcaffe2_1_1_g_l_softmax_op.html">GLSoftmaxOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:a7452d116a7434001f2973d5e56e3ddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36c4ec2a16cb6787c267be89d15e648"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36c4ec2a16cb6787c267be89d15e648"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GL_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1_g_l_spatial_b_n_op.html">GLSpatialBNOp</a>&lt; DataType &gt;)</td></tr>
<tr class="separator:ae36c4ec2a16cb6787c267be89d15e648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8242bf745a4cc5affeaacd377a911218"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8242bf745a4cc5affeaacd377a911218"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>benchmarkModel</b> (std::string init_net_pb, std::string predict_net_pb, std::string input_name, std::vector&lt; int &gt; input_dims, std::string net_name=&quot;benchmark_net&quot;, std::unordered_set&lt; std::string &gt; cpu_ops=std::unordered_set&lt; std::string &gt;({}))</td></tr>
<tr class="separator:a8242bf745a4cc5affeaacd377a911218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146280ebd64449949f8da763cf79682f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a146280ebd64449949f8da763cf79682f"></a>
template&lt;typename T  = float&gt; </td></tr>
<tr class="memitem:a146280ebd64449949f8da763cf79682f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PopulateCPUBlob</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, bool random, std::string name, std::vector&lt; int &gt; dims, int val=1, int dist_shift=0, float variance=1)</td></tr>
<tr class="separator:a146280ebd64449949f8da763cf79682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be03c4411444a54ad03bb6d1692cbba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8be03c4411444a54ad03bb6d1692cbba"></a>
template&lt;typename T  = half&gt; </td></tr>
<tr class="memitem:a8be03c4411444a54ad03bb6d1692cbba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compareNetResult</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> &amp;ws, NetDef &amp;cpu_net, NetDef &amp;gpu_net, string cpu_blob=&quot;ref_Y&quot;, string gpu_blob=&quot;gpu_Y&quot;, double tol=0.01, bool relative=false)</td></tr>
<tr class="separator:a8be03c4411444a54ad03bb6d1692cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ec7d816890c6546449087625a1b101"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53ec7d816890c6546449087625a1b101"></a>
template&lt;typename T  = half&gt; </td></tr>
<tr class="memitem:a53ec7d816890c6546449087625a1b101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compareNetResult4D</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> &amp;ws, NetDef &amp;cpu_net, NetDef &amp;gpu_net, string cpu_blob=&quot;ref_Y&quot;, string gpu_blob=&quot;gpu_Y&quot;, double tol=0.05)</td></tr>
<tr class="separator:a53ec7d816890c6546449087625a1b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a56c8772bdd2ef5e10e82e32a2812c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a56c8772bdd2ef5e10e82e32a2812c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToMPSCNN</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *mpscnnPredictNet)</td></tr>
<tr class="separator:a00a56c8772bdd2ef5e10e82e32a2812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6374034df05c127ea22e3d824285b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaf6374034df05c127ea22e3d824285b"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>annotateDefWithReadCounts</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:abaf6374034df05c127ea22e3d824285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a2fbd617c017bb2fd9f8e22b8aaf96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57a2fbd617c017bb2fd9f8e22b8aaf96"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>rewriteForMetal</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:a57a2fbd617c017bb2fd9f8e22b8aaf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2ebb0246dd4f78e67f3184b5690b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d2ebb0246dd4f78e67f3184b5690b0f"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>runMPSCNNFusion</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:a7d2ebb0246dd4f78e67f3184b5690b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c02c3cd6007350fa5ba718046d4ecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c02c3cd6007350fa5ba718046d4ecc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpDef</b> (const NetDef &amp;d)</td></tr>
<tr class="separator:a53c02c3cd6007350fa5ba718046d4ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d6a74b0298a661e86c225705e39a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a254d6a74b0298a661e86c225705e39a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpscnnRecordExecutionFinish</b> ()</td></tr>
<tr class="separator:a254d6a74b0298a661e86c225705e39a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe607097a57d84acd3ea177a85b7744"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabe607097a57d84acd3ea177a85b7744"></a>
<a class="el" href="structcaffe2_1_1_m_p_s_c_n_n_context.html">MPSCNNContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMPSCNNContext</b> ()</td></tr>
<tr class="separator:aabe607097a57d84acd3ea177a85b7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8ffd3689386b85c0d49a5200959f96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8ffd3689386b85c0d49a5200959f96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToMPSCNNIntermediateCopies</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *mpscnnPredictNet)</td></tr>
<tr class="separator:a9a8ffd3689386b85c0d49a5200959f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4186274961983247e54472fbeed42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc4186274961983247e54472fbeed42"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>setSpecialArgs</b> (const NetDef &amp;def)</td></tr>
<tr class="separator:a1fc4186274961983247e54472fbeed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da6bdc5a7c0d551de725a92530fd56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8da6bdc5a7c0d551de725a92530fd56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>testMPSCNN</b> ()</td></tr>
<tr class="separator:ae8da6bdc5a7c0d551de725a92530fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7065bb8848760071b8aa75997125eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe7065bb8848760071b8aa75997125eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareModels</b> (const NetDef &amp;initNet, NetDef predictNet)</td></tr>
<tr class="separator:afe7065bb8848760071b8aa75997125eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2a0d95be0f12114e4628c99cee76e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2a0d95be0f12114e4628c99cee76e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>verifyRewrite</b> (const NetDef &amp;initNet, const NetDef &amp;net, std::vector&lt; int &gt; inputDims)</td></tr>
<tr class="separator:aca2a0d95be0f12114e4628c99cee76e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2cf95a76f857355e90cdc09f95891"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99a2cf95a76f857355e90cdc09f95891"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="class_g_l_image.html">GLImage</a>&lt; float &gt;)</td></tr>
<tr class="separator:a99a2cf95a76f857355e90cdc09f95891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="class_g_l_image.html">GLImage</a>&lt; uint8_t &gt;)</td></tr>
<tr class="separator:ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86424036ce60f30d9d20148f0c047928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86424036ce60f30d9d20148f0c047928"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="class_g_l_image_vector.html">GLImageVector</a>&lt; float &gt;)</td></tr>
<tr class="separator:a86424036ce60f30d9d20148f0c047928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d86246574e79c9704eef9a8b970c7ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d86246574e79c9704eef9a8b970c7ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="class_g_l_image_vector.html">GLImageVector</a>&lt; uint8_t &gt;)</td></tr>
<tr class="separator:a4d86246574e79c9704eef9a8b970c7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22af4c5c13ab6a949f0c243daa773e4d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shareInputGLImage</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, const std::string &amp;name, <a class="el" href="class_g_l_image_vector.html">GLImageVector</a>&lt; T &gt; *input)</td></tr>
<tr class="separator:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a946e2544ac9ed60720014ec97e8f7dfe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_g_l_image_vector.html">GLImageVector</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extractOutputGLImage</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, const std::string &amp;name)</td></tr>
<tr class="separator:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7774d202f45f941a142e798aeb4b4177"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7774d202f45f941a142e798aeb4b4177"></a>
const NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>create_gl_run_net</b> (const NetDef &amp;init_net, const NetDef &amp;run_net, bool use_texture_input)</td></tr>
<tr class="separator:a7774d202f45f941a142e798aeb4b4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425fe9208a6165ffab7cc3581c71157c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a425fe9208a6165ffab7cc3581c71157c"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>rewritePredictNetForOpenGL</b> (const NetDef &amp;predictNet, bool useTextureInput, bool useTiling, bool runFusion)</td></tr>
<tr class="separator:a425fe9208a6165ffab7cc3581c71157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bac729318dc5966ec85348fe2fa28c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bac729318dc5966ec85348fe2fa28c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToOpenGL</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *glPredictNet, bool useTextureInput, bool useTiling, bool runFusion)</td></tr>
<tr class="separator:a3bac729318dc5966ec85348fe2fa28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa69d25c92bdc206d54f93e015242ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa69d25c92bdc206d54f93e015242ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLAdd, <a class="el" href="classcaffe2_1_1_open_g_l_add_op.html">OpenGLAddOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a8fa69d25c92bdc206d54f93e015242ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac503c8115c51b1e6bc931e6e325bd2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac503c8115c51b1e6bc931e6e325bd2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLAdd).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:aac503c8115c51b1e6bc931e6e325bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb598c792a818003b2fe7598f7a35b48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb598c792a818003b2fe7598f7a35b48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConcat, <a class="el" href="classcaffe2_1_1_open_g_l_concat_op.html">OpenGLConcatOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:abb598c792a818003b2fe7598f7a35b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7259cc186a8e3fea8ffe3ae5e89304fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7259cc186a8e3fea8ffe3ae5e89304fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConcat).NumInputs(2</td></tr>
<tr class="separator:a7259cc186a8e3fea8ffe3ae5e89304fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d96236d525905b458d20436496cad0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d96236d525905b458d20436496cad0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, 2)</td></tr>
<tr class="separator:a5d96236d525905b458d20436496cad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fa1d1b3aecd145a748e9876959ae3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a562fa1d1b3aecd145a748e9876959ae3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConv, <a class="el" href="classcaffe2_1_1_open_g_l_conv_op.html">OpenGLConvOp</a>&lt; float16_t, false, false &gt;)</td></tr>
<tr class="separator:a562fa1d1b3aecd145a748e9876959ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1739927bd8cc4d4a11d04fac9dabf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51c1739927bd8cc4d4a11d04fac9dabf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConv).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a51c1739927bd8cc4d4a11d04fac9dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad2045895ce9d95d60bbea96df21bb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad2045895ce9d95d60bbea96df21bb2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvPRelu, <a class="el" href="classcaffe2_1_1_open_g_l_conv_op.html">OpenGLConvOp</a>&lt; float16_t, true, false &gt;)</td></tr>
<tr class="separator:a4ad2045895ce9d95d60bbea96df21bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cf3a0839b9488b42ab00693fcfeee8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78cf3a0839b9488b42ab00693fcfeee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvPRelu).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:a78cf3a0839b9488b42ab00693fcfeee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d657640db149a91e4f7829f0086c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9d657640db149a91e4f7829f0086c6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvRelu, <a class="el" href="classcaffe2_1_1_open_g_l_conv_op.html">OpenGLConvOp</a>&lt; float16_t, false, true &gt;)</td></tr>
<tr class="separator:af9d657640db149a91e4f7829f0086c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0add19f11967be79c4415381da49b52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0add19f11967be79c4415381da49b52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvRelu).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ad0add19f11967be79c4415381da49b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e15f142efc741d54222e1e3d6bc418"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28e15f142efc741d54222e1e3d6bc418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTranspose, <a class="el" href="classcaffe2_1_1_open_g_l_conv_transpose_op.html">OpenGLConvTransposeOp</a>&lt; float16_t, false, false &gt;)</td></tr>
<tr class="separator:a28e15f142efc741d54222e1e3d6bc418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa3f1031549623196fce3ff7565e423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfa3f1031549623196fce3ff7565e423"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTranspose).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:adfa3f1031549623196fce3ff7565e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c209443a8d642c0fc92e75cc804928"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c209443a8d642c0fc92e75cc804928"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTransposePRelu, <a class="el" href="classcaffe2_1_1_open_g_l_conv_transpose_op.html">OpenGLConvTransposeOp</a>&lt; float16_t, true, false &gt;)</td></tr>
<tr class="separator:a33c209443a8d642c0fc92e75cc804928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1da6ad91c8f87c2d4cf609bb8a3bf77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1da6ad91c8f87c2d4cf609bb8a3bf77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTransposePRelu).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:ad1da6ad91c8f87c2d4cf609bb8a3bf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d119683748f90eb85a7f46aed6c3ddb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d119683748f90eb85a7f46aed6c3ddb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTransposeRelu, <a class="el" href="classcaffe2_1_1_open_g_l_conv_transpose_op.html">OpenGLConvTransposeOp</a>&lt; float16_t, false, true &gt;)</td></tr>
<tr class="separator:a8d119683748f90eb85a7f46aed6c3ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bc896f55316263a6d782fc025c7137"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75bc896f55316263a6d782fc025c7137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTransposeRelu).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a75bc896f55316263a6d782fc025c7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363487eded29eb0f06b5c928ade9df2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa363487eded29eb0f06b5c928ade9df2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyToOpenGL, <a class="el" href="classcaffe2_1_1_copy_to_open_g_l_op.html">CopyToOpenGLOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:aa363487eded29eb0f06b5c928ade9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf24e83e4f4f37694662f44f8151f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4bf24e83e4f4f37694662f44f8151f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CopyToOpenGL).NumInputs(1).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:ab4bf24e83e4f4f37694662f44f8151f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d8f4dc048d68f62ba6fdaeedee2736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39d8f4dc048d68f62ba6fdaeedee2736"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyFromOpenGL, <a class="el" href="classcaffe2_1_1_copy_from_open_g_l_op.html">CopyFromOpenGLOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a39d8f4dc048d68f62ba6fdaeedee2736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3fc06fc4dd0145ccb12419c550bebe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3fc06fc4dd0145ccb12419c550bebe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CopyFromOpenGL).NumInputs(1).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:aca3fc06fc4dd0145ccb12419c550bebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfe142c3cb36f0a70b779287945f670"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cfe142c3cb36f0a70b779287945f670"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLInstanceNorm, <a class="el" href="classcaffe2_1_1_open_g_l_instance_norm_p_relu_op.html">OpenGLInstanceNormPReluOp</a>&lt; float16_t, false &gt;)</td></tr>
<tr class="separator:a8cfe142c3cb36f0a70b779287945f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289a874d297611523bd4c04ecb10877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4289a874d297611523bd4c04ecb10877"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLInstanceNorm).NumInputs(3</td></tr>
<tr class="separator:a4289a874d297611523bd4c04ecb10877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cf546fcf6cd1e7c13ac155133bc9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a580cf546fcf6cd1e7c13ac155133bc9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, 3).AllowInplace(</td></tr>
<tr class="separator:a580cf546fcf6cd1e7c13ac155133bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac848e90af32b50f0b74713fb21bd3418"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac848e90af32b50f0b74713fb21bd3418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLInstanceNormPRelu, <a class="el" href="classcaffe2_1_1_open_g_l_instance_norm_p_relu_op.html">OpenGLInstanceNormPReluOp</a>&lt; float16_t, true &gt;)</td></tr>
<tr class="separator:ac848e90af32b50f0b74713fb21bd3418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af265eb801817a89e95cfdf2bcd50060e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af265eb801817a89e95cfdf2bcd50060e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLInstanceNormPRelu).NumInputs(3</td></tr>
<tr class="separator:af265eb801817a89e95cfdf2bcd50060e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f43f45f6bb3648bad73ad3e368def9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f43f45f6bb3648bad73ad3e368def9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLMul, <a class="el" href="classcaffe2_1_1_open_g_l_mul_op.html">OpenGLMulOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a9f43f45f6bb3648bad73ad3e368def9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2201ae75277f0e4f5ae0ce44723c9737"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2201ae75277f0e4f5ae0ce44723c9737"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLNormalizePlanarYUV, <a class="el" href="classcaffe2_1_1_g_l_norm_planar_y_u_v_op.html">GLNormPlanarYUVOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a2201ae75277f0e4f5ae0ce44723c9737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b264d6e1e86aa95b13656a48317df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a020b264d6e1e86aa95b13656a48317df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLNormalizePlanarYUV).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a020b264d6e1e86aa95b13656a48317df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c70979d0aa56f1ef9ff6cb244adbe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79c70979d0aa56f1ef9ff6cb244adbe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLPadImage, <a class="el" href="classcaffe2_1_1_open_g_l_pad_image_op.html">OpenGLPadImageOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a79c70979d0aa56f1ef9ff6cb244adbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57421b025505171908ebfe80f178d659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57421b025505171908ebfe80f178d659"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLPadImage).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:a57421b025505171908ebfe80f178d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b69735cb72b492e71a1f58b99212fd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b69735cb72b492e71a1f58b99212fd0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLPRelu, <a class="el" href="classcaffe2_1_1_open_g_l_p_relu_op.html">OpenGLPReluOp</a>&lt; float16_t, GLPRelu::PRelu &gt;)</td></tr>
<tr class="separator:a4b69735cb72b492e71a1f58b99212fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae721966f8a4a41ea13ac717698e09672"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>IdenticalTypeAndShape</b> ()</td></tr>
<tr class="separator:ae721966f8a4a41ea13ac717698e09672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d6c2004e74e840211e4683dc49b8b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75d6c2004e74e840211e4683dc49b8b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLRelu, <a class="el" href="classcaffe2_1_1_open_g_l_p_relu_op.html">OpenGLPReluOp</a>&lt; float16_t, GLPRelu::Relu &gt;)</td></tr>
<tr class="separator:a75d6c2004e74e840211e4683dc49b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fea477f80d5d4fc55c85ee2eedb8ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09fea477f80d5d4fc55c85ee2eedb8ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLResizeNearest, <a class="el" href="classcaffe2_1_1_open_g_l_resize_nearest_op.html">OpenGLResizeNearestOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a09fea477f80d5d4fc55c85ee2eedb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dbf7c5141481ca02000bf28d62722"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4dbf7c5141481ca02000bf28d62722"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLResizeNearest).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:adc4dbf7c5141481ca02000bf28d62722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffa85e4742fa013131a47992d0ff445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ffa85e4742fa013131a47992d0ff445"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLSigmoid, <a class="el" href="classcaffe2_1_1_open_g_l_sigmoid_op.html">OpenGLSigmoidOp</a>&lt; float16_t, Sigmoid &gt;)</td></tr>
<tr class="separator:a9ffa85e4742fa013131a47992d0ff445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f44e83e8259ab5784562b854267df7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f44e83e8259ab5784562b854267df7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTanh, <a class="el" href="classcaffe2_1_1_open_g_l_sigmoid_op.html">OpenGLSigmoidOp</a>&lt; float16_t, Tanh &gt;)</td></tr>
<tr class="separator:a55f44e83e8259ab5784562b854267df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6fb086ff5a2ad3f989cd803282f9f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b6fb086ff5a2ad3f989cd803282f9f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTensorToTextureStylizerPreprocess, <a class="el" href="classcaffe2_1_1_open_g_l_tensor_to_texture_stylizer_preprocess_op.html">OpenGLTensorToTextureStylizerPreprocessOp</a>)</td></tr>
<tr class="separator:a3b6fb086ff5a2ad3f989cd803282f9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb2489f195c89f24b58a2e6152afa51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1eb2489f195c89f24b58a2e6152afa51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTensorToTextureStylizerPreprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a1eb2489f195c89f24b58a2e6152afa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c16cd185a74811c285d02af042e26e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c16cd185a74811c285d02af042e26e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTextureStylizerPreprocess, <a class="el" href="classcaffe2_1_1_open_g_l_texture_to_texture_stylizer_preprocess_op.html">OpenGLTextureToTextureStylizerPreprocessOp</a>&lt; RGBA &gt;)</td></tr>
<tr class="separator:a19c16cd185a74811c285d02af042e26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cba7375a7c56f6f13a3db03b735130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68cba7375a7c56f6f13a3db03b735130"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTextureStylizerPreprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a68cba7375a7c56f6f13a3db03b735130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c452e50850da2f77991d9434f80ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab55c452e50850da2f77991d9434f80ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTensorStylizerDeprocess, <a class="el" href="classcaffe2_1_1_open_g_l_texture_to_tensor_stylizer_deprocess_op.html">OpenGLTextureToTensorStylizerDeprocessOp</a>)</td></tr>
<tr class="separator:ab55c452e50850da2f77991d9434f80ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb16d0b59b3c2b976968999e9462ff46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb16d0b59b3c2b976968999e9462ff46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTensorStylizerDeprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:acb16d0b59b3c2b976968999e9462ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1b784c4bdb68699acb802a343f2384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd1b784c4bdb68699acb802a343f2384"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTextureStylizerDeprocess, <a class="el" href="classcaffe2_1_1_open_g_l_texture_to_texture_stylizer_deprocess_op.html">OpenGLTextureToTextureStylizerDeprocessOp</a>&lt; RGBA &gt;)</td></tr>
<tr class="separator:afd1b784c4bdb68699acb802a343f2384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cdda1b3754f19e5772a851d13cfda9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92cdda1b3754f19e5772a851d13cfda9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTextureStylizerDeprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a92cdda1b3754f19e5772a851d13cfda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2fdf45d7817bd5874faf40f185e580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e2fdf45d7817bd5874faf40f185e580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLSub, <a class="el" href="classcaffe2_1_1_open_g_l_sub_op.html">OpenGLSubOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a3e2fdf45d7817bd5874faf40f185e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546d56314eecef6baa0cc93385ef46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af546d56314eecef6baa0cc93385ef46d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLSub).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:af546d56314eecef6baa0cc93385ef46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf0a4d8c3d3b32bc845b2624cc369fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accf0a4d8c3d3b32bc845b2624cc369fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>testOpenGL</b> ()</td></tr>
<tr class="separator:accf0a4d8c3d3b32bc845b2624cc369fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc451d7ad7ba65fd324bf5ae114499e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc451d7ad7ba65fd324bf5ae114499e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareModelsForOpenGL</b> (std::string name, const NetDef &amp;initNet, NetDef predictNet, int width, int height, int channel, std::string input_type, std::string input_order)</td></tr>
<tr class="separator:a5bc451d7ad7ba65fd324bf5ae114499e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f1ee5453d7f449564ec3e970596334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28f1ee5453d7f449564ec3e970596334"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareBatchedToTiledModels</b> (std::string name, const NetDef &amp;initNet, NetDef predictNet, int width, int height, int channel, std::string input_type, std::string input_order)</td></tr>
<tr class="separator:a28f1ee5453d7f449564ec3e970596334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2165da55a2a3eaf378664b82975a72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a2165da55a2a3eaf378664b82975a72"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>runModelBenchmarks</b> (caffe2::NetDef &amp;init_net, caffe2::NetDef &amp;predict_net, int warm_up_runs, int main_runs, int channel, int height, int width, std::string input_type, std::string input_order, std::string engine, bool run_individual=false, bool use_texture_input=false, bool use_tiling=false, bool run_fusion=true)</td></tr>
<tr class="separator:a3a2165da55a2a3eaf378664b82975a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2457b3242eeca40cf4f65e6cb0b75d20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2457b3242eeca40cf4f65e6cb0b75d20"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gSNPELocation</b> ()</td></tr>
<tr class="separator:a2457b3242eeca40cf4f65e6cb0b75d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade211aa656d7303d830b20fe176f9346"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade211aa656d7303d830b20fe176f9346"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SNPE, <a class="el" href="classcaffe2_1_1_s_n_p_e_op.html">SNPEOp</a>)</td></tr>
<tr class="separator:ade211aa656d7303d830b20fe176f9346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858eac856ff7f62c769e23ddb9af406b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858eac856ff7f62c769e23ddb9af406b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uniformQuantize2b1b</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &gt;&gt; &amp;XQ, float offset, float inter_center_distance)</td></tr>
<tr class="separator:a858eac856ff7f62c769e23ddb9af406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1476ad461eaf378d7917e80bce3edb09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1476ad461eaf378d7917e80bce3edb09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qconv</b> (const <a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;W, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *b, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:a1476ad461eaf378d7917e80bce3edb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17277f2033ff1b4578c1864754c1054"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad17277f2033ff1b4578c1864754c1054"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qpad_zero</b> (const <a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:ad17277f2033ff1b4578c1864754c1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708c5c82f39bd355506a0d5e89422bb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a708c5c82f39bd355506a0d5e89422bb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signQuantize</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *XQ)</td></tr>
<tr class="separator:a708c5c82f39bd355506a0d5e89422bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3400d9dcadd25caed54ad3942ff62493"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3400d9dcadd25caed54ad3942ff62493"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filterNormalization11</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;WQ, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *WQN)</td></tr>
<tr class="separator:a3400d9dcadd25caed54ad3942ff62493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197ad7509c858d29fc1bf80dc3b9ec92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a197ad7509c858d29fc1bf80dc3b9ec92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filterNormalizationL1</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;W, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *WL1)</td></tr>
<tr class="separator:a197ad7509c858d29fc1bf80dc3b9ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba550b3a9c6fd24a91ad9a114f1bb788"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba550b3a9c6fd24a91ad9a114f1bb788"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qim2col</b> (const <a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;XQ, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;WQ, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *XQcol)</td></tr>
<tr class="separator:aba550b3a9c6fd24a91ad9a114f1bb788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c6d0b3cd4fd632e1287358b7d34fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a082c6d0b3cd4fd632e1287358b7d34fe"></a>
std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1_q_conv_state.html">QConvState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create2b1bConvState</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;W, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *b)</td></tr>
<tr class="separator:a082c6d0b3cd4fd632e1287358b7d34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c829fb3b775c8790d3ef0419d6a731"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c829fb3b775c8790d3ef0419d6a731"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bConvGeneric</b> (<a class="el" href="structcaffe2_1_1_q_conv_state.html">QConvState</a> *state, const <a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:a94c829fb3b775c8790d3ef0419d6a731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b77566807b3576fa21053ba071c114a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b77566807b3576fa21053ba071c114a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bUnification</b> (<a class="el" href="structcaffe2_1_1_q_conv_state.html">QConvState</a> *state, size_t N, size_t C, const float *WQNVdata, const float *YQs0Vdata, const float *YQs1Vdata, size_t YQstride, float *Ydata, size_t Ystride, const float *bias)</td></tr>
<tr class="separator:a3b77566807b3576fa21053ba071c114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246b69b4a3b8c68c512cafd006df397"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8246b69b4a3b8c68c512cafd006df397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QConv, <a class="el" href="classcaffe2_1_1_q_conv_op.html">QConvOp</a>)</td></tr>
<tr class="separator:a8246b69b4a3b8c68c512cafd006df397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac67d9a6a97914fb3a6c54045667b004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac67d9a6a97914fb3a6c54045667b004"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>divRoundUp</b> (size_t x, size_t d)</td></tr>
<tr class="separator:aac67d9a6a97914fb3a6c54045667b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88af923ed6cef1948561dc4d24d9c9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab88af923ed6cef1948561dc4d24d9c9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bConvNeon</b> (<a class="el" href="structcaffe2_1_1_q_conv_state.html">QConvState</a> *state, const <a class="el" href="structcaffe2_1_1_conv_args.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:ab88af923ed6cef1948561dc4d24d9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22675a2de1f5235fc243775d19dbfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff22675a2de1f5235fc243775d19dbfd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_m_p_i_common_world_wrapper.html">MPICommonWorldWrapper</a>)</td></tr>
<tr class="separator:aff22675a2de1f5235fc243775d19dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bee4c02cf9a7fdb6868b05b8cd41df5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bee4c02cf9a7fdb6868b05b8cd41df5"></a>
std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MPIMutex</b> ()</td></tr>
<tr class="separator:a8bee4c02cf9a7fdb6868b05b8cd41df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca313bd69abda6cc82792348e1d64cc1"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aca313bd69abda6cc82792348e1d64cc1">GlobalMPIComm</a> ()</td></tr>
<tr class="memdesc:aca313bd69abda6cc82792348e1d64cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the global MPI communicator used by Caffe2.  <a href="#aca313bd69abda6cc82792348e1d64cc1">More...</a><br /></td></tr>
<tr class="separator:aca313bd69abda6cc82792348e1d64cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a1eaa1a07583fa2d94c3e66a7496f4790">SetGlobalMPIComm</a> (MPI_Comm new_comm)</td></tr>
<tr class="memdesc:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global MPI communicator.  <a href="#a1eaa1a07583fa2d94c3e66a7496f4790">More...</a><br /></td></tr>
<tr class="separator:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a395b8f7fc95f3e07aa97c327c7bb73a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a395b8f7fc95f3e07aa97c327c7bb73a0">MPICommSize</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to return the size of the given communicator. <br /></td></tr>
<tr class="separator:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b5d7b216271612f282cb791533d010"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7b5d7b216271612f282cb791533d010"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad7b5d7b216271612f282cb791533d010">MPICommRank</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:ad7b5d7b216271612f282cb791533d010"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to return the rank of the given communicator. <br /></td></tr>
<tr class="separator:ad7b5d7b216271612f282cb791533d010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2404153d4045abf87562f016a7fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a4dc2404153d4045abf87562f016a7fa4">MPISetupPeers</a> (const int replicas, const string &amp;role, const string &amp;job_path)</td></tr>
<tr class="memdesc:a4dc2404153d4045abf87562f016a7fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function used to perform peer setup so one does not need to use mpirun / mpiexec to run the binary.  <a href="#a4dc2404153d4045abf87562f016a7fa4">More...</a><br /></td></tr>
<tr class="separator:a4dc2404153d4045abf87562f016a7fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3f85d0b09bfde9dc265180f24bf01a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f3f85d0b09bfde9dc265180f24bf01a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckInitializedMPI</b> ()</td></tr>
<tr class="separator:a9f3f85d0b09bfde9dc265180f24bf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803b9c936189ddd9e0597b57dcae8a8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a803b9c936189ddd9e0597b57dcae8a8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Abs, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_abs_c_p_u_functor.html">AbsCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a803b9c936189ddd9e0597b57dcae8a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e9893af99362096e094fa669b23d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a311e9893af99362096e094fa669b23d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AbsGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_abs_gradient_c_p_u_functor.html">AbsGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a311e9893af99362096e094fa669b23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411386bd927eaf6efde8e598a35a79cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a411386bd927eaf6efde8e598a35a79cb"></a>
element wise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;input&quot;,&quot;Input tensor&quot;).Output(0</td></tr>
<tr class="separator:a411386bd927eaf6efde8e598a35a79cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b6698cbdefdc707ad876a1cf28b34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf5b6698cbdefdc707ad876a1cf28b34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AbsGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:acf5b6698cbdefdc707ad876a1cf28b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf41d31992d47858547cd42193c8964"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bf41d31992d47858547cd42193c8964"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Abs, <a class="el" href="classcaffe2_1_1_get_abs_gradient.html">GetAbsGradient</a>)</td></tr>
<tr class="separator:a4bf41d31992d47858547cd42193c8964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df747d59995127f18ad03be32131e9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0df747d59995127f18ad03be32131e9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Accumulate, <a class="el" href="classcaffe2_1_1_accumulate_op.html">AccumulateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0df747d59995127f18ad03be32131e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99977934dd736d9c2047fe0fbe879af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa99977934dd736d9c2047fe0fbe879af"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the&#160;</td><td class="memItemRight" valign="bottom"><b>operator, given that no one else fiddles with the output in the interim, will do simple accumulations.Accumulation is done using Axpby operation as shown:Y=1 *X+gamma *Y where X is the input tensor, Y is the output tensor and gamma is the multiplier argument.) DOC&quot;) .Arg</b> (&quot;gamma&quot;,&quot;(float, default 1.0) Accumulation multiplier&quot;).Input(0</td></tr>
<tr class="separator:aa99977934dd736d9c2047fe0fbe879af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d5a6ff20e2ced0a7b4f22420527cd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90d5a6ff20e2ced0a7b4f22420527cd8"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to and only accumulation is done&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;Accumulated output tensor&quot;)</td></tr>
<tr class="separator:a90d5a6ff20e2ced0a7b4f22420527cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78bc14e4f415df7ecbd5dc021f364a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e78bc14e4f415df7ecbd5dc021f364a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Accumulate)</td></tr>
<tr class="separator:a9e78bc14e4f415df7ecbd5dc021f364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226a3949dd6bbe06e017eda3bd9c7871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a226a3949dd6bbe06e017eda3bd9c7871"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Accuracy, <a class="el" href="classcaffe2_1_1_accuracy_op.html">AccuracyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a226a3949dd6bbe06e017eda3bd9c7871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade465a1be9535ecde85ef986fd6433d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade465a1be9535ecde85ef986fd6433d4"></a>
NumInputs(2).NumOutputs(1).ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Accuracy)</td></tr>
<tr class="separator:ade465a1be9535ecde85ef986fd6433d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1935fbf87dd5962a9730b559808baa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1935fbf87dd5962a9730b559808baa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Assert, <a class="el" href="classcaffe2_1_1_assert_op.html">AssertOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab1935fbf87dd5962a9730b559808baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe382ce62925b923bdd9080440a1b52a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe382ce62925b923bdd9080440a1b52a"></a>
or long longs and checks if all values are true when coerced into a boolean In other for non bool types this asserts that all values in the tensor are non zero DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;error_msg&quot;,&quot;An error message to print when the assert fails.&quot;, false)</td></tr>
<tr class="separator:afe382ce62925b923bdd9080440a1b52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28b63bd573fb8ac2c243c9f1d158fe9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae28b63bd573fb8ac2c243c9f1d158fe9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchGather, <a class="el" href="classcaffe2_1_1_batch_gather_op.html">BatchGatherOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae28b63bd573fb8ac2c243c9f1d158fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded54ac490ac9528615bf2da79a8a93c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aded54ac490ac9528615bf2da79a8a93c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchGatherGradient, <a class="el" href="classcaffe2_1_1_batch_gather_gradient_op.html">BatchGatherGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aded54ac490ac9528615bf2da79a8a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7b4cc9e95fa3d06364db3448f7efd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b7b4cc9e95fa3d06364db3448f7efd7"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (data_dims[0])</td></tr>
<tr class="separator:a9b7b4cc9e95fa3d06364db3448f7efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8886922a57252e67c2d3f9a0d6adb45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8886922a57252e67c2d3f9a0d6adb45"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (output_dims.end(), indices_dims.begin(), indices_dims.end())</td></tr>
<tr class="separator:af8886922a57252e67c2d3f9a0d6adb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c60dd54c505c4eeeffd3e0db7165f0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c60dd54c505c4eeeffd3e0db7165f0b"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (output_dims.end(), data_dims.begin()+2, data_dims.end())</td></tr>
<tr class="separator:a5c60dd54c505c4eeeffd3e0db7165f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76bf1394c3f5071eb47eb5a9c38c6d84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76bf1394c3f5071eb47eb5a9c38c6d84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Batch gather operation, first dimension in DATA is the batch size.
Given DATA tensor of rank r &gt;= 2, and INDICES tensor of rank q &gt;= 1, gather
entries of the outer-most dimension of DATA indexed by INDICES, and concatenate
them in an output tensor of rank (q - 1) + (r - 1).

Example:
  DATA  = [
      [1.0, 1.2, 2.4, 4.5],
      [2.3, 3.4, 3.6, 2.3],
      [4.5, 5.7, 1.2, 4.5],
  ]
  INDICES = [
      [0, 2],
  ]
  OUTPUT = [
      [1.0, 2.4],
      [2.3, 3.6],
      [4.5, 1.2],
  ]
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a76bf1394c3f5071eb47eb5a9c38c6d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424907704c3ff621020844f592be287e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a424907704c3ff621020844f592be287e"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of rank of any rank q&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;OUTPUT&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of rank (q - 1) + (r - 1).&quot;)</td></tr>
<tr class="separator:a424907704c3ff621020844f592be287e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040943feb691c6d2783bfc48d09c4ad6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a040943feb691c6d2783bfc48d09c4ad6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (BatchGatherGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a040943feb691c6d2783bfc48d09c4ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ab4ef78e8d53533fd78a515f238b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c2ab4ef78e8d53533fd78a515f238b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BatchGather, <a class="el" href="classcaffe2_1_1_get_batch_gather_gradient.html">GetBatchGatherGradient</a>)</td></tr>
<tr class="separator:a3c2ab4ef78e8d53533fd78a515f238b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d8d37c31c759a576e1e9dec98a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b50d8d37c31c759a576e1e9dec98a9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchMatMul, <a class="el" href="classcaffe2_1_1_batch_mat_mul_op.html">BatchMatMulOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2b50d8d37c31c759a576e1e9dec98a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1141b74c0708c627441eec016908db23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1141b74c0708c627441eec016908db23"></a>
where A has&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (dim0, dim1,...M, K)</td></tr>
<tr class="separator:a1141b74c0708c627441eec016908db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbf1fd97d46846af4c0d4415476443f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fbf1fd97d46846af4c0d4415476443f"></a>
where A has B has&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (dim0, dim1,...K, N)</td></tr>
<tr class="separator:a5fbf1fd97d46846af4c0d4415476443f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d732ffb0cdc05fef37d6e8b8f048c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af07d732ffb0cdc05fef37d6e8b8f048c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchSparseToDense, <a class="el" href="classcaffe2_1_1_batch_sparse_to_dense_op.html">BatchSparseToDenseOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af07d732ffb0cdc05fef37d6e8b8f048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd22f0d96a5090e2dc88f23800471d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd22f0d96a5090e2dc88f23800471d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (3, 4).NumOutputs(1).SetDoc(R&quot;DOC( Convert sparse matrix representation into dense matrix. A sparse matrix is represented by `lengths` vector</td></tr>
<tr class="separator:a5fd22f0d96a5090e2dc88f23800471d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c7926bec8532570d0d6302a74351e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74c7926bec8532570d0d6302a74351e5"></a>
indices and values vector Each element in lengths&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (lengths[`i`]) represents the number of indices in this batch(batch`i`).With in each batch</td></tr>
<tr class="separator:a74c7926bec8532570d0d6302a74351e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661de2e8bd57d969076dca9fbbd15c77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a661de2e8bd57d969076dca9fbbd15c77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanMask, <a class="el" href="classcaffe2_1_1_boolean_mask_op.html">BooleanMaskOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a661de2e8bd57d969076dca9fbbd15c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c40f697e54ef82185afeb0d5b9472f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6c40f697e54ef82185afeb0d5b9472f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanMaskLengths, BooleanMaskLengthsOp&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad6c40f697e54ef82185afeb0d5b9472f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13f2d9d0ad031525cc0c52904bdb86e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13f2d9d0ad031525cc0c52904bdb86e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a data tensor and a 1D boolean mask tensor, returns a tensor containing
only the elements corresponding to positions where the mask is true.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ab13f2d9d0ad031525cc0c52904bdb86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d36c646a4af48a91fcd0c8ad36aa5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64d36c646a4af48a91fcd0c8ad36aa5f"></a>
original data tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;mask&quot;,&quot;A tensor of bools of same shape as `data`.&quot;).Output(0</td></tr>
<tr class="separator:a64d36c646a4af48a91fcd0c8ad36aa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a8f5afa2380e4b3773a498f0449f6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a8f5afa2380e4b3773a498f0449f6d"></a>
original data tensor A tensor of same type as data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;masked_indices&quot;,&quot;A tensor for indices.&quot;)</td></tr>
<tr class="separator:a26a8f5afa2380e4b3773a498f0449f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b0c335c868489170192061f2558826"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b0c335c868489170192061f2558826"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;lengths&quot;,&quot;A 1D int32 tensor representing segment lengths.&quot;).Input(1</td></tr>
<tr class="separator:aa9b0c335c868489170192061f2558826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c83f988a1f03f13f0205f158cfcca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2c83f988a1f03f13f0205f158cfcca"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC A bool tensor of values to keep&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;masked_lengths&quot;,&quot;Segment lengths of a masked tensor.&quot;)</td></tr>
<tr class="separator:aca2c83f988a1f03f13f0205f158cfcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1a77ca62e15fbbaa617134bbc329c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e1a77ca62e15fbbaa617134bbc329c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (BooleanMaskLengths)</td></tr>
<tr class="separator:a16e1a77ca62e15fbbaa617134bbc329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a396cc6a0218fb358da4ef87d070a6b0e"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MaskWithFunctor</b> (size_t N, size_t M, int B, const float *in, Functor fn, float fill_val, float *out)</td></tr>
<tr class="separator:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2dd33050e43e411fc20d2865a804d8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d2dd33050e43e411fc20d2865a804d8"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a5d2dd33050e43e411fc20d2865a804d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RepeatedMaskWithFunctor</b> (size_t N, size_t M, int D, const float *in, Functor fn, float fill_val, float *out)</td></tr>
<tr class="separator:a5d2dd33050e43e411fc20d2865a804d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ac3b44a6339d941867ae3df4f345cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ac3b44a6339d941867ae3df4f345cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SequenceMask, <a class="el" href="classcaffe2_1_1_sequence_mask_op.html">SequenceMaskOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a97ac3b44a6339d941867ae3df4f345cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052e727bfc0c72e48ddc42578535e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae052e727bfc0c72e48ddc42578535e54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanUnmask, <a class="el" href="classcaffe2_1_1_boolean_unmask_op.html">BooleanUnmaskOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae052e727bfc0c72e48ddc42578535e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab743435dd156a3ac7f9465777add5e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab743435dd156a3ac7f9465777add5e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n){return n &gt; 0 &amp;&amp;n%2==0;}).NumOutputs(1).SetDoc(R&quot;DOC( Given a series of mask and values</td></tr>
<tr class="separator:aab743435dd156a3ac7f9465777add5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cbde9a8b80bfc14beb2e5552725b3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6cbde9a8b80bfc14beb2e5552725b3e"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True we will accept the first value For False False False True DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;unmasked_data&quot;,&quot;The final reconstructed unmasked data&quot;)</td></tr>
<tr class="separator:ac6cbde9a8b80bfc14beb2e5552725b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e06f847fb5a26f54e6225b3cf9e5c93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e06f847fb5a26f54e6225b3cf9e5c93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Cast, <a class="el" href="classcaffe2_1_1_cast_op.html">CastOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6e06f847fb5a26f54e6225b3cf9e5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322565961cb52c6e30b4b0cb280c0b04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a322565961cb52c6e30b4b0cb280c0b04"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (in[0])</td></tr>
<tr class="separator:a322565961cb52c6e30b4b0cb280c0b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b13bcca4238702e1f3860fb44beecb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b13bcca4238702e1f3860fb44beecb6"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (cast::GetCastDataType(helper,&quot;to&quot;))</td></tr>
<tr class="separator:a7b13bcca4238702e1f3860fb44beecb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbfcaed157fff02678dcaede4e7c7eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bbfcaed157fff02678dcaede4e7c7eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The operator casts the elements of a given input tensor to a data type
specified by the 'to' argument and returns an output tensor of the same size in
the converted type. The 'to' argument must be one of the data types specified
in the 'DataType' enum field in the TensorProto message. If the 'to' argument
is not provided or is not one of the enumerated types in DataType, Caffe2
throws an Enforce error.

NOTE: Casting to and from strings is not supported yet.
)DOC&quot;).Arg(&quot;to&quot;</td></tr>
<tr class="separator:a9bbfcaed157fff02678dcaede4e7c7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2146c51ac83e35c7f96088853b5066cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2146c51ac83e35c7f96088853b5066cd"></a>
The data type to which the elements of the input tensor are cast Strictly must be one of the types from DataType enum in TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;input&quot;,&quot;Input tensor to be cast.&quot;).Output(0</td></tr>
<tr class="separator:a2146c51ac83e35c7f96088853b5066cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca31f20f5f48826244c16253688e969"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ca31f20f5f48826244c16253688e969"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Cast, <a class="el" href="classcaffe2_1_1_get_cast_gradient.html">GetCastGradient</a>)</td></tr>
<tr class="separator:a8ca31f20f5f48826244c16253688e969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674cc31b2aac4d11c3c4c904d500b1bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674cc31b2aac4d11c3c4c904d500b1bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Ceil, <a class="el" href="classcaffe2_1_1_ceil_op.html">CeilOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a674cc31b2aac4d11c3c4c904d500b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010287b826d9507528c87f434a89656d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a010287b826d9507528c87f434a89656d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Ceil takes one input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) and produces one output data
(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) where the ceil function, y = ceil(x), is applied to
the tensor elementwise. Currently supports only float32.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a010287b826d9507528c87f434a89656d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4360ce81661bcefa2d79f3df180f2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4360ce81661bcefa2d79f3df180f2f"></a>
ND input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;ND input tensor&quot;)</td></tr>
<tr class="separator:a0b4360ce81661bcefa2d79f3df180f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bdb2901e888c0122936d0f7abbc78e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44bdb2901e888c0122936d0f7abbc78e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GRADIENT_NOT_IMPLEMENTED_YET</b> (Ceil)</td></tr>
<tr class="separator:a44bdb2901e888c0122936d0f7abbc78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1df83ff9b308cd592da73ded0d46cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc1df83ff9b308cd592da73ded0d46cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelBackpropStats, <a class="el" href="classcaffe2_1_1_channel_backprop_stats_op.html">ChannelBackpropStatsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afc1df83ff9b308cd592da73ded0d46cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56eb89cfd95dc8efc2c24fc1b1f43c21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56eb89cfd95dc8efc2c24fc1b1f43c21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (4).NumOutputs(2).SetDoc(R&quot;DOC( Given an input tensor in NCHW format</td></tr>
<tr class="separator:a56eb89cfd95dc8efc2c24fc1b1f43c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77a1c41934099d8e709424acfe69e53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac77a1c41934099d8e709424acfe69e53"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;The input 4-dimensional tensor of shape NCHW&quot;).Input(1</td></tr>
<tr class="separator:ac77a1c41934099d8e709424acfe69e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5e823bd1a5297db0fdd5b420fa89eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb5e823bd1a5297db0fdd5b420fa89eb"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC The mean saved from the forward pass as a dimensional tensor of size C&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;inv_std&quot;,&quot;The saved inverse standard deviation as a 1-dimensional tensor &quot;&quot;of size C.&quot;).Input(3</td></tr>
<tr class="separator:afb5e823bd1a5297db0fdd5b420fa89eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39073bdd0839017842a6ce618c0fcc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac39073bdd0839017842a6ce618c0fcc9"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC The mean saved from the forward pass as a dimensional tensor of size C Gradient for the output layer of here used as input because we are on the backward pass&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;scale_grad&quot;,&quot;Gradient for the scale vector&quot;).Output(1</td></tr>
<tr class="separator:ac39073bdd0839017842a6ce618c0fcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb7dc3fc153a2bcc28ddf48b3981809"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb7dc3fc153a2bcc28ddf48b3981809"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ChannelBackpropStats)</td></tr>
<tr class="separator:a9cb7dc3fc153a2bcc28ddf48b3981809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1174a2acc80f69b1c4900bedf764eb7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1174a2acc80f69b1c4900bedf764eb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelShuffle, <a class="el" href="classcaffe2_1_1_channel_shuffle_op.html">ChannelShuffleOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa1174a2acc80f69b1c4900bedf764eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8762881e165e41fac886eec2da7c5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8762881e165e41fac886eec2da7c5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelShuffleGradient, <a class="el" href="classcaffe2_1_1_channel_shuffle_gradient_op.html">ChannelShuffleGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a8762881e165e41fac886eec2da7c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1942f40b3c748c8fed39212060a1d1af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1942f40b3c748c8fed39212060a1d1af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ChannelShuffle, <a class="el" href="classcaffe2_1_1_get_channel_shuffle_gradient.html">GetChannelShuffleGradient</a>)</td></tr>
<tr class="separator:a1942f40b3c748c8fed39212060a1d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8565aab178d2940cf141c30bb3ff7eec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8565aab178d2940cf141c30bb3ff7eec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelStats, <a class="el" href="classcaffe2_1_1_channel_stats_op.html">ChannelStatsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8565aab178d2940cf141c30bb3ff7eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099fb98c647d4c955977cf5b90217e4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a099fb98c647d4c955977cf5b90217e4e"></a>
computes the sum of all elements per channel and the sum of all elements squared per channel These values can be reduced across multiple batches and used to obtain the mean and variance across the full set of batches Using the new mean and variance as input to SpatialBN has the effect of changing the batch size over which SpatialBN is applied DOC The output dimensional tensor of size C containing the sum of elements of X per channel&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;sumsq&quot;,&quot;The output 1-dimensional tensor of size C containing the sum of &quot;&quot;elements squared per channel.&quot;)</td></tr>
<tr class="separator:a099fb98c647d4c955977cf5b90217e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526bfbd0065285dc0b9b45e54fa59228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a526bfbd0065285dc0b9b45e54fa59228"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ChannelStats)</td></tr>
<tr class="separator:a526bfbd0065285dc0b9b45e54fa59228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5193b73ccc1a3de3067c1b65af80f23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5193b73ccc1a3de3067c1b65af80f23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Clip, <a class="el" href="classcaffe2_1_1_clip_op.html">ClipOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac5193b73ccc1a3de3067c1b65af80f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36ac85145caad91c4f7aca4a37a4b0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad36ac85145caad91c4f7aca4a37a4b0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ClipGradient, <a class="el" href="classcaffe2_1_1_clip_gradient_op.html">ClipGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad36ac85145caad91c4f7aca4a37a4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7126205a3ff8c1be4df06db4fb3888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f7126205a3ff8c1be4df06db4fb3888"></a>
Key value handler for&#160;</td><td class="memItemRight" valign="bottom"><b>rendezvous</b> (optional).&quot;) .Output(0</td></tr>
<tr class="separator:a1f7126205a3ff8c1be4df06db4fb3888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe63252c455049c7f40f93324a9b05cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe63252c455049c7f40f93324a9b05cf"></a>
Key value handler for A common world for collective operations&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;size&quot;,&quot;(int) size of the common world.&quot;).Arg(&quot;rank&quot;</td></tr>
<tr class="separator:afe63252c455049c7f40f93324a9b05cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ced32a1ee4541cf64c748995a1122"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a352ced32a1ee4541cf64c748995a1122"></a>
Existing common world to clone&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;comm_world&quot;,&quot;A common world for collective operations.&quot;)</td></tr>
<tr class="separator:a352ced32a1ee4541cf64c748995a1122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9010828041090f5fadf2cf3e2074736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9010828041090f5fadf2cf3e2074736"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Closes all connections managed by a common world.&quot;).Input(0</td></tr>
<tr class="separator:ae9010828041090f5fadf2cf3e2074736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03995f4439ef58b918ffe3238b82ab8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af03995f4439ef58b918ffe3238b82ab8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int in, int out){return in &gt;=2 &amp;&amp;out==(in-1);}).EnforceInplace([](int in</td></tr>
<tr class="separator:af03995f4439ef58b918ffe3238b82ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3438d55622475b55fb31e6f03f497a94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3438d55622475b55fb31e6f03f497a94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputsCanCrossDevices</b> ().IdenticalTypeAndShapeOfInput(0).SetDoc(R&quot;DOC( Does a broadcast operation from the root node to every other node. The tensor on each node should have been pre-created with the same shape and data type. )DOC&quot;).Input(0</td></tr>
<tr class="separator:a3438d55622475b55fb31e6f03f497a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a1d56d6f1999f599063f59417f5ed0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9a1d56d6f1999f599063f59417f5ed0"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;X&quot;,&quot;A tensor to be broadcasted.&quot;).Output(0</td></tr>
<tr class="separator:ab9a1d56d6f1999f599063f59417f5ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43b93d19f3c2f0a95acb89b83bdf3e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af43b93d19f3c2f0a95acb89b83bdf3e2"></a>
The common world In place as input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;root&quot;,&quot;(int, default 0) the root to run broadcast from.&quot;)</td></tr>
<tr class="separator:af43b93d19f3c2f0a95acb89b83bdf3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13738a8111fabbb2d9af67defb447672"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13738a8111fabbb2d9af67defb447672"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;X&quot;,&quot;A tensor to be reduced.&quot;).Output(0</td></tr>
<tr class="separator:a13738a8111fabbb2d9af67defb447672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bed02a1873b66e7d1e3113b438c8523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bed02a1873b66e7d1e3113b438c8523"></a>
The common world The reduced result on not set for other nodes&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;root&quot;,&quot;(int, default 0) the root to run reduce into.&quot;)</td></tr>
<tr class="separator:a6bed02a1873b66e7d1e3113b438c8523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0f62d6920884fe591ee7ba9969554f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a0f62d6920884fe591ee7ba9969554f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IdenticalTypeAndShapeOfInput</b> (0).InputsCanCrossDevices().SetDoc(R&quot;DOC( Does an allreduce operation among the nodes. Currently only Sum is supported. )DOC&quot;).Input(0</td></tr>
<tr class="separator:a0a0f62d6920884fe591ee7ba9969554f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80436037cf60851be3a681f7b6a73b5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80436037cf60851be3a681f7b6a73b5f"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;X&quot;,&quot;A tensor to be allreduced.&quot;).Output(0</td></tr>
<tr class="separator:a80436037cf60851be3a681f7b6a73b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c4bdf578dafa89c7286ea3dc8f5bec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c4bdf578dafa89c7286ea3dc8f5bec"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;X&quot;,&quot;A tensor to be reduce-scattered.&quot;).Output(0</td></tr>
<tr class="separator:af0c4bdf578dafa89c7286ea3dc8f5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4bcb2fc070ed6240f7621ecc2cff36b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4bcb2fc070ed6240f7621ecc2cff36b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2, INT_MAX).NumOutputs(1).InputsCanCrossDevices().SetDoc(R&quot;DOC( Does an allgather operation among the nodes. )DOC&quot;).Input(0</td></tr>
<tr class="separator:aa4bcb2fc070ed6240f7621ecc2cff36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad240ba46f9e11ce06726e01a84baaf02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad240ba46f9e11ce06726e01a84baaf02"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;X&quot;,&quot;A tensor to be allgathered.&quot;).Output(0</td></tr>
<tr class="separator:ad240ba46f9e11ce06726e01a84baaf02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea90562061faa0f4d3b04d8850fa1f67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea90562061faa0f4d3b04d8850fa1f67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ({2, 4}).NumOutputs(0).SetDoc(R&quot;DOC( Sends the tensor to another node. )DOC&quot;).Input(0</td></tr>
<tr class="separator:aea90562061faa0f4d3b04d8850fa1f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77dd71ad74652adc585657fce708888b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77dd71ad74652adc585657fce708888b"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;tag&quot;,&quot;An int CPUtensor of size 1 specifying the tag to &quot;&quot;send the tensor with. This overrides the 'tag' &quot;&quot;argument of the op.&quot;).Arg(&quot;dst&quot;</td></tr>
<tr class="separator:a77dd71ad74652adc585657fce708888b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fe2a8704dc473476b0c22866fb5947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4fe2a8704dc473476b0c22866fb5947"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;tag&quot;,&quot;(int) a tag to send the tensor with.&quot;).Arg(&quot;raw_buffer&quot;</td></tr>
<tr class="separator:ab4fe2a8704dc473476b0c22866fb5947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a112d7275e092bef316540a56d4cc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a112d7275e092bef316540a56d4cc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{2, 1},{3, 2}}).SetDoc(R&quot;DOC( Receives the tensor from another node. )DOC&quot;).Input(0</td></tr>
<tr class="separator:a10a112d7275e092bef316540a56d4cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192f36f04e67af2705e1a0035b82fed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192f36f04e67af2705e1a0035b82fed9"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;Y&quot;,&quot;In-place output. If raw_buffer is specified, &quot;&quot;Y should have pre-allocated data and type..&quot;).Input(2</td></tr>
<tr class="separator:a192f36f04e67af2705e1a0035b82fed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fd97021b8de20cf267d263a5986ba0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0fd97021b8de20cf267d263a5986ba0"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;src&quot;,&quot;The sender that sent the message as a CPUTensor &quot;&quot;of size 1 and of type int.&quot;).Output(2</td></tr>
<tr class="separator:ae0fd97021b8de20cf267d263a5986ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a2a1a6b73ca4c422a472bae0fa6852"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32a2a1a6b73ca4c422a472bae0fa6852"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor The tag that the message is sent with as a CPUTensor of size and of type int&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;src&quot;,&quot;(int) he rank to receive the tensor from.&quot;).Arg(&quot;tag&quot;</td></tr>
<tr class="separator:a32a2a1a6b73ca4c422a472bae0fa6852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2170ab87b7a01bda5058b55cd7a7568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2170ab87b7a01bda5058b55cd7a7568"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor The tag that the message is sent with as a CPUTensor of size and of type int int a tag to receive the tensor with&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;raw_buffer&quot;,&quot;(bool) if set, only send the content and assume that the receiver &quot;&quot;has already known the tensor's shape and information.&quot;)</td></tr>
<tr class="separator:ab2170ab87b7a01bda5058b55cd7a7568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49539000e2a5fc0eed28624a67cc016"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad49539000e2a5fc0eed28624a67cc016"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CreateCommonWorld)</td></tr>
<tr class="separator:ad49539000e2a5fc0eed28624a67cc016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd80fe8cac2b741aa8fa72047c63e664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd80fe8cac2b741aa8fa72047c63e664"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CloneCommonWorld)</td></tr>
<tr class="separator:acd80fe8cac2b741aa8fa72047c63e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ae8b96d0cee85e6a82db74a3618dc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19ae8b96d0cee85e6a82db74a3618dc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (DestroyCommonWorld)</td></tr>
<tr class="separator:a19ae8b96d0cee85e6a82db74a3618dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c8f29f71652e7c3a907d4535eb6159"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21c8f29f71652e7c3a907d4535eb6159"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Broadcast)</td></tr>
<tr class="separator:a21c8f29f71652e7c3a907d4535eb6159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48195cc4cdfc484aff4e373cd0648805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48195cc4cdfc484aff4e373cd0648805"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Reduce)</td></tr>
<tr class="separator:a48195cc4cdfc484aff4e373cd0648805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486e2bba9d4e92afa02816e855cafd6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a486e2bba9d4e92afa02816e855cafd6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Allgather)</td></tr>
<tr class="separator:a486e2bba9d4e92afa02816e855cafd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650a7bd191ce63b9d6d128755473a84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3650a7bd191ce63b9d6d128755473a84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Allreduce)</td></tr>
<tr class="separator:a3650a7bd191ce63b9d6d128755473a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c724e821d0034ae05de7c615c444a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850c724e821d0034ae05de7c615c444a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ReduceScatter)</td></tr>
<tr class="separator:a850c724e821d0034ae05de7c615c444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ea3114660c16d1481ce94385984ea0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75ea3114660c16d1481ce94385984ea0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Barrier)</td></tr>
<tr class="separator:a75ea3114660c16d1481ce94385984ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af05c9bf4569fc7a1e46136e8662568"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af05c9bf4569fc7a1e46136e8662568"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SendTensor)</td></tr>
<tr class="separator:a1af05c9bf4569fc7a1e46136e8662568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809d0c77d10a4a63338f8ca0fbc47de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a809d0c77d10a4a63338f8ca0fbc47de3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ReceiveTensor)</td></tr>
<tr class="separator:a809d0c77d10a4a63338f8ca0fbc47de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ffb04b412a41b84a40a7fd9b6af946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82ffb04b412a41b84a40a7fd9b6af946"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateCommonWorld, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a82ffb04b412a41b84a40a7fd9b6af946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f12b032101d7aa1e795701b551e4b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f12b032101d7aa1e795701b551e4b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CloneCommonWorld, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a01f12b032101d7aa1e795701b551e4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9201ba82eb22aa93623df5a9fbace5cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9201ba82eb22aa93623df5a9fbace5cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DestroyCommonWorld, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9201ba82eb22aa93623df5a9fbace5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd7b087b2d8b2dc61f4f112ca50e9a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafd7b087b2d8b2dc61f4f112ca50e9a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Broadcast, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aafd7b087b2d8b2dc61f4f112ca50e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce28a459d4946861f99180a38be193"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacce28a459d4946861f99180a38be193"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Reduce, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aacce28a459d4946861f99180a38be193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19489cdede91acaa8530900fdfae472"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa19489cdede91acaa8530900fdfae472"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Allgather, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa19489cdede91acaa8530900fdfae472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf22b5e8ec68635f0d7351a55d8ea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38bf22b5e8ec68635f0d7351a55d8ea9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Allreduce, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38bf22b5e8ec68635f0d7351a55d8ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9fe18433659566bdad6651064056fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a9fe18433659566bdad6651064056fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceScatter, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8a9fe18433659566bdad6651064056fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0484a83e1404939b456a983ec76da4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0484a83e1404939b456a983ec76da4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Barrier, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa0484a83e1404939b456a983ec76da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a563f491bf45a8612a48b0f04bfe435"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a563f491bf45a8612a48b0f04bfe435"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SendTensor, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3a563f491bf45a8612a48b0f04bfe435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a16bcddd44f6b9d0f58f054404c8be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a16bcddd44f6b9d0f58f054404c8be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReceiveTensor, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a26a16bcddd44f6b9d0f58f054404c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9536c5e72afa35d3384fcea4e85915"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c9536c5e72afa35d3384fcea4e85915"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateCommonWorld, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c9536c5e72afa35d3384fcea4e85915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae687b04805f1b278252e645b04845609"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae687b04805f1b278252e645b04845609"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CloneCommonWorld, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae687b04805f1b278252e645b04845609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78998b74f7a886416d7a5cd6c98e1d0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78998b74f7a886416d7a5cd6c98e1d0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Broadcast, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a78998b74f7a886416d7a5cd6c98e1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf14488f591c1013139b4fb48fcb05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41cf14488f591c1013139b4fb48fcb05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Reduce, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a41cf14488f591c1013139b4fb48fcb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb5146bdc443e27be1d0feb34aa305c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bb5146bdc443e27be1d0feb34aa305c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Allgather, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a8bb5146bdc443e27be1d0feb34aa305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e6a068bd3b4a89754a5d5db34d414b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e6a068bd3b4a89754a5d5db34d414b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Allreduce, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a25e6a068bd3b4a89754a5d5db34d414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1514f4ab94c412972f50cc3f9fd2110c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1514f4ab94c412972f50cc3f9fd2110c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SendTensor, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a1514f4ab94c412972f50cc3f9fd2110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e2dadc8ec3fab95bd31ae67f00ac04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37e2dadc8ec3fab95bd31ae67f00ac04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ReceiveTensor, <a class="el" href="classcaffe2_1_1_no_default_engine_op.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a37e2dadc8ec3fab95bd31ae67f00ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f36c0089fc94b6017420b6e513ea631"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f36c0089fc94b6017420b6e513ea631"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Split, <a class="el" href="classcaffe2_1_1_split_op.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9f36c0089fc94b6017420b6e513ea631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dadc37c106c87f6b5a4f1fa50260d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dadc37c106c87f6b5a4f1fa50260d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Concat, <a class="el" href="classcaffe2_1_1_concat_op.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96dadc37c106c87f6b5a4f1fa50260d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2796d3e2dd75c75b4dcc84d8d912b044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2796d3e2dd75c75b4dcc84d8d912b044"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;input&quot;,&quot;The tensor to split&quot;).Input(1</td></tr>
<tr class="separator:a2796d3e2dd75c75b4dcc84d8d912b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bb4ef5f44f680faaf8007994f2801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d5bb4ef5f44f680faaf8007994f2801"></a>
INT_MAX Optional list of output&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b> (see also arg 'split')&quot;) .Arg(&quot;axis&quot;</td></tr>
<tr class="separator:a8d5bb4ef5f44f680faaf8007994f2801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7017a1ace23b0e8e35ef3af2d36cda93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7017a1ace23b0e8e35ef3af2d36cda93"></a>
INT_MAX Optional list of output Which axis to split on&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;split&quot;,&quot;length of each output&quot;).Arg(&quot;order&quot;</td></tr>
<tr class="separator:a7017a1ace23b0e8e35ef3af2d36cda93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a680c2a03838257983454ef3df8ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a680c2a03838257983454ef3df8ac8"></a>
INT_MAX Optional list of output Which axis to split on Either NHWC or will split on C defaults to NCHW&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Split a tensor into a list of tensors, along the specified
'axis'. The lengths of the split can be specified using argument 'axis' or
optional second input blob to the operator. Otherwise, the tensor is split
to equal sized parts.
)DOC&quot;)</td></tr>
<tr class="separator:a44a680c2a03838257983454ef3df8ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8476fd5adf9b91b80df1a23c791fc736"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8476fd5adf9b91b80df1a23c791fc736"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, INT_MAX).NumOutputs(2).Arg(&quot;axis&quot;</td></tr>
<tr class="separator:a8476fd5adf9b91b80df1a23c791fc736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae017fde139e10a65c01f6e754c230455"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae017fde139e10a65c01f6e754c230455"></a>
Which axis to concat on&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;order&quot;,&quot;Either NHWC or NCHW, will concat on C axis, defaults to NCHW&quot;).Arg(&quot;add_axis&quot;</td></tr>
<tr class="separator:ae017fde139e10a65c01f6e754c230455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a148fcea0d59568230560038b517d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9a148fcea0d59568230560038b517d6"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);const int axis=helper.HasArgument(&quot;axis&quot;)?helper.GetSingleArgument&lt; int &gt;(&quot;axis&quot;,-1):GetDimFromOrderString(helper.GetSingleArgument&lt; string &gt;(&quot;order&quot;,&quot;NCHW&quot;));bool add_axis=helper.GetSingleArgument&lt; int &gt;(&quot;add_axis&quot;, 0)!=0;const int canonical_axis=canonical_axis_index_(axis, in[0].dims_size());CAFFE_ENFORCE_GT(in.size(), 0);vector&lt; int &gt; split_shape(1, in.size());vector&lt; int &gt; out_shape(in[0].dims().begin(), in[0].dims().end());if(add_axis){for(int i=1;i&lt; in.size();++i){CAFFE_ENFORCE_EQ(in[0].dims().size(), in[i].dims().size(),&quot;All inputs of Concat should have same dims when add_axis = 1. &quot;&quot;Got different sizes for inputs 0 and &quot;, i);for(int j=0;j&lt; in[0].dims().size();++j){CAFFE_ENFORCE_EQ(in[0].dims(j), in[i].dims(j),&quot;All inputs of Concat should have same dims when add_axis = 1. &quot;&quot;Got different dims for inputs 0 and &quot;, i,&quot;. At dim: &quot;, j);}}out_shape.insert(out_shape.begin()+canonical_axis, in.size());}else{for(int i=1;i&lt; in.size();++i){CAFFE_ENFORCE_EQ(in[0].dims().size(), in[i].dims().size(),&quot;All inputs of Concat should have same dims except &quot;&quot;canonical_axis dim that is equal to &quot;, canonical_axis,&quot;Got different sizes for inputs 0 and &quot;, i);for(int j=0;j&lt; in[0].dims().size();++j){if(j==canonical_axis){continue;}CAFFE_ENFORCE_EQ(in[0].dims(j), in[i].dims(j),&quot;All inputs of Concat should have same dims except &quot;&quot;canonical_axis dim that is equal to &quot;, canonical_axis,&quot;Got different dims for inputs 0 and &quot;, i,&quot;. At dim: &quot;, j);}}for(int i=1;i&lt; in.size();++i){out_shape[canonical_axis]+=in[i].dims(canonical_axis);}}if(def.output_size()==1){return vector&lt; TensorShape &gt;{CreateTensorShape(out_shape, in[0].data_type())};}return vector&lt; TensorShape &gt;{CreateTensorShape(out_shape, in[0].data_type()), CreateTensorShape(split_shape, TensorProto::INT32)};}).CostInferenceFunction(CostInferenceForConcat).SetDoc(&quot;Concatenate a list of tensors into a single tensor&quot;).Output(0</td></tr>
<tr class="separator:af9a148fcea0d59568230560038b517d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa217105861d43ed90b662b103097e203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa217105861d43ed90b662b103097e203"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors Concatenated tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;split_info&quot;,&quot;The dimensions of the inputs.&quot;)</td></tr>
<tr class="separator:aa217105861d43ed90b662b103097e203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dee9617b37d653dc8af9efc6e59ca39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dee9617b37d653dc8af9efc6e59ca39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DepthSplit, <a class="el" href="classcaffe2_1_1_split_op.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7dee9617b37d653dc8af9efc6e59ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e29368e00f7b6bbe85ac05aa1f23ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e29368e00f7b6bbe85ac05aa1f23ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DepthConcat, <a class="el" href="classcaffe2_1_1_concat_op.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a16e29368e00f7b6bbe85ac05aa1f23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d4cebb2b53b2311c7010f5aa3979e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d0d4cebb2b53b2311c7010f5aa3979e"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Backward compatible operator name for Split.&quot;)</td></tr>
<tr class="separator:a4d0d4cebb2b53b2311c7010f5aa3979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa280a02008baa5e6d85aeee0d890a968"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa280a02008baa5e6d85aeee0d890a968"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Split, <a class="el" href="classcaffe2_1_1_get_split_gradient.html">GetSplitGradient</a>)</td></tr>
<tr class="separator:aa280a02008baa5e6d85aeee0d890a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae96181d03ea1ae68aba6dc91adda4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ae96181d03ea1ae68aba6dc91adda4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DepthSplit, <a class="el" href="classcaffe2_1_1_get_split_gradient.html">GetSplitGradient</a>)</td></tr>
<tr class="separator:a13ae96181d03ea1ae68aba6dc91adda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a8621852a16e99cc7beeb198416a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a398a8621852a16e99cc7beeb198416a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Concat, <a class="el" href="classcaffe2_1_1_get_concat_gradient.html">GetConcatGradient</a>)</td></tr>
<tr class="separator:a398a8621852a16e99cc7beeb198416a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef6f1bee2d410e1173b6f2303091f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5ef6f1bee2d410e1173b6f2303091f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DepthConcat, <a class="el" href="classcaffe2_1_1_get_concat_gradient.html">GetConcatGradient</a>)</td></tr>
<tr class="separator:aa5ef6f1bee2d410e1173b6f2303091f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf259b0449f20ec531eca7fab0c7c08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbf259b0449f20ec531eca7fab0c7c08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Split, <a class="el" href="classcaffe2_1_1_split_op.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adbf259b0449f20ec531eca7fab0c7c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0a837afc1d3fc0bb6641916b60d183"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c0a837afc1d3fc0bb6641916b60d183"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Concat, <a class="el" href="classcaffe2_1_1_concat_op.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0c0a837afc1d3fc0bb6641916b60d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf43127339fd7014056ad39fa6ab9a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf43127339fd7014056ad39fa6ab9a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DepthSplit, <a class="el" href="classcaffe2_1_1_split_op.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7bf43127339fd7014056ad39fa6ab9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe48756a227d7227b1c04866552fa49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe48756a227d7227b1c04866552fa49e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DepthConcat, <a class="el" href="classcaffe2_1_1_concat_op.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abe48756a227d7227b1c04866552fa49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daa15e8091929ad231fc747b512a49e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3daa15e8091929ad231fc747b512a49e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conditional, <a class="el" href="classcaffe2_1_1_conditional_op.html">ConditionalOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3daa15e8091929ad231fc747b512a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0e6d635ffd0fab0fda70aff7cdc92b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add0e6d635ffd0fab0fda70aff7cdc92b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (3).NumOutputs(1).SetDoc(R&quot;DOC( Given a 1-D tensor of boolean values</td></tr>
<tr class="separator:add0e6d635ffd0fab0fda70aff7cdc92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831a644375c51e977b484f4bb0b3eb42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a831a644375c51e977b484f4bb0b3eb42"></a>
apply conditional&#160;</td><td class="memItemRight" valign="bottom"><b>operator along the first dimension of DataT and DataF and return DataO.Note, DataT and DataF must have the exact same shape and type.) DOC&quot;) .Input</b> (0,&quot;Condition&quot;,&quot;Boolean tensor to select DataT or DataF&quot;).Input(1</td></tr>
<tr class="separator:a831a644375c51e977b484f4bb0b3eb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a0aed8fa5c46c6a597ae99d45d2c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42a0aed8fa5c46c6a597ae99d45d2c81"></a>
apply conditional Data to use when True&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;DataF&quot;,&quot;Data to use when False&quot;).Output(0</td></tr>
<tr class="separator:a42a0aed8fa5c46c6a597ae99d45d2c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257fa8ed03c06d3e11a454096c47b128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257fa8ed03c06d3e11a454096c47b128"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Conditional)</td></tr>
<tr class="separator:a257fa8ed03c06d3e11a454096c47b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de298be2221d805d6cf340faa5c2265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2de298be2221d805d6cf340faa5c2265"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2de298be2221d805d6cf340faa5c2265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052eeee20416bfbdb6da73fa3af29d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8052eeee20416bfbdb6da73fa3af29d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ConvGradient).NumInputs(2</td></tr>
<tr class="separator:a8052eeee20416bfbdb6da73fa3af29d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfdb1488130c01386f73e009ebdea3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dfdb1488130c01386f73e009ebdea3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0dfdb1488130c01386f73e009ebdea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e6db089dfe1d69e2ca5cbf652967f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad62e6db089dfe1d69e2ca5cbf652967f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv1DGradient).NumInputs(2</td></tr>
<tr class="separator:ad62e6db089dfe1d69e2ca5cbf652967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11dcdfa25eba74b23ae88c1f44ba203"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11dcdfa25eba74b23ae88c1f44ba203"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac11dcdfa25eba74b23ae88c1f44ba203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f149930c99026da1f513db4befb90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5f149930c99026da1f513db4befb90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv2DGradient).NumInputs(2</td></tr>
<tr class="separator:ae5f149930c99026da1f513db4befb90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d87b91c30feba32d163573ad815f0ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d87b91c30feba32d163573ad815f0ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8d87b91c30feba32d163573ad815f0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862914a1ce4ce4da75ad17b8858e55ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a862914a1ce4ce4da75ad17b8858e55ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv3DGradient).NumInputs(2</td></tr>
<tr class="separator:a862914a1ce4ce4da75ad17b8858e55ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0539c8ad037562f59ed975c7ac7f228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0539c8ad037562f59ed975c7ac7f228"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv, <a class="el" href="classcaffe2_1_1_get_conv_gradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:ab0539c8ad037562f59ed975c7ac7f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e1facdf457ef2f4a647bd0c1ef778c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50e1facdf457ef2f4a647bd0c1ef778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv1D, <a class="el" href="classcaffe2_1_1_get_conv_gradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:a50e1facdf457ef2f4a647bd0c1ef778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff75df71a3e0f3d4fb9d75cf0482770"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ff75df71a3e0f3d4fb9d75cf0482770"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv2D, <a class="el" href="classcaffe2_1_1_get_conv_gradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:a3ff75df71a3e0f3d4fb9d75cf0482770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7d7984044891abad49d3f2bb4e5e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3d7d7984044891abad49d3f2bb4e5e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv3D, <a class="el" href="classcaffe2_1_1_get_conv_gradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:af3d7d7984044891abad49d3f2bb4e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdb4117c1bb618fdcb09cc2ac08a05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cdb4117c1bb618fdcb09cc2ac08a05b"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConvDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a4cdb4117c1bb618fdcb09cc2ac08a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a8f1035b50560b24e2f5e6abcbd334"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a8f1035b50560b24e2f5e6abcbd334"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af4a8f1035b50560b24e2f5e6abcbd334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035c36ce45aefac076a5c9ac8a7f9c9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a035c36ce45aefac076a5c9ac8a7f9c9f"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a035c36ce45aefac076a5c9ac8a7f9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e40db5ddd44443696571030136db98e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e40db5ddd44443696571030136db98e"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4e40db5ddd44443696571030136db98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2db24bf5f19e28466d9ae3faa94d10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e2db24bf5f19e28466d9ae3faa94d10"></a>
NumInputs(2, 3).NumOutputs(1).CostInferenceFunction(<a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0e2db24bf5f19e28466d9ae3faa94d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55e76f6280fa3c180bc1c5575d7031"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a55e76f6280fa3c180bc1c5575d7031"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1_cudnn_conv_op.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a3a55e76f6280fa3c180bc1c5575d7031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe80cf5ad02fd87783df2f3bd68913"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ababe80cf5ad02fd87783df2f3bd68913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1_cudnn_conv_gradient_op.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:ababe80cf5ad02fd87783df2f3bd68913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef673b86ba934e008ccb3d8ef8fe6b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abef673b86ba934e008ccb3d8ef8fe6b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1_cudnn_conv_op.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:abef673b86ba934e008ccb3d8ef8fe6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf00e30165169fd98a32db8725a60ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedf00e30165169fd98a32db8725a60ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1_cudnn_conv_gradient_op.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:aedf00e30165169fd98a32db8725a60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1008188d46c33ac672d2716970e9b529"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1008188d46c33ac672d2716970e9b529"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1_cudnn_conv_op.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a1008188d46c33ac672d2716970e9b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65994e157c44fc7c7b2fc88bb67d08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a65994e157c44fc7c7b2fc88bb67d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1_cudnn_conv_gradient_op.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:a5a65994e157c44fc7c7b2fc88bb67d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c17613f95bd532fba0b3e9b8e91fe8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79c17613f95bd532fba0b3e9b8e91fe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1_cudnn_conv_op.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a79c17613f95bd532fba0b3e9b8e91fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6728f13e1f07639c0a4064b50cc7487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6728f13e1f07639c0a4064b50cc7487"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1_cudnn_conv_gradient_op.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:ab6728f13e1f07639c0a4064b50cc7487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2093f470591d86aec9503bbf58857b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f2093f470591d86aec9503bbf58857b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv, EIGEN, <a class="el" href="classcaffe2_1_1_eigen_conv_op.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5f2093f470591d86aec9503bbf58857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5981b5c7ff364dbc3a58a3bd24ac81df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5981b5c7ff364dbc3a58a3bd24ac81df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv1D, EIGEN, <a class="el" href="classcaffe2_1_1_eigen_conv_op.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5981b5c7ff364dbc3a58a3bd24ac81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b38b7b795eb17199c291779b54cdda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4b38b7b795eb17199c291779b54cdda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv2D, EIGEN, <a class="el" href="classcaffe2_1_1_eigen_conv_op.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:ad4b38b7b795eb17199c291779b54cdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaa995f1db066c891e9c91639af53ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5eaa995f1db066c891e9c91639af53ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv3D, EIGEN, <a class="el" href="classcaffe2_1_1_eigen_conv_op.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5eaa995f1db066c891e9c91639af53ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0080513a31b41074defde34c59a7631d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0080513a31b41074defde34c59a7631d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0080513a31b41074defde34c59a7631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d484f11ab3fc6b654748ee90835d42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4d484f11ab3fc6b654748ee90835d42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa4d484f11ab3fc6b654748ee90835d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2670912f01d9b13ad0c7f051fb231eaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2670912f01d9b13ad0c7f051fb231eaa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2670912f01d9b13ad0c7f051fb231eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c0504914ea9f630a02b80e96233c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e3c0504914ea9f630a02b80e96233c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6e3c0504914ea9f630a02b80e96233c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4417c57afc2b9d325a88e9ce1f47c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e4417c57afc2b9d325a88e9ce1f47c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad7e4417c57afc2b9d325a88e9ce1f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad747122b1d6b00d39fb715796975f6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad747122b1d6b00d39fb715796975f6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1_conv_op.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aad747122b1d6b00d39fb715796975f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75eedba15c075b77730337efc10e59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c75eedba15c075b77730337efc10e59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1_conv_gradient_op.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c75eedba15c075b77730337efc10e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88a107a6c3915d6363926a599dca0c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9f88a107a6c3915d6363926a599dca0c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9f88a107a6c3915d6363926a599dca0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createSharedBuffer&lt; CPUContext &gt;</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a9f88a107a6c3915d6363926a599dca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memTemplParams" colspan="2"><a class="anchor" id="aea0c1e1bcf3b2b2d6c77ecd7f3211720"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runWithSharedBuffer</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt; *buffer)&gt; f)</td></tr>
<tr class="separator:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bab26d8f00817d54cb0d975ea633123"><td class="memTemplParams" colspan="2">template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a5bab26d8f00817d54cb0d975ea633123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5bab26d8f00817d54cb0d975ea633123">createSharedBuffer</a> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws)</td></tr>
<tr class="memdesc:a5bab26d8f00817d54cb0d975ea633123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutex and shared buffer in the workspace.  <a href="#a5bab26d8f00817d54cb0d975ea633123">More...</a><br /></td></tr>
<tr class="separator:a5bab26d8f00817d54cb0d975ea633123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caaa1d4761b04f91851fb04ec265399"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0caaa1d4761b04f91851fb04ec265399"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a0caaa1d4761b04f91851fb04ec265399"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a0caaa1d4761b04f91851fb04ec265399">runWithSharedBuffer</a> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; *buffer)&gt; f)</td></tr>
<tr class="memdesc:a0caaa1d4761b04f91851fb04ec265399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe, can be invoked from RunOnDevice() to serialize access to shared buffer. <br /></td></tr>
<tr class="separator:a0caaa1d4761b04f91851fb04ec265399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498e06540c78d810ee1f4ab906a41bd8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a498e06540c78d810ee1f4ab906a41bd8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a498e06540c78d810ee1f4ab906a41bd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createSharedBuffer&lt; CUDAContext &gt;</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a498e06540c78d810ee1f4ab906a41bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43f5c23e200a2e32eb29c9aa761f4746"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runWithSharedBuffer</b> (<a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt; *buffer)&gt; f)</td></tr>
<tr class="separator:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1_conv_transpose_gradient_op.html">ConvTransposeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2886c6933fd6befaa73b27927d1c6b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2886c6933fd6befaa73b27927d1c6b8c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ConvTransposeGradient).NumInputs(3).NumOutputs(1</td></tr>
<tr class="separator:a2886c6933fd6befaa73b27927d1c6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809c4b5ea9c977ed42d9fbb0b8e704e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3809c4b5ea9c977ed42d9fbb0b8e704e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1_get_conv_transpose_gradient.html">GetConvTransposeGradient</a>)</td></tr>
<tr class="separator:a3809c4b5ea9c977ed42d9fbb0b8e704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7221ade0eb07cf5a7cce0a034c34e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7221ade0eb07cf5a7cce0a034c34e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1_conv_transpose_op.html">ConvTransposeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c7221ade0eb07cf5a7cce0a034c34e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab288791569aeaec6b4916542a084b87d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab288791569aeaec6b4916542a084b87d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2, 3).NumOutputs(1).SetDoc(R&quot;DOC( The transposed convolution consumes an input vector</td></tr>
<tr class="separator:ab288791569aeaec6b4916542a084b87d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964d5140bae2c899d71b7e9e089d0422"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a964d5140bae2c899d71b7e9e089d0422"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;Input data blob from previous layer; has size &quot;&quot;(N x C x H x W), where N is the batch size, C is the number of channels, and&quot;&quot; H and W are the height and width. Note that this is for the NCHW usage. On &quot;&quot;the other hand, the NHWC Op has a different set of dimension constraints.&quot;).Input(1</td></tr>
<tr class="separator:a964d5140bae2c899d71b7e9e089d0422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52acc2a6e4814b467101edb9dfe022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a52acc2a6e4814b467101edb9dfe022"></a>
has&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (M x C x kH x kW)</td></tr>
<tr class="separator:a6a52acc2a6e4814b467101edb9dfe022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942109e38e9e63942f0974a34ab25e3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a942109e38e9e63942f0974a34ab25e3f"></a>
has where C is the number of and kH and kW are the height and width of the kernel&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;bias&quot;,&quot;The 1D bias blob that is added through the convolution;&quot;&quot;has size (C). Optional, if not passed, will treat it as all 0.&quot;).Output(0</td></tr>
<tr class="separator:a942109e38e9e63942f0974a34ab25e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e8432ee0a969ed41eecea44dd07a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f8e8432ee0a969ed41eecea44dd07a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1_cudnn_conv_transpose_op.html">CudnnConvTransposeOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a1f8e8432ee0a969ed41eecea44dd07a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5c15ee4460f36e2d806f31ad868a19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5c15ee4460f36e2d806f31ad868a19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1_cudnn_conv_transpose_gradient_op.html">CudnnConvTransposeGradientOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a0b5c15ee4460f36e2d806f31ad868a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467c89d9a81c34c23afc470ad0f46355"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a467c89d9a81c34c23afc470ad0f46355"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1_conv_transpose_op.html">ConvTransposeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a467c89d9a81c34c23afc470ad0f46355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9257b79fa1cebcfe21372c7b61c2b182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9257b79fa1cebcfe21372c7b61c2b182"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1_conv_transpose_gradient_op.html">ConvTransposeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9257b79fa1cebcfe21372c7b61c2b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7091fca08890f3b0c3cb72e3aac66491"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7091fca08890f3b0c3cb72e3aac66491"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Cos, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_cos_c_p_u_functor.html">CosCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a7091fca08890f3b0c3cb72e3aac66491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c860f817f6c9e8ca25d0394e324722"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7c860f817f6c9e8ca25d0394e324722"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_cos_gradient_c_p_u_functor.html">CosGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:ae7c860f817f6c9e8ca25d0394e324722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5ad69932bf57b804104f6d28904019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5ad69932bf57b804104f6d28904019"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CosGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:adf5ad69932bf57b804104f6d28904019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc548c2c8f9a883536882f1ba0860f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fc548c2c8f9a883536882f1ba0860f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Cos, <a class="el" href="classcaffe2_1_1_get_cos_gradient.html">GetCosGradient</a>)</td></tr>
<tr class="separator:a5fc548c2c8f9a883536882f1ba0860f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa7665df55970fa98126428f43a61fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefa7665df55970fa98126428f43a61fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineEmbeddingCriterion, <a class="el" href="classcaffe2_1_1_cosine_embedding_criterion_op.html">CosineEmbeddingCriterionOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aefa7665df55970fa98126428f43a61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eb38b712b2fff805f5b7eea6dd4f4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6eb38b712b2fff805f5b7eea6dd4f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineEmbeddingCriterionGradient, <a class="el" href="classcaffe2_1_1_cosine_embedding_criterion_gradient_op.html">CosineEmbeddingCriterionGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac6eb38b712b2fff805f5b7eea6dd4f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed8fef54afee9a213146e58071ff945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ed8fef54afee9a213146e58071ff945"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateCounter, <a class="el" href="classcaffe2_1_1_create_counter_op.html">CreateCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7ed8fef54afee9a213146e58071ff945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce03ab286c508bef6e2f333f7ba209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14ce03ab286c508bef6e2f333f7ba209"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResetCounter, <a class="el" href="classcaffe2_1_1_reset_counter_op.html">ResetCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a14ce03ab286c508bef6e2f333f7ba209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2cc9daa694e95b811d5b931601eb59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a2cc9daa694e95b811d5b931601eb59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CountDown, <a class="el" href="classcaffe2_1_1_count_down_op.html">CountDownOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a2cc9daa694e95b811d5b931601eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce152bf1ed15524a042b3be386d9171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce152bf1ed15524a042b3be386d9171"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CheckCounterDone, <a class="el" href="classcaffe2_1_1_check_counter_done_op.html">CheckCounterDoneOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2ce152bf1ed15524a042b3be386d9171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af776edd8c4b941a72a3f1c2f0a7b038f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af776edd8c4b941a72a3f1c2f0a7b038f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CountUp, <a class="el" href="classcaffe2_1_1_count_up_op.html">CountUpOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af776edd8c4b941a72a3f1c2f0a7b038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed2de4731cd839dc300a62974cbcde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eed2de4731cd839dc300a62974cbcde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RetrieveCount, <a class="el" href="classcaffe2_1_1_retrieve_count_op.html">RetrieveCountOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7eed2de4731cd839dc300a62974cbcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8022518c554f47cd3e4b06b31ff816c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8022518c554f47cd3e4b06b31ff816c2"></a>
A blob pointing to an instance of a new counter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;init_count&quot;,&quot;Initial count for the counter, must be &gt;= 0.&quot;)</td></tr>
<tr class="separator:a8022518c554f47cd3e4b06b31ff816c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539af0f5d537eec29e07cabfc19d54e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a539af0f5d537eec29e07cabfc19d54e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Resets a count-down counter with initial value specified by the 'init_count'
argument.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a539af0f5d537eec29e07cabfc19d54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa021d042370b6ace6e21eec9510165ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa021d042370b6ace6e21eec9510165ec"></a>
A blob pointing to an instance of a new counter&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;previous_value&quot;,&quot;(optional) Previous value of the counter.&quot;).Arg(&quot;init_count&quot;</td></tr>
<tr class="separator:aa021d042370b6ace6e21eec9510165ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045b0015362f294d90b189d378ee448b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a045b0015362f294d90b189d378ee448b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateCounter, <a class="el" href="classcaffe2_1_1_create_counter_op.html">CreateCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a045b0015362f294d90b189d378ee448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4aaff7be981c8f50228bf65129fe16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb4aaff7be981c8f50228bf65129fe16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ResetCounter, <a class="el" href="classcaffe2_1_1_reset_counter_op.html">ResetCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aeb4aaff7be981c8f50228bf65129fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092617e34390d060ade14cf0f428b7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092617e34390d060ade14cf0f428b7e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CountDown, <a class="el" href="classcaffe2_1_1_count_down_op.html">CountDownOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a092617e34390d060ade14cf0f428b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414b411f8598bdcf7a5759273f5dbc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5414b411f8598bdcf7a5759273f5dbc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CheckCounterDone, <a class="el" href="classcaffe2_1_1_check_counter_done_op.html">CheckCounterDoneOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a5414b411f8598bdcf7a5759273f5dbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e2919309940df0230167b891aa4460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67e2919309940df0230167b891aa4460"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CountUp, <a class="el" href="classcaffe2_1_1_count_up_op.html">CountUpOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a67e2919309940df0230167b891aa4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd301bfab132a9b2529d1e05a6185f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfd301bfab132a9b2529d1e05a6185f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RetrieveCount, <a class="el" href="classcaffe2_1_1_retrieve_count_op.html">RetrieveCountOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abfd301bfab132a9b2529d1e05a6185f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06db80a0517868754937406c34a8544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af06db80a0517868754937406c34a8544"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1detail_1_1_workspace_stack.html">detail::WorkspaceStack</a>)</td></tr>
<tr class="separator:af06db80a0517868754937406c34a8544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8604e71023fd1d73c9c4940e3ee41b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca8604e71023fd1d73c9c4940e3ee41b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateScope, <a class="el" href="classcaffe2_1_1_create_scope_op.html">CreateScopeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aca8604e71023fd1d73c9c4940e3ee41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57ae8ea03d63bc92f1be201ecc25eef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa57ae8ea03d63bc92f1be201ecc25eef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CreateScope)</td></tr>
<tr class="separator:aa57ae8ea03d63bc92f1be201ecc25eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb85c896ba4e9c67180b6a2dd5ab282"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabb85c896ba4e9c67180b6a2dd5ab282"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateScope).NumInputs(0).NumOutputs(1).SetDoc(R&quot;DOC( 'CreateScope' operator initializes and outputs empty scope that is used by Do operator to store local blobs )DOC&quot;)</td></tr>
<tr class="separator:aabb85c896ba4e9c67180b6a2dd5ab282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c0f2068c0ef86c22c5deb60c8130d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a4c0f2068c0ef86c22c5deb60c8130d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (HasScope, <a class="el" href="classcaffe2_1_1_has_scope_op.html">HasScopeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2a4c0f2068c0ef86c22c5deb60c8130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ddc7882e5c7d177c933870427f0d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33ddc7882e5c7d177c933870427f0d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (HasScope)</td></tr>
<tr class="separator:ae33ddc7882e5c7d177c933870427f0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ec89b16557060167a914f41aae3b95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ec89b16557060167a914f41aae3b95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (HasScope).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( Checks whether scope blob has any saved scopes left )DOC&quot;)</td></tr>
<tr class="separator:ad8ec89b16557060167a914f41aae3b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4396fc145639b103c925214fbc6303"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c4396fc145639b103c925214fbc6303"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LabelCrossEntropy, <a class="el" href="classcaffe2_1_1_label_cross_entropy_op.html">LabelCrossEntropyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7c4396fc145639b103c925214fbc6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312a993638b53afa2e9a3c6d3a0972e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a312a993638b53afa2e9a3c6d3a0972e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LabelCrossEntropyGradient, <a class="el" href="classcaffe2_1_1_label_cross_entropy_gradient_op.html">LabelCrossEntropyGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a312a993638b53afa2e9a3c6d3a0972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12303b7a4dd0a741e7ac1610b5dcf13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad12303b7a4dd0a741e7ac1610b5dcf13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1_operator.html">Operator</a> computes the cross entropy between the input and the label set. In
 practice, it is most commonly used at the end of models, after the SoftMax
 operator and before the <a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a> operator. Note that LabelCrossEntropy
 assumes that the label provided is either a 1D array of size N (batch size), or
 a 2D array of size N x 1 (batch size). Each entry in the label vector indicates
 which is the correct class; as such, each entry must be between 0 and D - 1,
 inclusive, where D is the total number of classes. The formula used is:

                            Y[i] = -log(X[i][j])

 where (i, j) is the classifier's prediction of the jth class (the correct one),
 and i is the batch size. Each log has a lower limit for numerical stability.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ad12303b7a4dd0a741e7ac1610b5dcf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1045a698842fad907f188edd4974c052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1045a698842fad907f188edd4974c052"></a>
X is a array of size N x where N is the batch size and D is the number of classes&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;label&quot;,&quot;<a class="el" href="classcaffe2_1_1_blob.html">Blob</a> containing the labels used to compare the input&quot;).Output(0</td></tr>
<tr class="separator:a1045a698842fad907f188edd4974c052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a042db7e40bc940d4c8621a642a4001"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a042db7e40bc940d4c8621a642a4001"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LabelCrossEntropy, <a class="el" href="classcaffe2_1_1_get_label_cross_entropy_gradient.html">GetLabelCrossEntropyGradient</a>)</td></tr>
<tr class="separator:a8a042db7e40bc940d4c8621a642a4001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465467c9f5367cc0dad262ca2185848c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a465467c9f5367cc0dad262ca2185848c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MakeTwoClass, <a class="el" href="classcaffe2_1_1_make_two_class_op.html">MakeTwoClassOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a465467c9f5367cc0dad262ca2185848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafe7fba6fa17a784791c76c60c4a28c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaafe7fba6fa17a784791c76c60c4a28c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MakeTwoClassGradient, <a class="el" href="classcaffe2_1_1_make_two_class_gradient_op.html">MakeTwoClassGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aaafe7fba6fa17a784791c76c60c4a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292b58d85aeff0ac8d19e47458baaad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab292b58d85aeff0ac8d19e47458baaad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyWithLogits, <a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_with_logits_op.html">SigmoidCrossEntropyWithLogitsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab292b58d85aeff0ac8d19e47458baaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd06f57da40b896837de2110f2898e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fd06f57da40b896837de2110f2898e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyWithLogitsGradient, <a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_with_logits_gradient_op.html">SigmoidCrossEntropyWithLogitsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4fd06f57da40b896837de2110f2898e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0335af892586700897d690af0cf6ffc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0335af892586700897d690af0cf6ffc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSigmoidCrossEntropyWithLogits, <a class="el" href="classcaffe2_1_1_weighted_sigmoid_cross_entropy_with_logits_op.html">WeightedSigmoidCrossEntropyWithLogitsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0335af892586700897d690af0cf6ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceca955ee067384ace9f0c1d1676f3cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceca955ee067384ace9f0c1d1676f3cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSigmoidCrossEntropyWithLogitsGradient, <a class="el" href="classcaffe2_1_1_weighted_sigmoid_cross_entropy_with_logits_gradient_op.html">WeightedSigmoidCrossEntropyWithLogitsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aceca955ee067384ace9f0c1d1676f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278002796a245b82d2176c6d3af198dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a278002796a245b82d2176c6d3af198dd"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(0))</td></tr>
<tr class="separator:a278002796a245b82d2176c6d3af198dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e47da95b0cd124065dfa39a4aaa991"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30e47da95b0cd124065dfa39a4aaa991"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (2)</td></tr>
<tr class="separator:a30e47da95b0cd124065dfa39a4aaa991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c712ec8feccd09fc63df4d2f9bc03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef6c712ec8feccd09fc63df4d2f9bc03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a vector of probabilities, this operator transforms this into a 2-column
 matrix with complimentary probabilities for binary classification. In explicit
 terms, given the vector X, the output Y is vstack(1 - X, X).
  )DOC&quot;).Input(0</td></tr>
<tr class="separator:aef6c712ec8feccd09fc63df4d2f9bc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7348963c27c26bd5ddce57dc801d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed7348963c27c26bd5ddce57dc801d5"></a>
Input vector of probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;2-column matrix with complimentary probabilities of X for &quot;&quot;binary classification&quot;)</td></tr>
<tr class="separator:a6ed7348963c27c26bd5ddce57dc801d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e54a0c51b6c3ec623174be722722fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e54a0c51b6c3ec623174be722722fbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two matrices logits and targets, of same shape,
(batch_size, num_classes), computes the sigmoid cross entropy between the two.
Returns a tensor of shape (batch_size,) of losses for each example.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a0e54a0c51b6c3ec623174be722722fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66a3b0dcd964d18914db9c5ea190da8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac66a3b0dcd964d18914db9c5ea190da8"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;targets&quot;,&quot;matrix of targets, same shape as logits.&quot;).Output(0</td></tr>
<tr class="separator:ac66a3b0dcd964d18914db9c5ea190da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f8efe40905d6e30a920d6002b0f6eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1f8efe40905d6e30a920d6002b0f6eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given three matrices: logits, targets, weights, all of the same shape,
(batch_size, num_classes), computes the weighted sigmoid cross entropy between
logits and targets. Specifically, at each position r,c, this computes
weights[r, c] * crossentropy(sigmoid(logits[r, c]), targets[r, c]), and then
averages over each row.
Returns a tensor of shape (batch_size,) of losses for each example.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ac1f8efe40905d6e30a920d6002b0f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12cba80072c4e774c5937c17a2688c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa12cba80072c4e774c5937c17a2688c1"></a>
matrix of logits for each example and class matrix of same shape as logits&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;xentropy&quot;,&quot;Vector with the total xentropy for each example.&quot;)</td></tr>
<tr class="separator:aa12cba80072c4e774c5937c17a2688c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3b8b865de49c0da833bddb86fc6e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47a3b8b865de49c0da833bddb86fc6e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MakeTwoClass, <a class="el" href="structcaffe2_1_1_get_make_two_class_gradient.html">GetMakeTwoClassGradient</a>)</td></tr>
<tr class="separator:a47a3b8b865de49c0da833bddb86fc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7429af1d9a8a5bc5bf0eb3c9642248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e7429af1d9a8a5bc5bf0eb3c9642248"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SigmoidCrossEntropyWithLogits, <a class="el" href="structcaffe2_1_1_get_sigmoid_cross_entropy_with_logits_gradient.html">GetSigmoidCrossEntropyWithLogitsGradient</a>)</td></tr>
<tr class="separator:a0e7429af1d9a8a5bc5bf0eb3c9642248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26b537f56129874abbc9a77b8db4662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26b537f56129874abbc9a77b8db4662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (WeightedSigmoidCrossEntropyWithLogits, <a class="el" href="structcaffe2_1_1_get_weighted_sigmoid_cross_entropy_with_logits_gradient.html">GetWeightedSigmoidCrossEntropyWithLogitsGradient</a>)</td></tr>
<tr class="separator:ae26b537f56129874abbc9a77b8db4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c375cd2a4f9d14a61ce1935028f47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af09c375cd2a4f9d14a61ce1935028f47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CrossEntropy, <a class="el" href="classcaffe2_1_1_cross_entropy_op.html">CrossEntropyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af09c375cd2a4f9d14a61ce1935028f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84c43849ee5c2af009b8f64b665020b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac84c43849ee5c2af009b8f64b665020b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CrossEntropyGradient, <a class="el" href="classcaffe2_1_1_cross_entropy_gradient_op.html">CrossEntropyGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac84c43849ee5c2af009b8f64b665020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e02286a5117e48a4778cbde3f2a769f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e02286a5117e48a4778cbde3f2a769f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1_operator.html">Operator</a> computes the cross entropy between the input and the label set. In
 practice, it is most commonly used at the end of models, after the SoftMax
 operator and before the <a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a> operator. Note that CrossEntropy
 assumes that the soft labels provided is a 2D array of size N x D
 (batch size x number of classes). Each entry in the 2D label corresponds to
 the soft label for the input, where each element represents the correct
 probability of the class being selected. As such, each element must be between
 0 and 1, and all elements in an entry must sum to 1. The formula used is:

                Y[i] = sum_j (label[i][j] * log(X[i][j]))

 where (i, j) is the classifier's prediction of the jth class (the correct one),
 and i is the batch size. Each log has a lower limit for numerical stability.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a0e02286a5117e48a4778cbde3f2a769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83144fc9b38a5895eaf15458e5ef170a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83144fc9b38a5895eaf15458e5ef170a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (CrossEntropy, <a class="el" href="classcaffe2_1_1_get_cross_entropy_gradient.html">GetCrossEntropyGradient</a>)</td></tr>
<tr class="separator:a83144fc9b38a5895eaf15458e5ef170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc919c49f725b3492fe44ef3536aa3af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc919c49f725b3492fe44ef3536aa3af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1dataset__ops_1_1_tree_cursor.html">dataset_ops::TreeCursor</a> &gt;)</td></tr>
<tr class="separator:abc919c49f725b3492fe44ef3536aa3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b61e82c723cf3dc8daa4fc5afb9827"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b61e82c723cf3dc8daa4fc5afb9827"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (dataset_ops::TensorVectorPtr&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96b61e82c723cf3dc8daa4fc5afb9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19caef35d3f96aa748efe387890d0985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19caef35d3f96aa748efe387890d0985"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (dataset_ops::SharedTensorVectorPtr)</td></tr>
<tr class="separator:a19caef35d3f96aa748efe387890d0985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af300ffee8007add914d05020c1a4fb1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af300ffee8007add914d05020c1a4fb1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DeformConvGradient).NumInputs(4</td></tr>
<tr class="separator:af300ffee8007add914d05020c1a4fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc270ee9705bfa4ee30f052e337f7350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc270ee9705bfa4ee30f052e337f7350"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (2, 4)</td></tr>
<tr class="separator:acc270ee9705bfa4ee30f052e337f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759c87f7659eb48d10d55307e0434848"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a759c87f7659eb48d10d55307e0434848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquaredL2Distance, <a class="el" href="classcaffe2_1_1_squared_l2_distance_op.html">SquaredL2DistanceOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a759c87f7659eb48d10d55307e0434848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ee1375b1ba85a1cd7a766ea6ae047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193ee1375b1ba85a1cd7a766ea6ae047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquaredL2DistanceGradient, <a class="el" href="classcaffe2_1_1_squared_l2_distance_gradient_op.html">SquaredL2DistanceGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a193ee1375b1ba85a1cd7a766ea6ae047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82136e05b09fbfa006d612ec955fc70d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82136e05b09fbfa006d612ec955fc70d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two input float tensors X, Y, and produces one output float tensor
of the L2 difference between X and Y that is computed as ||(X - Y)^2 / 2||.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a82136e05b09fbfa006d612ec955fc70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea308eb3099e114845e74fe035573d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea308eb3099e114845e74fe035573d05"></a>
or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;Y&quot;,&quot;1D or 2D input tensor (must have the same shape as X)&quot;).Output(0</td></tr>
<tr class="separator:aea308eb3099e114845e74fe035573d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9535174dd8f5bea5c9f4d729a323bd04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9535174dd8f5bea5c9f4d729a323bd04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SquaredL2DistanceGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a9535174dd8f5bea5c9f4d729a323bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58166fd9b119bfdcd330b7ca74bc1f0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58166fd9b119bfdcd330b7ca74bc1f0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SquaredL2Distance, <a class="el" href="classcaffe2_1_1_get_squared_l2_distance_gradient.html">GetSquaredL2DistanceGradient</a>)</td></tr>
<tr class="separator:a58166fd9b119bfdcd330b7ca74bc1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4093899c29097437b6d788a182f4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66d4093899c29097437b6d788a182f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (L1Distance, <a class="el" href="classcaffe2_1_1_l1_distance_op.html">L1DistanceOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a66d4093899c29097437b6d788a182f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7868e35ea4a154b4ef0846da048a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e7868e35ea4a154b4ef0846da048a1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (L1DistanceGradient, <a class="el" href="classcaffe2_1_1_l1_distance_gradient_op.html">L1DistanceGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e7868e35ea4a154b4ef0846da048a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc21a98353546087a9d488e023d3d019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc21a98353546087a9d488e023d3d019"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two input float tensors X, Y, and produces one output float tensor
of the L1 difference between X and Y, computed as L1(x,y) = sum over |x-y|
)DOC&quot;).Input(0</td></tr>
<tr class="separator:acc21a98353546087a9d488e023d3d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dba067dd6ecf88e697a9134cc8f03a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03dba067dd6ecf88e697a9134cc8f03a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (L1DistanceGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a03dba067dd6ecf88e697a9134cc8f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb2394c679844ae159d8b01ce847c6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb2394c679844ae159d8b01ce847c6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (L1Distance, <a class="el" href="classcaffe2_1_1_get_l1_distance_gradient.html">GetL1DistanceGradient</a>)</td></tr>
<tr class="separator:a4eb2394c679844ae159d8b01ce847c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc5be29a915c4fd711df9ec1005176"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4adc5be29a915c4fd711df9ec1005176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProduct, <a class="el" href="classcaffe2_1_1_dot_product_op.html">DotProductOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4adc5be29a915c4fd711df9ec1005176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88847c6a3482af154ce49fa4e5b8708"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa88847c6a3482af154ce49fa4e5b8708"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductGradient, <a class="el" href="classcaffe2_1_1_dot_product_gradient_op.html">DotProductGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa88847c6a3482af154ce49fa4e5b8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bf8ed4609a41ed40f9c6abed0d0bf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31bf8ed4609a41ed40f9c6abed0d0bf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two input float tensors X, Y, and produces one output float tensor
of the dot product between X and Y.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a31bf8ed4609a41ed40f9c6abed0d0bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abb0efe4e8e91bb3f21451535faa3bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6abb0efe4e8e91bb3f21451535faa3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DotProductGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a6abb0efe4e8e91bb3f21451535faa3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5192fbaddd9a460e2984464339f9fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d5192fbaddd9a460e2984464339f9fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DotProduct, <a class="el" href="classcaffe2_1_1_get_dot_product_gradient.html">GetDotProductGradient</a>)</td></tr>
<tr class="separator:a4d5192fbaddd9a460e2984464339f9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4509a408b06d3e69d2764b4223462"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abea4509a408b06d3e69d2764b4223462"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineSimilarity, <a class="el" href="classcaffe2_1_1_cosine_similarity_op.html">CosineSimilarityOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abea4509a408b06d3e69d2764b4223462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5de21b7a7a3425f67a507a140c15c17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5de21b7a7a3425f67a507a140c15c17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineSimilarityGradient, <a class="el" href="classcaffe2_1_1_cosine_similarity_gradient_op.html">CosineSimilarityGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae5de21b7a7a3425f67a507a140c15c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cf830490129391ad795e2d408ef391"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51cf830490129391ad795e2d408ef391"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two input float tensors X, Y, and produces one output float tensor
of the cosine similarity between X and Y.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a51cf830490129391ad795e2d408ef391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e95453ffd4f09215d3d7b74b3c9ecfe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e95453ffd4f09215d3d7b74b3c9ecfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CosineSimilarityGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a8e95453ffd4f09215d3d7b74b3c9ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c057b06a1c2bf40ad0ca6b9e0a03ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c057b06a1c2bf40ad0ca6b9e0a03ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (CosineSimilarity, <a class="el" href="classcaffe2_1_1_get_cosine_similarity_gradient.html">GetCosineSimilarityGradient</a>)</td></tr>
<tr class="separator:a46c057b06a1c2bf40ad0ca6b9e0a03ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1efc8b1c93d426c7a5db470afbe3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77b1efc8b1c93d426c7a5db470afbe3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductWithPadding, <a class="el" href="classcaffe2_1_1_dot_product_with_padding_op.html">DotProductWithPaddingOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a77b1efc8b1c93d426c7a5db470afbe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3a56d9650d88c824460e5458bf063"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61e3a56d9650d88c824460e5458bf063"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductWithPaddingGradient, <a class="el" href="classcaffe2_1_1_dot_product_with_padding_gradient_op.html">DotProductWithPaddingGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a61e3a56d9650d88c824460e5458bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdbb01665a04f6bfc9aeca0d67452f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cdbb01665a04f6bfc9aeca0d67452f6"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (using pad_value) to the same shape as the other one.2) replicate the smaller tensor to the same shape as the other one.Note the first dimension of X</td></tr>
<tr class="separator:a1cdbb01665a04f6bfc9aeca0d67452f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5978f310e365d165d09a177968fe6cbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5978f310e365d165d09a177968fe6cbd"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;1D or 2D input tensor&quot;).Input(1</td></tr>
<tr class="separator:a5978f310e365d165d09a177968fe6cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0834b37715cc0792963bea40709636c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0834b37715cc0792963bea40709636c"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Z&quot;,&quot;1D output tensor&quot;).IdenticalTypeAndShapeOfInputDim(0</td></tr>
<tr class="separator:ac0834b37715cc0792963bea40709636c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517526992ab52ba7b03a788f13a77e03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517526992ab52ba7b03a788f13a77e03"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;pad_value&quot;,&quot;the padding value for tensors with smaller dimension&quot;).Arg(&quot;replicate&quot;</td></tr>
<tr class="separator:a517526992ab52ba7b03a788f13a77e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57062b2d63a516028d03c3aa970c564"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab57062b2d63a516028d03c3aa970c564"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DotProductWithPaddingGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:ab57062b2d63a516028d03c3aa970c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afece1925a65deee851a9905ba4ef0eda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afece1925a65deee851a9905ba4ef0eda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DotProductWithPadding, <a class="el" href="classcaffe2_1_1_get_dot_product_with_padding_gradient.html">GetDotProductWithPaddingGradient</a>)</td></tr>
<tr class="separator:afece1925a65deee851a9905ba4ef0eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120c315e80b7dd994deb27c6de2731f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a120c315e80b7dd994deb27c6de2731f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Do, <a class="el" href="classcaffe2_1_1_do_op.html">DoOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a120c315e80b7dd994deb27c6de2731f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c07db97daf382528ab784ac1c650715"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c07db97daf382528ab784ac1c650715"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'Do' control operator, executes a subnet in a separate workspace.
Last blobs in the input and output lists should be the same blob created with
CreateScope op. Arguments 'inner_blobs' and 'outer_blobs_idx' provide a mapping
between selected inner blob names and corresponding outer blob indices.
    )DOC&quot;).Arg(&quot;net&quot;</td></tr>
<tr class="separator:a0c07db97daf382528ab784ac1c650715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139f31d457029fdf5bf87beec6af448b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a139f31d457029fdf5bf87beec6af448b"></a>
INT_MAX Subnet with blob bindings&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;inner_blobs&quot;,&quot;List of inner net blob names to bind to outer workspace&quot;).Arg(&quot;outer_blobs_idx&quot;</td></tr>
<tr class="separator:a139f31d457029fdf5bf87beec6af448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9918233cb5a585cbc9c9cfd7ecd7975"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9918233cb5a585cbc9c9cfd7ecd7975"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in&#160;</td><td class="memItemRight" valign="bottom"><b>operator outputs</b> (skipping workspace blobs)&quot;) .Arg( &quot;saved_fwd_blobs&quot;</td></tr>
<tr class="separator:ab9918233cb5a585cbc9c9cfd7ecd7975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61023ad7af7d38a277e79cce170b557b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61023ad7af7d38a277e79cce170b557b"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in List of blobs from the forward Do&#160;</td><td class="memItemRight" valign="bottom"><b>operator workspace needed&quot; &quot;in backward pass, used in gradient Do operator&quot;) .Arg</b> (&quot;reuse_workspace&quot;,&quot;Whether to reuse workspace or create a new one in a given scope&quot;).AllowInplace([](int in</td></tr>
<tr class="separator:a61023ad7af7d38a277e79cce170b557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9aec77b9877ad602837148d5dff1f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c9aec77b9877ad602837148d5dff1f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Do, <a class="el" href="classcaffe2_1_1_do_op.html">DoOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c9aec77b9877ad602837148d5dff1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dff897b9581cf290790faf38553b148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dff897b9581cf290790faf38553b148"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Dropout, <a class="el" href="classcaffe2_1_1_dropout_op.html">DropoutOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3dff897b9581cf290790faf38553b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d67348de5ef8c9e1af86d93b2e6082d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d67348de5ef8c9e1af86d93b2e6082d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DropoutGrad, <a class="el" href="classcaffe2_1_1_dropout_gradient_op.html">DropoutGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9d67348de5ef8c9e1af86d93b2e6082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47bbba2215f2ce01d7f939389aab0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af47bbba2215f2ce01d7f939389aab0e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{0, 0}}).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:af47bbba2215f2ce01d7f939389aab0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64da77f03415ef24ee195f5be6d620"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c64da77f03415ef24ee195f5be6d620"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (output_mask)</td></tr>
<tr class="separator:a1c64da77f03415ef24ee195f5be6d620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fca59acd632ffd8dcb407a062f8a0ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fca59acd632ffd8dcb407a062f8a0ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Dropout takes one input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) and produces two <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> outputs,
output (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) and mask (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;bool&gt;). Depending on whether it is in
test mode or not, the output Y will either be a random dropout, or a simple
copy of the input. Note that our implementation of Dropout does scaling in
the training phase, so during testing nothing needs to be done.
)DOC&quot;).Arg(&quot;ratio&quot;</td></tr>
<tr class="separator:a7fca59acd632ffd8dcb407a062f8a0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8812b5ac202e7db5440e625b292085a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8812b5ac202e7db5440e625b292085a7"></a>
default the ratio of random dropout&#160;</td><td class="memItemRight" valign="bottom"><b>ArgIsTest</b> (&quot;(int) if nonzero, run dropout in test mode where &quot;&quot;the output is simply Y = X.&quot;).Input(0</td></tr>
<tr class="separator:a8812b5ac202e7db5440e625b292085a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8288bc3130de889a68b2b6886860871"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8288bc3130de889a68b2b6886860871"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;The output.&quot;).Output(1</td></tr>
<tr class="separator:ab8288bc3130de889a68b2b6886860871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee809be80b8cc87ce4358d03159b43a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee809be80b8cc87ce4358d03159b43a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Dropout, <a class="el" href="classcaffe2_1_1_get_dropout_gradient.html">GetDropoutGradient</a>)</td></tr>
<tr class="separator:a8ee809be80b8cc87ce4358d03159b43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08266a632d16a9c19ce4eec524697fd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08266a632d16a9c19ce4eec524697fd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Add, EIGEN_ADD, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a08266a632d16a9c19ce4eec524697fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca95477b66cf6b1cf8b137f34762a1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca95477b66cf6b1cf8b137f34762a1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Div, EIGEN_DIV, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a4ca95477b66cf6b1cf8b137f34762a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf1b7759200e47780e2de5f59fe5a34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf1b7759200e47780e2de5f59fe5a34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ElementWiseDivide</b> (<a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &amp;, const int n, float *dXdata, float *dYdata, const float *dZdata, const float *Ydata, const float *Zdata)</td></tr>
<tr class="separator:abcf1b7759200e47780e2de5f59fe5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b33b4d71f254adc7d15d2d7c09514"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a462b33b4d71f254adc7d15d2d7c09514"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DivGradient, <a class="el" href="classcaffe2_1_1_div_gradient_op.html">DivGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a462b33b4d71f254adc7d15d2d7c09514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4696f995a2d3eda5ff8ae4ae89f967c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4696f995a2d3eda5ff8ae4ae89f967c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ElementwiseLinear, <a class="el" href="classcaffe2_1_1_elementwise_linear_op.html">ElementwiseLinearOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af4696f995a2d3eda5ff8ae4ae89f967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825114a76adc85d79bd206213e1c002a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a825114a76adc85d79bd206213e1c002a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ElementwiseLinearGradient, <a class="el" href="classcaffe2_1_1_elementwise_linear_gradient_op.html">ElementwiseLinearGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a825114a76adc85d79bd206213e1c002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6403d8b36158e391f210532d5073efbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6403d8b36158e391f210532d5073efbd"></a>
w of size D and b of size the op computes Y of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (N X D) where Y_</td></tr>
<tr class="separator:a6403d8b36158e391f210532d5073efbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36cb19298d392bfba498e3ea64f14c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab36cb19298d392bfba498e3ea64f14c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ElementwiseLinear, <a class="el" href="structcaffe2_1_1_get_elementwise_linear_gradient.html">GetElementwiseLinearGradient</a>)</td></tr>
<tr class="separator:ab36cb19298d392bfba498e3ea64f14c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df433e2a83d5a74d214fc368b119913"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4df433e2a83d5a74d214fc368b119913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Mul, EIGEN_MUL, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a4df433e2a83d5a74d214fc368b119913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b38a8404e0a91adb094c1c576cb07ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b38a8404e0a91adb094c1c576cb07ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (LT, NAIVE_LT, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2b38a8404e0a91adb094c1c576cb07ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1b9e96395352e08546470f6076511b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e1b9e96395352e08546470f6076511b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (LE, NAIVE_LE, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2e1b9e96395352e08546470f6076511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4430967dd5b8a4cf6ec69fdce51f2d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4430967dd5b8a4cf6ec69fdce51f2d11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (GT, NAIVE_GT, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a4430967dd5b8a4cf6ec69fdce51f2d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4df4003709084e82e33367d6e3e35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb4df4003709084e82e33367d6e3e35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (GE, NAIVE_GE, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2fb4df4003709084e82e33367d6e3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b958eacb0cd2e7d44d4e3b6f11751f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b958eacb0cd2e7d44d4e3b6f11751f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (EQ, NAIVE_EQ, <a class="el" href="structcaffe2_1_1_tensor_types.html">IntBoolTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a5b958eacb0cd2e7d44d4e3b6f11751f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9245c10717ae88926a31aa7fe1d2b256"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9245c10717ae88926a31aa7fe1d2b256"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (And, NAIVE_AND, <a class="el" href="structcaffe2_1_1_tensor_types.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a9245c10717ae88926a31aa7fe1d2b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae033c619860e02091bb52d14a14c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ae033c619860e02091bb52d14a14c81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (Or, NAIVE_OR, <a class="el" href="structcaffe2_1_1_tensor_types.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a6ae033c619860e02091bb52d14a14c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe1db1548b22bf37d5e7c738d2c7817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe1db1548b22bf37d5e7c738d2c7817"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (Xor, NAIVE_XOR, <a class="el" href="structcaffe2_1_1_tensor_types.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1_fixed_type.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a8fe1db1548b22bf37d5e7c738d2c7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d86e3060f692b7242a0a7ba8d2ac4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67d86e3060f692b7242a0a7ba8d2ac4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Not, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">BoolTypes</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_not_functor.html">NotFunctor</a> &gt;)</td></tr>
<tr class="separator:a67d86e3060f692b7242a0a7ba8d2ac4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5090bd618e12592070b3ac536c5a052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5090bd618e12592070b3ac536c5a052"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumReduceLike, <a class="el" href="classcaffe2_1_1_sum_reduce_like_op.html">SumReduceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad5090bd618e12592070b3ac536c5a052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc070707141ec0d42d8f9e84505d42b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc070707141ec0d42d8f9e84505d42b4"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:acc070707141ec0d42d8f9e84505d42b4"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculate_broadcast_sizes</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;A, const <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;B, int axis)</td></tr>
<tr class="separator:acc070707141ec0d42d8f9e84505d42b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad0d3b54b10f1c66809f96fb596dbf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ad0d3b54b10f1c66809f96fb596dbf0"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MathDocGenerator</b> (const char *name)</td></tr>
<tr class="separator:a3ad0d3b54b10f1c66809f96fb596dbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7943e389460d0a5de99e9fa3df03ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7943e389460d0a5de99e9fa3df03ba1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (PointwiseCostInference&lt; 1 &gt;).IdenticalTypeAndShapeOfInput(0).FillUsing(MathDocGenerator(&quot;addition&quot;))</td></tr>
<tr class="separator:ac7943e389460d0a5de99e9fa3df03ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8002be33493bd612317dc56891e973c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8002be33493bd612317dc56891e973c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DivGradient).NumInputs(3).NumOutputs(2).AllowInplace(</td></tr>
<tr class="separator:ad8002be33493bd612317dc56891e973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3338f28d9f20274ff81e6356759decd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3338f28d9f20274ff81e6356759decd1"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (B)</td></tr>
<tr class="separator:a3338f28d9f20274ff81e6356759decd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf4918b3309dec0d3e0f99e4913e84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3bf4918b3309dec0d3e0f99e4913e84"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are i e B is a scalar&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (A)</td></tr>
<tr class="separator:ab3bf4918b3309dec0d3e0f99e4913e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d4fcefc7b43ff7e90d369132d32ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d4fcefc7b43ff7e90d369132d32ec5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Sub, EIGEN_SUB, <a class="el" href="structcaffe2_1_1_tensor_types.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a50d4fcefc7b43ff7e90d369132d32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b718bd1d99ccaa1b0629a7f1fc6d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9b718bd1d99ccaa1b0629a7f1fc6d00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sum, <a class="el" href="classcaffe2_1_1_sum_op.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad9b718bd1d99ccaa1b0629a7f1fc6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1f5fb42a66bc0f72de579b62a4db1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b1f5fb42a66bc0f72de579b62a4db1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (CostInferenceForSum).InputsCanCrossDevices().IdenticalTypeAndShapeOfInput(0).SetDoc(R&quot;DOC( Element-wise sum of each of the input tensors. The first input tensor can be used in-place as the output tensor</td></tr>
<tr class="separator:a1b1f5fb42a66bc0f72de579b62a4db1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0736265c39a007dae621ea822110cb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0736265c39a007dae621ea822110cb8"></a>
in which case the sum will be done in place and results will be accumulated in input0 All inputs and outputs must have the same shape and data type DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;data_0&quot;,&quot;First of the input tensors. Can be inplace.&quot;).Output(0</td></tr>
<tr class="separator:aa0736265c39a007dae621ea822110cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac035f1485229df6b767b358832c9eaf6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac035f1485229df6b767b358832c9eaf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Elu, <a class="el" href="classcaffe2_1_1_elu_op.html">EluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac035f1485229df6b767b358832c9eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b561e1908f4d07c8a0941188ea8b247"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b561e1908f4d07c8a0941188ea8b247"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EluGradient, <a class="el" href="classcaffe2_1_1_elu_gradient_op.html">EluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7b561e1908f4d07c8a0941188ea8b247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f9360aa815be2d797761c5a368c53a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f9360aa815be2d797761c5a368c53a"></a>
is applied to the tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;1D input tensor&quot;).Output(0</td></tr>
<tr class="separator:a54f9360aa815be2d797761c5a368c53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a020534a53773fbacf5c7fcb25f01c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a020534a53773fbacf5c7fcb25f01c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
EluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the rectified linear function.
)DOC&quot;)</td></tr>
<tr class="separator:a3a020534a53773fbacf5c7fcb25f01c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106f7d276074072026f82fe975e1e121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a106f7d276074072026f82fe975e1e121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Elu, <a class="el" href="classcaffe2_1_1_get_elu_gradient.html">GetEluGradient</a>)</td></tr>
<tr class="separator:a106f7d276074072026f82fe975e1e121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35898418acaa09e9592059b9069c46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab35898418acaa09e9592059b9069c46d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Exp, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_exp_c_p_u_functor.html">ExpCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:ab35898418acaa09e9592059b9069c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace21a98aaf448ca86e2f57c4467765e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace21a98aaf448ca86e2f57c4467765e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Exp, <a class="el" href="classcaffe2_1_1_get_exp_gradient.html">GetExpGradient</a>)</td></tr>
<tr class="separator:ace21a98aaf448ca86e2f57c4467765e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a639f59d659fed5f5788ff8d2444070"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a639f59d659fed5f5788ff8d2444070"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ExpandDims, <a class="el" href="classcaffe2_1_1_expand_dims_op.html">ExpandDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a639f59d659fed5f5788ff8d2444070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df341a5f4674d17842a1b3e77366edd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1df341a5f4674d17842a1b3e77366edd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Squeeze, <a class="el" href="classcaffe2_1_1_squeeze_op.html">SqueezeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1df341a5f4674d17842a1b3e77366edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba59d71a2866cf00221aa492aab9bce8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba59d71a2866cf00221aa492aab9bce8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);auto dims=helper.template GetRepeatedArgument&lt; int &gt;(&quot;dims&quot;);auto originalSize=dims.size();CAFFE_ENFORCE(originalSize &gt; 0,&quot;Parameter `dims` must be provided.&quot;);std::sort(dims.begin(), dims.end());dims.erase(std::unique(dims.begin(), dims.end()), dims.end());if(dims.size()&lt; originalSize){LOG(WARNING)&lt;&lt; &quot;Parameter `dims` has repeated dimensions.&quot;;}CAFFE_ENFORCE(dims.front() &gt;=0,&quot;Dimension ids must be non-negative.&quot;);CAFFE_ENFORCE_GE(in[0].dims_size()+dims.size(), dims.back()+1,&quot;Input needs at least &quot;,(1+dims.back()-dims.size()),&quot; dimensions given `dims`.&quot;);vector&lt; TensorShape &gt; out(1);int cur_pos=0;int idx=0;for(const auto new_dim:dims){for(int i=cur_pos;i&lt; new_dim;i++){out[0].add_dims(in[0].dims(idx++));}out[0].add_dims(1);cur_pos=new_dim+1;}for(;idx&lt; in[0].dims_size();idx++){out[0].add_dims(in[0].dims(idx));}out[0].set_data_type(in[0].data_type());return out;}).SetDoc(R&quot;DOC( Insert single-dimensional entries to the shape of a tensor. Takes one required argument `dims`</td></tr>
<tr class="separator:aba59d71a2866cf00221aa492aab9bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b27586c43651c1c73785db21657ddfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b27586c43651c1c73785db21657ddfc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Squeeze, <a class="el" href="classcaffe2_1_1_squeeze_op.html">SqueezeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0b27586c43651c1c73785db21657ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba9712992902de52a0c864a424d4a93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ba9712992902de52a0c864a424d4a93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ExpandDims, <a class="el" href="classcaffe2_1_1_expand_dims_op.html">ExpandDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3ba9712992902de52a0c864a424d4a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b6dc5a6a52e2c93b44713b7133578d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b6dc5a6a52e2c93b44713b7133578d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FeedBlob, <a class="el" href="classcaffe2_1_1_feed_blob_op.html">FeedBlobOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa9b6dc5a6a52e2c93b44713b7133578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351e03fb859b3632d11f62ad1d8950c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8351e03fb859b3632d11f62ad1d8950c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (FeedBlob)</td></tr>
<tr class="separator:a8351e03fb859b3632d11f62ad1d8950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4dfd4bf8a7ea0f46944463a766650"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72a4dfd4bf8a7ea0f46944463a766650"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, 0).NumOutputs(1</td></tr>
<tr class="separator:a72a4dfd4bf8a7ea0f46944463a766650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340fab007e3db9818f9b88d2bb195134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a340fab007e3db9818f9b88d2bb195134"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
FeedBlobs the content of the blobs. The input and output blobs should be
one-to-one inplace.)DOC&quot;).Arg(&quot;value&quot;</td></tr>
<tr class="separator:a340fab007e3db9818f9b88d2bb195134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f639e28601da3c07ac8e237b3572c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27f639e28601da3c07ac8e237b3572c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniformFill, <a class="el" href="classcaffe2_1_1_uniform_fill_op.html">UniformFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a27f639e28601da3c07ac8e237b3572c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1974816c7e4b3740e96cc2f940a90af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1974816c7e4b3740e96cc2f940a90af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniformIntFill, <a class="el" href="classcaffe2_1_1_uniform_fill_op.html">UniformFillOp</a>&lt; int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa1974816c7e4b3740e96cc2f940a90af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81b63ebab12452f6f8e8d57980dd1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac81b63ebab12452f6f8e8d57980dd1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniqueUniformFill, <a class="el" href="classcaffe2_1_1_unique_uniform_fill_op.html">UniqueUniformFillOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aac81b63ebab12452f6f8e8d57980dd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e9f65068d0fcb55d3699c00559e46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a1e9f65068d0fcb55d3699c00559e46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConstantFill, <a class="el" href="classcaffe2_1_1_constant_fill_op.html">ConstantFillOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a1e9f65068d0fcb55d3699c00559e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210f156a8503d60d2a32394a8656458b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a210f156a8503d60d2a32394a8656458b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DiagonalFill, <a class="el" href="classcaffe2_1_1_diagonal_fill_op.html">DiagonalFillOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a210f156a8503d60d2a32394a8656458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5041564a2c1bb5307576f93e6b2ee2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5041564a2c1bb5307576f93e6b2ee2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GaussianFill, <a class="el" href="classcaffe2_1_1_gaussian_fill_op.html">GaussianFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af5041564a2c1bb5307576f93e6b2ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c5c69d3eff8b8997ddd2d0321db30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af52c5c69d3eff8b8997ddd2d0321db30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (XavierFill, <a class="el" href="classcaffe2_1_1_xavier_fill_op.html">XavierFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af52c5c69d3eff8b8997ddd2d0321db30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a118c7c04bd6a44970b938c397c18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa8a118c7c04bd6a44970b938c397c18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MSRAFill, <a class="el" href="classcaffe2_1_1_m_s_r_a_fill_op.html">MSRAFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afa8a118c7c04bd6a44970b938c397c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212da7c76bc28aaf943d4814799b0c83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a212da7c76bc28aaf943d4814799b0c83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RangeFill, <a class="el" href="classcaffe2_1_1_range_fill_op.html">RangeFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a212da7c76bc28aaf943d4814799b0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a85b6d6e73a4c5ed6acdf7c5d81357f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a85b6d6e73a4c5ed6acdf7c5d81357f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsRangeFill, <a class="el" href="classcaffe2_1_1_lengths_range_fill_op.html">LengthsRangeFillOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a85b6d6e73a4c5ed6acdf7c5d81357f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316c5b1fcc8a0b071075c5671e775150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a316c5b1fcc8a0b071075c5671e775150"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt;&gt;).SetDoc(R&quot;DOC( The operator fills the elements of the output tensor with a const ant value specified by the 'value' argument. The data type is specified by the 'dtype' argument. The 'dtype' argument must be one of the data types specified in the 'DataType' enum field in the TensorProto message. If the 'dtype' argument is not provided</td></tr>
<tr class="separator:a316c5b1fcc8a0b071075c5671e775150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affef2c8d5e428a73b191483d03642ab2"><td class="memTemplParams" colspan="2"><a class="anchor" id="affef2c8d5e428a73b191483d03642ab2"></a>
template&lt;int VALUE_TYPE = TensorProto_DataType_FLOAT&gt; </td></tr>
<tr class="memitem:affef2c8d5e428a73b191483d03642ab2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TensorShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FillerTensorInference</b> (const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in)</td></tr>
<tr class="separator:affef2c8d5e428a73b191483d03642ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b470ebd6dde07075fd1869ac2d0e6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b470ebd6dde07075fd1869ac2d0e6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LengthsRangeFill, <a class="el" href="classcaffe2_1_1_g_p_u_fallback_op.html">GPUFallbackOp</a>&lt; <a class="el" href="classcaffe2_1_1_lengths_range_fill_op.html">LengthsRangeFillOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&gt;)</td></tr>
<tr class="separator:a97b470ebd6dde07075fd1869ac2d0e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a696b96099f051dc3ea125aa64e04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07a696b96099f051dc3ea125aa64e04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b> (integers)&quot;) .Input(1</td></tr>
<tr class="separator:ab07a696b96099f051dc3ea125aa64e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776e20a70e6f034b0ab99c8cbb0e440d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776e20a70e6f034b0ab99c8cbb0e440d"></a>
Needles query&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;query_indices&quot;,&quot;Indices of the needles in index or 'missing value'&quot;).Arg(&quot;missing_value&quot;</td></tr>
<tr class="separator:a776e20a70e6f034b0ab99c8cbb0e440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f8acbf738bbcfb85fa22285b787061"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2f8acbf738bbcfb85fa22285b787061"></a>
Needles query Placeholder for items that are not found&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Finds elements of second input from first input,
outputting the last (max) index for each query.
If query not find, inserts missing_value.
See IndexGet() for a version that modifies the index when
values are not found.
)DOC&quot;)</td></tr>
<tr class="separator:af2f8acbf738bbcfb85fa22285b787061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1755f5007b5525661e297ac95b85289d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1755f5007b5525661e297ac95b85289d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Flatten, <a class="el" href="classcaffe2_1_1_flatten_op.html">FlattenOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1755f5007b5525661e297ac95b85289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c03a72626c14843c248829f802c50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab04c03a72626c14843c248829f802c50"></a>
vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> (1)</td></tr>
<tr class="separator:ab04c03a72626c14843c248829f802c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d2286b733ab4f0e2dbe71074ce3985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d2286b733ab4f0e2dbe71074ce3985"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (auto d:in[0].dims())</td></tr>
<tr class="separator:a32d2286b733ab4f0e2dbe71074ce3985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa42a78dbd98b1b5fa034551023585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2aa42a78dbd98b1b5fa034551023585"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (in[0].data_type())</td></tr>
<tr class="separator:aa2aa42a78dbd98b1b5fa034551023585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc9398efbdd3a1d463a3fa45cb40822"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cc9398efbdd3a1d463a3fa45cb40822"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (outer)</td></tr>
<tr class="separator:a5cc9398efbdd3a1d463a3fa45cb40822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d44cd34c5d3a5f045f3c0090649642e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d44cd34c5d3a5f045f3c0090649642e"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (inner)</td></tr>
<tr class="separator:a8d44cd34c5d3a5f045f3c0090649642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0dada077138062df05f0b854d16140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e0dada077138062df05f0b854d16140"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Flattens the input tensor into a 2D matrix. If input tensor has shape
(d_0, d_1, ... d_n) then the output will have shape
(d_0 X d_1 ... d_(axis-1), d_axis X d_(axis+1) ... X dn)
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a2e0dada077138062df05f0b854d16140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e792f937b10fe38af868a7ad041dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f0e792f937b10fe38af868a7ad041dd"></a>
A tensor of with input dimensions up to axis flattened to the outer dimension of the output and remaining input dimensions flattened into the inner dimension of the output&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis&quot;,&quot;(Default to 1) Indicate up to which input dimensions &quot;&quot;(exclusive) should be flattened to the outer dimension of the output&quot;)</td></tr>
<tr class="separator:a7f0e792f937b10fe38af868a7ad041dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384df3668505f76c85f552b02187ca33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384df3668505f76c85f552b02187ca33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Flatten, <a class="el" href="classcaffe2_1_1_get_flatten_gradient.html">GetFlattenGradient</a>)</td></tr>
<tr class="separator:a384df3668505f76c85f552b02187ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcd71de627b3a4c418c6ee15896cb72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fcd71de627b3a4c418c6ee15896cb72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlexibleTopK, <a class="el" href="classcaffe2_1_1_flexible_top_k_op.html">FlexibleTopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2fcd71de627b3a4c418c6ee15896cb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f774a585fae067302931bb7c00542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a381f774a585fae067302931bb7c00542"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlexibleTopKGradient, <a class="el" href="classcaffe2_1_1_flexible_top_k_gradient_op.html">FlexibleTopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a381f774a585fae067302931bb7c00542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28839e5aacd40cdf93789551f87c1f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae28839e5aacd40cdf93789551f87c1f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Floor, <a class="el" href="classcaffe2_1_1_floor_op.html">FloorOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae28839e5aacd40cdf93789551f87c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95bafafbf0932a5b70cb497e8892af3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95bafafbf0932a5b70cb497e8892af3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Floor takes one input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) and produces one output data
(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) where the floor function, y = floor(x), is applied to
the tensor elementwise. Currently supports only float32.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ae95bafafbf0932a5b70cb497e8892af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062dec729017bbf1bfb05a496e0b73cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062dec729017bbf1bfb05a496e0b73cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GRADIENT_NOT_IMPLEMENTED_YET</b> (Floor)</td></tr>
<tr class="separator:a062dec729017bbf1bfb05a496e0b73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44a6fcfc0ff135335e8fbe29ce87b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace44a6fcfc0ff135335e8fbe29ce87b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Free, <a class="el" href="classcaffe2_1_1_free_op.html">FreeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ace44a6fcfc0ff135335e8fbe29ce87b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069d91af285b8d6101007750937f5512"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a069d91af285b8d6101007750937f5512"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Free)</td></tr>
<tr class="separator:a069d91af285b8d6101007750937f5512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b40bfc2fcecb522a8a90bbd063df1dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b40bfc2fcecb522a8a90bbd063df1dc"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SameNumberOfOutput</b> ().EnforceOneToOneInplace().SetDoc(R&quot;DOC( Frees the content of the blobs. The input and output blobs should be one-to-one inplace.)DOC&quot;)</td></tr>
<tr class="separator:a0b40bfc2fcecb522a8a90bbd063df1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f9797224aef8884a1cb233c0ffbe82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4f9797224aef8884a1cb233c0ffbe82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Free, <a class="el" href="classcaffe2_1_1_free_op.html">FreeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad4f9797224aef8884a1cb233c0ffbe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc120235d53fe0a733a44a98b42ab17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc120235d53fe0a733a44a98b42ab17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FC, <a class="el" href="classcaffe2_1_1_fully_connected_op.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3dc120235d53fe0a733a44a98b42ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548c644916d6d2a1aae045a4d8720d7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a548c644916d6d2a1aae045a4d8720d7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCGradient, <a class="el" href="classcaffe2_1_1_fully_connected_gradient_op.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a548c644916d6d2a1aae045a4d8720d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71d158abf61ab81c2b0c5543a1be3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af71d158abf61ab81c2b0c5543a1be3f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCTransposed, <a class="el" href="classcaffe2_1_1_fully_connected_op.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_default_engine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:af71d158abf61ab81c2b0c5543a1be3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcc29c8cb9abc1567af87e71bd9bf24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dcc29c8cb9abc1567af87e71bd9bf24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCTransposedGradient, <a class="el" href="classcaffe2_1_1_fully_connected_gradient_op.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_default_engine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:a7dcc29c8cb9abc1567af87e71bd9bf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fd2849ba80cbe030fec3b47959b6d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92fd2849ba80cbe030fec3b47959b6d4"></a>
NumInputs(3).NumOutputs(1).TensorInferenceFunction(std NumInputs(3).NumOutputs(1).TensorInferenceFunction(std&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCGradient).NumInputs(3).NumOutputs(2</td></tr>
<tr class="separator:a92fd2849ba80cbe030fec3b47959b6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d868b7bb06d1711ba171ab35f04de88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d868b7bb06d1711ba171ab35f04de88"></a>
NumInputs(3).NumOutputs(1).TensorInferenceFunction(std NumInputs(3).NumOutputs(1).TensorInferenceFunction(std&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCTransposedGradient).NumInputs(3).NumOutputs(2</td></tr>
<tr class="separator:a8d868b7bb06d1711ba171ab35f04de88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44555fbef3acb1dfc26cfdc9037b74be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44555fbef3acb1dfc26cfdc9037b74be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FC, <a class="el" href="classcaffe2_1_1_fully_connected_op.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a44555fbef3acb1dfc26cfdc9037b74be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc15980ac98f61c26ba6772cb26f1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21cc15980ac98f61c26ba6772cb26f1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCGradient, <a class="el" href="classcaffe2_1_1_fully_connected_gradient_op.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a21cc15980ac98f61c26ba6772cb26f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4aa7282aa4ed23e9f10a6ae3f021345"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4aa7282aa4ed23e9f10a6ae3f021345"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCTransposed, <a class="el" href="classcaffe2_1_1_fully_connected_op.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_default_engine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:ad4aa7282aa4ed23e9f10a6ae3f021345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7cc869429fbba5869a831a6bc177a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c7cc869429fbba5869a831a6bc177a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCTransposedGradient, <a class="el" href="classcaffe2_1_1_fully_connected_gradient_op.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_default_engine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:a9c7cc869429fbba5869a831a6bc177a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f8c0b657005eb2d0e6ab4a34b7fd16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59f8c0b657005eb2d0e6ab4a34b7fd16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FloatToFused8BitRowwiseQuantized, <a class="el" href="classcaffe2_1_1_float_to_fused8_bit_rowwise_quantized_op.html">FloatToFused8BitRowwiseQuantizedOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a59f8c0b657005eb2d0e6ab4a34b7fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ec579b7635293a32bdc3d119f50e1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6ec579b7635293a32bdc3d119f50e1d"></a>
and then scaling each element to an bit number between and To later de quantize the&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b> (range/255) and offset(bias) are stored alongside the data.More precisely</td></tr>
<tr class="separator:af6ec579b7635293a32bdc3d119f50e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab117d19c549b5a63339f8665a5934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fab117d19c549b5a63339f8665a5934"></a>
and then scaling each element to an bit number between and To later de quantize the the first bytes of each row in the output matrix are a bit float storing the the next bytes store the bias as a bit and all remaining bytes in the row encode single quantized values DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;input&quot;,&quot;Float32 input data&quot;).Output(0</td></tr>
<tr class="separator:a1fab117d19c549b5a63339f8665a5934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010084a6ee5b808fd7a27fb58b72cb6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a010084a6ee5b808fd7a27fb58b72cb6a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (FloatToFused8BitRowwiseQuantized)</td></tr>
<tr class="separator:a010084a6ee5b808fd7a27fb58b72cb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a656421d800b4418bd6e118c9ec7245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a656421d800b4418bd6e118c9ec7245"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Fused8BitRowwiseQuantizedToFloat, <a class="el" href="classcaffe2_1_1_fused8_bit_rowwise_quantized_to_float_op.html">Fused8BitRowwiseQuantizedToFloatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0a656421d800b4418bd6e118c9ec7245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ed90c60adac7cd45f8dd558ef9d896"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96ed90c60adac7cd45f8dd558ef9d896"></a>
followed by the bias as a bit float in the next and the quantized values in the preceding bytes of the row The output is a matrix containing only the but de quantized De quantization is performed by multiplying each value by its row s scale and bias parameters The de quantized values will thus not be exactly equal to the un quantized floating <a class="el" href="structpoint.html">point</a> values DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;scale_bias_quantized_input&quot;,&quot;Fused scale, bias and quantized data&quot;).Output(0</td></tr>
<tr class="separator:a96ed90c60adac7cd45f8dd558ef9d896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052dfa230a77350a00706311fea6754"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8052dfa230a77350a00706311fea6754"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Fused8BitRowwiseQuantizedToFloat)</td></tr>
<tr class="separator:a8052dfa230a77350a00706311fea6754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a40c8ce51b9de6c5ad61dc047b829e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a40c8ce51b9de6c5ad61dc047b829e6"></a>
but operating on bit rowwise quantized matrices with fused&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b> (where each row stores quantized values, and then the scale and offset).DATA needs to have rank 2 and INDICES needs to have rank 1.) DOC&quot;) .Input( 0</td></tr>
<tr class="separator:a1a40c8ce51b9de6c5ad61dc047b829e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8d016e6881e2c8aba2c83145db0608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf8d016e6881e2c8aba2c83145db0608"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor with rank obtained with&#160;</td><td class="memItemRight" valign="bottom"><b>operator FloatToFused8BitRowwiseQuantized&quot;) .Input</b> (1,&quot;INDICES&quot;,&quot;Integer vector containing indices of the first dimension of DATA for&quot;&quot;the rows that are being gathered&quot;).Output(0</td></tr>
<tr class="separator:abf8d016e6881e2c8aba2c83145db0608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e5fb4372ed6660a3a98ea0690043ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e5fb4372ed6660a3a98ea0690043ff"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor with rank obtained with output&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){vector&lt; TensorShape &gt; out(1);for(auto d:in[1].dims()){out[0].add_dims(d);}for(int i=1;i&lt; in[0].dims_size();++i){out[0].add_dims(in[0].dims(i));}out[0].set_data_type(in[0].data_type());return out;})</td></tr>
<tr class="separator:af7e5fb4372ed6660a3a98ea0690043ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60efa88d8e5c2b93818ae8da725a4db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac60efa88d8e5c2b93818ae8da725a4db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GatherFused8BitRowwise, <a class="el" href="classcaffe2_1_1_gather_fused8_bit_rowwise_op.html">GatherFused8BitRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac60efa88d8e5c2b93818ae8da725a4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f785a1ae552fd2ae17d62a2820a585d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f785a1ae552fd2ae17d62a2820a585d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorFill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7f785a1ae552fd2ae17d62a2820a585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a228f3cb8714bb1747b0d7ea286f19c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a228f3cb8714bb1747b0d7ea286f19c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorDoubleFill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; double, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6a228f3cb8714bb1747b0d7ea286f19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6793798d6aa4a28518481f72b5dffe0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6793798d6aa4a28518481f72b5dffe0e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorBoolFill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; bool, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6793798d6aa4a28518481f72b5dffe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3ee829a67c1ff79abe416528c41f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe3ee829a67c1ff79abe416528c41f30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorIntFill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afe3ee829a67c1ff79abe416528c41f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be5a6969ca8de5d902a53309df0c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1be5a6969ca8de5d902a53309df0c27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorInt64Fill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab1be5a6969ca8de5d902a53309df0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1bf149a69798586ca44a0f7a11d39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c1bf149a69798586ca44a0f7a11d39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorStringFill, <a class="el" href="classcaffe2_1_1_given_tensor_fill_op.html">GivenTensorFillOp</a>&lt; std::string, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a25c1bf149a69798586ca44a0f7a11d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b7a04b92c4d0c7e688cbd5d9b92453"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27b7a04b92c4d0c7e688cbd5d9b92453"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorFill)</td></tr>
<tr class="separator:a27b7a04b92c4d0c7e688cbd5d9b92453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776f57c3c36d1ca80e440a9731910326"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776f57c3c36d1ca80e440a9731910326"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorDoubleFill)</td></tr>
<tr class="separator:a776f57c3c36d1ca80e440a9731910326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de4c54a6bcb97507e49a946bedd6f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16de4c54a6bcb97507e49a946bedd6f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorBoolFill)</td></tr>
<tr class="separator:a16de4c54a6bcb97507e49a946bedd6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f5291476fc8ac4db53c1b88e506b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d4f5291476fc8ac4db53c1b88e506b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorIntFill)</td></tr>
<tr class="separator:a7d4f5291476fc8ac4db53c1b88e506b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4182e9d6ba8afaf3e24478479e6350de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4182e9d6ba8afaf3e24478479e6350de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorInt64Fill)</td></tr>
<tr class="separator:a4182e9d6ba8afaf3e24478479e6350de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09357b5c1748c66e24ce0b4495e02c9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09357b5c1748c66e24ce0b4495e02c9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorStringFill)</td></tr>
<tr class="separator:a09357b5c1748c66e24ce0b4495e02c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9668223da47f615a327c5e3b55aecb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9668223da47f615a327c5e3b55aecb9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_DOUBLE &gt;)</td></tr>
<tr class="separator:aa9668223da47f615a327c5e3b55aecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1127010c8b79ef887f0e8fa003eb783f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1127010c8b79ef887f0e8fa003eb783f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_BOOL &gt;)</td></tr>
<tr class="separator:a1127010c8b79ef887f0e8fa003eb783f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d10328de65da48df227378e54aef56e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d10328de65da48df227378e54aef56e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_INT32 &gt;)</td></tr>
<tr class="separator:a7d10328de65da48df227378e54aef56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642e0d4281da343cab8fa2117c56b7b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a642e0d4281da343cab8fa2117c56b7b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_INT64 &gt;)</td></tr>
<tr class="separator:a642e0d4281da343cab8fa2117c56b7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e6de0a31359f52a5468e209d1af3bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90e6de0a31359f52a5468e209d1af3bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_STRING &gt;)</td></tr>
<tr class="separator:a90e6de0a31359f52a5468e209d1af3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1441fb45c62829835f5df2c664f9b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1441fb45c62829835f5df2c664f9b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GRUUnit, <a class="el" href="classcaffe2_1_1_g_r_u_unit_op.html">GRUUnitOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7b1441fb45c62829835f5df2c664f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ad44c1cbd4a64ee957dfd6ff9fa52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a275ad44c1cbd4a64ee957dfd6ff9fa52"></a>
in a sequence length aware fashion given&#160;</td><td class="memItemRight" valign="bottom"><b>the</b> (fused) inputs X(TxNxD)</td></tr>
<tr class="separator:a275ad44c1cbd4a64ee957dfd6ff9fa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959bdd2f18bcf6ed779e4edb688429c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959bdd2f18bcf6ed779e4edb688429c7"></a>
in a sequence length aware fashion given the previous hidden&#160;</td><td class="memItemRight" valign="bottom"><b>state</b> (NxD)</td></tr>
<tr class="separator:a959bdd2f18bcf6ed779e4edb688429c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785a0265bb5a49fe563576a5856bffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5785a0265bb5a49fe563576a5856bffb"></a>
in a sequence length aware fashion given the previous hidden and the sequence&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b> (N)</td></tr>
<tr class="separator:a5785a0265bb5a49fe563576a5856bffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bded13860e75746552c5f62698996f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bded13860e75746552c5f62698996f3"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is&#160;</td><td class="memItemRight" valign="bottom"><b>invalid</b> (as in, the value at X[t][n] &gt;=seqLengths[n].) DOC&quot;) .Arg( &quot;drop_states&quot;</td></tr>
<tr class="separator:a0bded13860e75746552c5f62698996f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42f64f71fed13909e998bfb422051df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab42f64f71fed13909e998bfb422051df"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;sequence_lengths&quot;,&quot;When false, the sequence lengths input is left out, &quot;&quot;and all following inputs are shifted left by one.&quot;).Output(0</td></tr>
<tr class="separator:ab42f64f71fed13909e998bfb422051df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65219a73c9faa974635939b186318b75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65219a73c9faa974635939b186318b75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GRUUnitGradient, <a class="el" href="classcaffe2_1_1_g_r_u_unit_gradient_op.html">GRUUnitGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a65219a73c9faa974635939b186318b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75c99c5b2b78b982546af2552826ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af75c99c5b2b78b982546af2552826ac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (5, 6).NumOutputs(2).Arg(&quot;sequence_lengths&quot;</td></tr>
<tr class="separator:af75c99c5b2b78b982546af2552826ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ded52bdd945fab308b19d3d7eb1c42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67ded52bdd945fab308b19d3d7eb1c42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (GRUUnit, <a class="el" href="classcaffe2_1_1_get_g_r_u_unit_gradient.html">GetGRUUnitGradient</a>)</td></tr>
<tr class="separator:a67ded52bdd945fab308b19d3d7eb1c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e1b3d007135b6e2591f5e23e11e1a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20e1b3d007135b6e2591f5e23e11e1a5"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (X)</td></tr>
<tr class="separator:a20e1b3d007135b6e2591f5e23e11e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba527b99c7e1b69a8258cf418920c0d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba527b99c7e1b69a8258cf418920c0d4"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto_DataType_FLOAT16)</td></tr>
<tr class="separator:aba527b99c7e1b69a8258cf418920c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1bd2ffab8464109c668b45df6591f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae1bd2ffab8464109c668b45df6591f8"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto_DataType_FLOAT)</td></tr>
<tr class="separator:aae1bd2ffab8464109c668b45df6591f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bcdb257c86dc846180e777357f208c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14bcdb257c86dc846180e777357f208c"></a>
The value for the elements of the output tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;shape&quot;,&quot;The shape of the output tensor.&quot;).Output(0</td></tr>
<tr class="separator:a14bcdb257c86dc846180e777357f208c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36696199136eaf34faac441f46efca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a36696199136eaf34faac441f46efca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (FloatToHalf, <a class="el" href="classcaffe2_1_1_get_float_to_half_gradient.html">GetFloatToHalfGradient</a>)</td></tr>
<tr class="separator:a3a36696199136eaf34faac441f46efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81004f1ab8baad6daa1fe974ee060f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa81004f1ab8baad6daa1fe974ee060f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (HalfToFloat, <a class="el" href="classcaffe2_1_1_get_half_to_float_gradient.html">GetHalfToFloatGradient</a>)</td></tr>
<tr class="separator:aa81004f1ab8baad6daa1fe974ee060f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e3494b799b136a2787912c5c8c200d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e3494b799b136a2787912c5c8c200d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Float16ConstantFill)</td></tr>
<tr class="separator:a45e3494b799b136a2787912c5c8c200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e52c366909d9e9723388425b3bf7b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e52c366909d9e9723388425b3bf7b72"></a>
std::vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Float16FillerTensorInference</b> (const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in)</td></tr>
<tr class="separator:a8e52c366909d9e9723388425b3bf7b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c28ce5d8a0bae091163f9342c38542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28c28ce5d8a0bae091163f9342c38542"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (If, <a class="el" href="classcaffe2_1_1_if_op.html">IfOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a28c28ce5d8a0bae091163f9342c38542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7eb7bdae983a0dc2bc94104175bae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca7eb7bdae983a0dc2bc94104175bae8"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'If' control operator, first input is a scalar boolean blob that stores condition
value. Accepts 'then_net' (required) and 'else_net' (optional) arguments for 'then' and
'else' subnets respectively. Subnets are executed in the same workspace as 'If'.
    )DOC&quot;).Arg(&quot;then_net&quot;</td></tr>
<tr class="separator:aca7eb7bdae983a0dc2bc94104175bae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddbde416cf87af0dee9cdddc0fa191f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adddbde416cf87af0dee9cdddc0fa191f"></a>
INT_MAX Net executed when condition is true&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;else_net&quot;,&quot;Net executed when condition is false (optional)&quot;).Input(0</td></tr>
<tr class="separator:adddbde416cf87af0dee9cdddc0fa191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144a71879072634a064d5e6bccf62bfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a144a71879072634a064d5e6bccf62bfa"></a>
INT_MAX Net executed when condition is true Scalar boolean condition&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ([](int in, int out) -&gt; bool{return true;})</td></tr>
<tr class="separator:a144a71879072634a064d5e6bccf62bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5ff154ad3fd3019cb05de7283925d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b5ff154ad3fd3019cb05de7283925d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (If, <a class="el" href="classcaffe2_1_1_if_op.html">IfOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a84b5ff154ad3fd3019cb05de7283925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113cc01301d21f478188b3f0e3c6f4ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a113cc01301d21f478188b3f0e3c6f4ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Im2Col, <a class="el" href="classcaffe2_1_1_im2_col_op.html">Im2ColOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a113cc01301d21f478188b3f0e3c6f4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca353312069267046d35ab8c4f4e97d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ca353312069267046d35ab8c4f4e97d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Col2Im, <a class="el" href="classcaffe2_1_1_col2_im_op.html">Col2ImOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7ca353312069267046d35ab8c4f4e97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135134482622f6a9688744822b69c691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a135134482622f6a9688744822b69c691"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Im2Col, <a class="el" href="classcaffe2_1_1_get_im2_col_gradient.html">GetIm2ColGradient</a>)</td></tr>
<tr class="separator:a135134482622f6a9688744822b69c691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b102883b9a724576888fd933fdafca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b102883b9a724576888fd933fdafca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Col2Im, <a class="el" href="classcaffe2_1_1_get_col2_im_gradient.html">GetCol2ImGradient</a>)</td></tr>
<tr class="separator:a50b102883b9a724576888fd933fdafca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f2e4aa5de48764929b5f3893550af7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2f2e4aa5de48764929b5f3893550af7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>switch</b> (order)</td></tr>
<tr class="separator:ad2f2e4aa5de48764929b5f3893550af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa282b23c9194e9f55b8c0a2d1791049e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa282b23c9194e9f55b8c0a2d1791049e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (H &gt;=dkernel_h)</td></tr>
<tr class="separator:aa282b23c9194e9f55b8c0a2d1791049e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94afdbc207e805298189c5d2c8136241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94afdbc207e805298189c5d2c8136241"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (W &gt;=dkernel_w)</td></tr>
<tr class="separator:a94afdbc207e805298189c5d2c8136241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb03e731553bf866806e3951e4724da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeb03e731553bf866806e3951e4724da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;4-tensor in NCHW or NHWC.&quot;).Output(0</td></tr>
<tr class="separator:afeb03e731553bf866806e3951e4724da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c75a39c612a14c09ac8802acf988be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30c75a39c612a14c09ac8802acf988be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Col2Im).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a30c75a39c612a14c09ac8802acf988be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b899b8c03924960fa28167a035b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a192b899b8c03924960fa28167a035b53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Im2Col, <a class="el" href="classcaffe2_1_1_im2_col_op.html">Im2ColOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a192b899b8c03924960fa28167a035b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0e66a1d9d8b0b02508c9e1919676d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f0e66a1d9d8b0b02508c9e1919676d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Col2Im, <a class="el" href="classcaffe2_1_1_col2_im_op.html">Col2ImOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9f0e66a1d9d8b0b02508c9e1919676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbadabea450b6aaf36301ddc2c56458"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bbadabea450b6aaf36301ddc2c56458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IntIndexCreate, <a class="el" href="classcaffe2_1_1_index_create_op.html">IndexCreateOp</a>&lt; int32_t &gt;)</td></tr>
<tr class="separator:a1bbadabea450b6aaf36301ddc2c56458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5f565be1a53b7165de223af1d7d77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77f5f565be1a53b7165de223af1d7d77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LongIndexCreate, <a class="el" href="classcaffe2_1_1_index_create_op.html">IndexCreateOp</a>&lt; int64_t &gt;)</td></tr>
<tr class="separator:a77f5f565be1a53b7165de223af1d7d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3334f788f88b77115926011ee2a9d65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3334f788f88b77115926011ee2a9d65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StringIndexCreate, <a class="el" href="classcaffe2_1_1_index_create_op.html">IndexCreateOp</a>&lt; std::string &gt;)</td></tr>
<tr class="separator:af3334f788f88b77115926011ee2a9d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b1c1b091ac2f07f1a447e86200813f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b1c1b091ac2f07f1a447e86200813f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexGet, <a class="el" href="classcaffe2_1_1_index_get_op.html">IndexGetOp</a>)</td></tr>
<tr class="separator:aa3b1c1b091ac2f07f1a447e86200813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b20d47b4f18396c328b6630866612e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8b20d47b4f18396c328b6630866612e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexLoad, <a class="el" href="classcaffe2_1_1_index_load_op.html">IndexLoadOp</a>)</td></tr>
<tr class="separator:ad8b20d47b4f18396c328b6630866612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a240fc30821040510877689d2f9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826a240fc30821040510877689d2f9e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexStore, <a class="el" href="classcaffe2_1_1_index_store_op.html">IndexStoreOp</a>)</td></tr>
<tr class="separator:a826a240fc30821040510877689d2f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524999b8c59758427ba16492de3e9c8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a524999b8c59758427ba16492de3e9c8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexFreeze, <a class="el" href="classcaffe2_1_1_index_freeze_op.html">IndexFreezeOp</a>)</td></tr>
<tr class="separator:a524999b8c59758427ba16492de3e9c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed210c9226ce7a92cd93a8d8c71bc011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed210c9226ce7a92cd93a8d8c71bc011"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexSize, <a class="el" href="classcaffe2_1_1_index_size_op.html">IndexSizeOp</a>)</td></tr>
<tr class="separator:aed210c9226ce7a92cd93a8d8c71bc011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceb64be62723f7e84b4eb54899698e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ceb64be62723f7e84b4eb54899698e3"></a>
Max number of including the zero entry&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;handler&quot;,&quot;Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance.&quot;)</td></tr>
<tr class="separator:a9ceb64be62723f7e84b4eb54899698e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade21c0df1d76663710fb3c660127f246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade21c0df1d76663710fb3c660127f246"></a>
Max number of including the zero entry&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;handle&quot;,&quot;Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance.&quot;)</td></tr>
<tr class="separator:ade21c0df1d76663710fb3c660127f246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66332de6045a57fdce39fea74e17e17f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66332de6045a57fdce39fea74e17e17f"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;handle&quot;,&quot;Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance.&quot;).Input(1</td></tr>
<tr class="separator:a66332de6045a57fdce39fea74e17e17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884ab0c236eacdd5c3a01adf606836bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a884ab0c236eacdd5c3a01adf606836bb"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of keys to be looked up&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;indices&quot;,&quot;Indices for each of the keys.&quot;)</td></tr>
<tr class="separator:a884ab0c236eacdd5c3a01adf606836bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad256e93f8c3da60ba21419a2bede66b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad256e93f8c3da60ba21419a2bede66b6"></a>
disallowing creation of new index entries Should not be called concurrently with IndexGet DOC The input handle&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{0, 0}})</td></tr>
<tr class="separator:ad256e93f8c3da60ba21419a2bede66b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf47500482f6aaa857f23f89e269d52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaf47500482f6aaa857f23f89e269d52"></a>
Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;items&quot;,&quot;1-D tensor with elements starting with index 1.&quot;).Output(0</td></tr>
<tr class="separator:aeaf47500482f6aaa857f23f89e269d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047fd3902fe90af881533489cffc43b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a047fd3902fe90af881533489cffc43b5"></a>
Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;items&quot;,&quot;Scalar int64 tensor with number of entries.&quot;)</td></tr>
<tr class="separator:a047fd3902fe90af881533489cffc43b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f281293d10a867072b740077d058270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f281293d10a867072b740077d058270"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_index_get_op.html">IndexGetOp</a>)</td></tr>
<tr class="separator:a0f281293d10a867072b740077d058270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aef91c7d93e6997aa19e28d3246fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18aef91c7d93e6997aa19e28d3246fbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (IntIndexCreate)</td></tr>
<tr class="separator:a18aef91c7d93e6997aa19e28d3246fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94b1d33c7c70b44de59c6276ba264d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e94b1d33c7c70b44de59c6276ba264d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (LongIndexCreate)</td></tr>
<tr class="separator:a8e94b1d33c7c70b44de59c6276ba264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab929f3d0e43c56b474afc25a53141a26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab929f3d0e43c56b474afc25a53141a26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (StringIndexCreate)</td></tr>
<tr class="separator:ab929f3d0e43c56b474afc25a53141a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f6626f025edb1699495d2aa157112"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690f6626f025edb1699495d2aa157112"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexFreeze)</td></tr>
<tr class="separator:a690f6626f025edb1699495d2aa157112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7bffcc3c74b78c3c3fc67b42d76df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62d7bffcc3c74b78c3c3fc67b42d76df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexLoad)</td></tr>
<tr class="separator:a62d7bffcc3c74b78c3c3fc67b42d76df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2e92a711580482a684080e4c08922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36f2e92a711580482a684080e4c08922"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexStore)</td></tr>
<tr class="separator:a36f2e92a711580482a684080e4c08922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15843d09e06554084a8116b544d8e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f15843d09e06554084a8116b544d8e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexSize)</td></tr>
<tr class="separator:a2f15843d09e06554084a8116b544d8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431e6b523ecc2eb8aced116bac416d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2431e6b523ecc2eb8aced116bac416d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1_index_base.html">caffe2::IndexBase</a> &gt;)</td></tr>
<tr class="separator:a2431e6b523ecc2eb8aced116bac416d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498534efc64526508676a9fa17b443bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a498534efc64526508676a9fa17b443bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_SERIALIZER</b> ((<a class="el" href="classcaffe2_1_1_type_meta.html#a832b40f4bf4158dd3f1cc0b7d51858db">TypeMeta::Id</a>&lt; std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1_index_base.html">caffe2::IndexBase</a> &gt;&gt;()), <a class="el" href="classcaffe2_1_1_index_serializer.html">IndexSerializer</a>)</td></tr>
<tr class="separator:a498534efc64526508676a9fa17b443bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6bfcb6492d0e7044d8b2461f108e6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b6bfcb6492d0e7044d8b2461f108e6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_DESERIALIZER</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1_index_base.html">caffe2::IndexBase</a> &gt;, <a class="el" href="classcaffe2_1_1_index_deserializer.html">IndexDeserializer</a>)</td></tr>
<tr class="separator:a0b6bfcb6492d0e7044d8b2461f108e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f4ceb2b6a85106b4378bee04a8b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e2f4ceb2b6a85106b4378bee04a8b5c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (InstanceNormGradient, <a class="el" href="classcaffe2_1_1_instance_norm_gradient_op.html">InstanceNormGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e2f4ceb2b6a85106b4378bee04a8b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c347803669d9cf2910272708ab0907"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3c347803669d9cf2910272708ab0907"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (InstanceNormGradient).NumInputs(4</td></tr>
<tr class="separator:ac3c347803669d9cf2910272708ab0907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612b4e4d17f9e8d6c40579ec84b60e3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a612b4e4d17f9e8d6c40579ec84b60e3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (3)</td></tr>
<tr class="separator:a612b4e4d17f9e8d6c40579ec84b60e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81aee449bf149a09a82ec31f4882a63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af81aee449bf149a09a82ec31f4882a63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (InstanceNorm, <a class="el" href="classcaffe2_1_1_get_instance_norm_gradient.html">GetInstanceNormGradient</a>)</td></tr>
<tr class="separator:af81aee449bf149a09a82ec31f4882a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0af483cee269a5f5ff6b50caff6943"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef0af483cee269a5f5ff6b50caff6943"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (InstanceNorm, <a class="el" href="classcaffe2_1_1_instance_norm_op.html">InstanceNormOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aef0af483cee269a5f5ff6b50caff6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bffc30682c0843d52223564efd877d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bffc30682c0843d52223564efd877d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BernoulliJSD, <a class="el" href="classcaffe2_1_1_bernoulli_j_s_d_op.html">BernoulliJSDOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0bffc30682c0843d52223564efd877d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22303aabd08a7b7706a69d39d0ba4ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22303aabd08a7b7706a69d39d0ba4ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BernoulliJSDGradient, <a class="el" href="classcaffe2_1_1_bernoulli_j_s_d_gradient_op.html">BernoulliJSDGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad22303aabd08a7b7706a69d39d0ba4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858776ce1f1216c2df4ec19bc9e893fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a858776ce1f1216c2df4ec19bc9e893fe"></a>
array of probabilities for prediction&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;T&quot;,&quot;array of probabilities for target&quot;).Output(0</td></tr>
<tr class="separator:a858776ce1f1216c2df4ec19bc9e893fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06016ba6fc7a7bf51db1eb204a5da628"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06016ba6fc7a7bf51db1eb204a5da628"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (BernoulliJSDGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a06016ba6fc7a7bf51db1eb204a5da628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82708cc86adbd368c6a760f95f786292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82708cc86adbd368c6a760f95f786292"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BernoulliJSD, <a class="el" href="classcaffe2_1_1_get_bernoulli_j_s_d_gradient.html">GetBernoulliJSDGradient</a>)</td></tr>
<tr class="separator:a82708cc86adbd368c6a760f95f786292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12265f745d3c059e7cfe2869bf6ac786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12265f745d3c059e7cfe2869bf6ac786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (KeySplit, <a class="el" href="classcaffe2_1_1_key_split_op.html">KeySplitOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a12265f745d3c059e7cfe2869bf6ac786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedecb2914782e4628fe842b5415e682"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaedecb2914782e4628fe842b5415e682"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_key_split_op.html">KeySplitOp</a>)</td></tr>
<tr class="separator:aaedecb2914782e4628fe842b5415e682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0866b7d590af1e53d29378bcc31b9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b0866b7d590af1e53d29378bcc31b9b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (KeySplit).NumInputs(1).NumOutputs(1</td></tr>
<tr class="separator:a0b0866b7d590af1e53d29378bcc31b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c089dfb7d86f6ea01447865c945cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327c089dfb7d86f6ea01447865c945cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LayerNorm, <a class="el" href="classcaffe2_1_1_layer_norm_op.html">LayerNormOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a327c089dfb7d86f6ea01447865c945cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a78f0c564ee8f85feb8334b45944d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a8a78f0c564ee8f85feb8334b45944d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LayerNormGradient).NumInputs(5).NumOutputs(1)</td></tr>
<tr class="separator:a0a8a78f0c564ee8f85feb8334b45944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e01bb0ae44a6c2b47a44852cc72ff2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e01bb0ae44a6c2b47a44852cc72ff2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LayerNormGradient, <a class="el" href="classcaffe2_1_1_layer_norm_gradient_op.html">LayerNormGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa6e01bb0ae44a6c2b47a44852cc72ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8528c57a6e4c9f15081661271e9411"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea8528c57a6e4c9f15081661271e9411"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LayerNorm, GetLayerNormGradient)</td></tr>
<tr class="separator:aea8528c57a6e4c9f15081661271e9411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b031020b594a1fc2472f642593ff33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b031020b594a1fc2472f642593ff33"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>input_dims</b> (input_dims_long.begin(), input_dims_long.end())</td></tr>
<tr class="separator:a85b031020b594a1fc2472f642593ff33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361340ae951d832bd229b551db6d686c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a361340ae951d832bd229b551db6d686c"></a>
<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>helper</b> (def)</td></tr>
<tr class="separator:a361340ae951d832bd229b551db6d686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b896aa28455a7f33ba3d7f55d0b7e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b896aa28455a7f33ba3d7f55d0b7e00"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stat_dims</b> (input_dims.begin(), input_dims.begin()+canonical_axis)</td></tr>
<tr class="separator:a3b896aa28455a7f33ba3d7f55d0b7e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe470c342523160213450ac5708d0041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe470c342523160213450ac5708d0041"></a>
stat_dims&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (1)</td></tr>
<tr class="separator:afe470c342523160213450ac5708d0041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02daba3b6c74564217fa93817a1f29b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae02daba3b6c74564217fa93817a1f29b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Computes layer normalization as described in https://arxiv.org/pdf/1607.06450.pdf.
Given an input vector x \in [a_0, a_1, ...,a_{k-1}, a_k, ..., a_{n-1}],
this op treats dimensions a_k through a_{n-1} as feature vectors. For each
feature vector, the op contains the mean and standard deviation. Then,
it returns the normalized values (with respect to the feature vector).

Note that this op does not contain the scale an bias terms described in the
paper. Simply follow this op with an FC op to add those. Concretely, this op
implements:

h = \frac{1}{\sigma}(a - \mu)
where \mu = \frac{1}{H}\sum_{i=1}^{H} a_i
and \sigma = \sqrt{\frac{1}{H}\sum_{i=1}^{H}(a_i - \mu)^2}
where H is the number of hidden units (i.e. product of dimensions from 'axis'
to the end.)
)DOC&quot;).Arg(&quot;axis&quot;</td></tr>
<tr class="separator:ae02daba3b6c74564217fa93817a1f29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefe70ce6e423ae38bdddb07fe367510"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adefe70ce6e423ae38bdddb07fe367510"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;epsilon&quot;,&quot;(float) default to 0.001. Small value to be added to the stdev when&quot;&quot; dividing out by that value. This prevents division by zero.&quot;).Input(0</td></tr>
<tr class="separator:adefe70ce6e423ae38bdddb07fe367510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef802f512ba74c2bce30b8fd96a0dc7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef802f512ba74c2bce30b8fd96a0dc7a"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size Input tensor which layer normalization will be applied to&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;Normalized values&quot;).Output(1</td></tr>
<tr class="separator:aef802f512ba74c2bce30b8fd96a0dc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de415e963632e7285ce3db115f92c06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de415e963632e7285ce3db115f92c06"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size Input tensor which layer normalization will be applied to Mean values for each feature vector&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2,&quot;stddev&quot;,&quot;Standard deviations for each feature vector&quot;)</td></tr>
<tr class="separator:a4de415e963632e7285ce3db115f92c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2263206a567cd499e2088b447264c4cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2263206a567cd499e2088b447264c4cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LeakyRelu, <a class="el" href="classcaffe2_1_1_leaky_relu_op.html">LeakyReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2263206a567cd499e2088b447264c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411c5b13234bf990c1555a10fb09b95d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a411c5b13234bf990c1555a10fb09b95d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LeakyReluGradient, <a class="el" href="classcaffe2_1_1_leaky_relu_gradient_op.html">LeakyReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a411c5b13234bf990c1555a10fb09b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bd555dbc7fce4a1bee4eee7f49d195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89bd555dbc7fce4a1bee4eee7f49d195"></a>
Coefficient of default value is and produces one output&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; T &gt;) where the function`f(x)</td></tr>
<tr class="separator:a89bd555dbc7fce4a1bee4eee7f49d195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e08259846bbbdb9446f66960fe014ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e08259846bbbdb9446f66960fe014ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;alpha&quot;,&quot;Coefficient of leakage&quot;)</td></tr>
<tr class="separator:a4e08259846bbbdb9446f66960fe014ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6b082c1a7064c4fc73157bc41643f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae6b082c1a7064c4fc73157bc41643f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LeakyRelu, <a class="el" href="classcaffe2_1_1_get_leaky_relu_gradient.html">GetLeakyReluGradient</a>)</td></tr>
<tr class="separator:a1ae6b082c1a7064c4fc73157bc41643f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d8b5ff322dc32ea156dd89fbd0218c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91d8b5ff322dc32ea156dd89fbd0218c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsSumFused8BitRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths_fused8_bit_rowwise_op.html">SparseLengthsFused8BitRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a91d8b5ff322dc32ea156dd89fbd0218c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17803b531d555dad8af3e8c4eff1c09d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17803b531d555dad8af3e8c4eff1c09d"></a>
but operating on bit rowwise quantized matrices with fused&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b> (where each row stores quantized values, and then 4-byte scale and 4-byte bias).) DOC&quot;) .Input( 0</td></tr>
<tr class="separator:a17803b531d555dad8af3e8c4eff1c09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f2a281250120560f5d496cc13b14c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f2a281250120560f5d496cc13b14c0"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor obtained with&#160;</td><td class="memItemRight" valign="bottom"><b>operator FloatToFused8BitRowwiseQuantized&quot;) .Input</b> (1,&quot;INDICES&quot;,&quot;Integer vector containing indices of the first &quot;&quot;dimension of DATA for the slices that are being aggregated&quot;).Input(2</td></tr>
<tr class="separator:a11f2a281250120560f5d496cc13b14c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83bd2488e22253dc6a894ea1469489f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa83bd2488e22253dc6a894ea1469489f"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor obtained with Vector with the same sum of elements as the first dimension of DATA&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;output&quot;)</td></tr>
<tr class="separator:aa83bd2488e22253dc6a894ea1469489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5004bcd17a4e7d8f457b5ebe19b63a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5004bcd17a4e7d8f457b5ebe19b63a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsSumFused8BitRowwise)</td></tr>
<tr class="separator:a0f5004bcd17a4e7d8f457b5ebe19b63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eb6fcabe3dd05328ef202600210f9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7eb6fcabe3dd05328ef202600210f9b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsWeightedSumFused8BitRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths_fused8_bit_rowwise_op.html">SparseLengthsFused8BitRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:af7eb6fcabe3dd05328ef202600210f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac22763995f94a64f0455f60672aec0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ac22763995f94a64f0455f60672aec0"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor obtained with Vector with the same sum of elements as the first dimension of DATA&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;WEIGHTS&quot;,&quot;Vector of weights to scale rows of DATA with before reduction&quot;).Output(0</td></tr>
<tr class="separator:a9ac22763995f94a64f0455f60672aec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0626ce66b6efc80ad54f6fb4b35faed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0626ce66b6efc80ad54f6fb4b35faed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsWeightedSumFused8BitRowwise)</td></tr>
<tr class="separator:aa0626ce66b6efc80ad54f6fb4b35faed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bf9d89c75d5d1709dc47165ff2cec7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0bf9d89c75d5d1709dc47165ff2cec7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsMeanFused8BitRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths_fused8_bit_rowwise_op.html">SparseLengthsFused8BitRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false, true &gt;)</td></tr>
<tr class="separator:af0bf9d89c75d5d1709dc47165ff2cec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de7891a5a0d69774139573cd45a1f64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de7891a5a0d69774139573cd45a1f64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsMeanFused8BitRowwise)</td></tr>
<tr class="separator:a4de7891a5a0d69774139573cd45a1f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798a8776e3c600a7c4fb72e0d75078bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a798a8776e3c600a7c4fb72e0d75078bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsSum&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float, float16 &gt;, 0, 0 &gt;)</td></tr>
<tr class="separator:a798a8776e3c600a7c4fb72e0d75078bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b29b394b27bc0898b8e7d08b66132d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0b29b394b27bc0898b8e7d08b66132d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsWeightedSum&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float, float16 &gt;, 1, 0 &gt;)</td></tr>
<tr class="separator:ac0b29b394b27bc0898b8e7d08b66132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf19f82c38a0ef58c19964ab068c857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcf19f82c38a0ef58c19964ab068c857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsMean&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float, float16 &gt;, 0, 1 &gt;)</td></tr>
<tr class="separator:abcf19f82c38a0ef58c19964ab068c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafe488e6db7646a9d15aec155a0fc04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afafe488e6db7646a9d15aec155a0fc04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Rowwise8BitQuantizedToFloat, <a class="el" href="classcaffe2_1_1_rowwise8_bit_quantized_to_float_op.html">Rowwise8BitQuantizedToFloatOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afafe488e6db7646a9d15aec155a0fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75b30a0c88ed4f390bf2e445d68311"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a75b30a0c88ed4f390bf2e445d68311"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FloatToRowwiseQuantized8Bits, <a class="el" href="classcaffe2_1_1_float_to_rowwise_quantized8_bits_op.html">FloatToRowwiseQuantized8BitsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1a75b30a0c88ed4f390bf2e445d68311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9bc5b0516a81f46642c5c36d55f4c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e9bc5b0516a81f46642c5c36d55f4c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsSum8BitsRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths8_bits_rowwise_op.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8e9bc5b0516a81f46642c5c36d55f4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a52395c5f3f9c00284b61da06cadc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5a52395c5f3f9c00284b61da06cadc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsWeightedSum8BitsRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths8_bits_rowwise_op.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, 1 &gt;)</td></tr>
<tr class="separator:ab5a52395c5f3f9c00284b61da06cadc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ca5d3b1682fd375392731ad2ebfae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e5ca5d3b1682fd375392731ad2ebfae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsMean8BitsRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths8_bits_rowwise_op.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, 0, 1 &gt;)</td></tr>
<tr class="separator:a4e5ca5d3b1682fd375392731ad2ebfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c1b465e20295abe7d0a644ba260f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a906c1b465e20295abe7d0a644ba260f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsWeightedMean8BitsRowwise, <a class="el" href="classcaffe2_1_1_sparse_lengths8_bits_rowwise_op.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, 1, 1 &gt;)</td></tr>
<tr class="separator:a906c1b465e20295abe7d0a644ba260f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9ca94af1f491bf7be627d57f0eb59d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef9ca94af1f491bf7be627d57f0eb59d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (5).NumOutputs(1).SetDoc(R&quot;DOC( Variation of SparseLengthsWeightedSum operator</td></tr>
<tr class="separator:aef9ca94af1f491bf7be627d57f0eb59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22f7bbcc05c2fd91ab3a8a01f31d4c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa22f7bbcc05c2fd91ab3a8a01f31d4c4"></a>
reshape it into matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (m_1, m_2 x...x m_n) and apply row-wise quantization.After this</td></tr>
<tr class="separator:aa22f7bbcc05c2fd91ab3a8a01f31d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f43185518d07a4972af6391036524f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a30f43185518d07a4972af6391036524f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Rowwise8BitQuantizedToFloat)</td></tr>
<tr class="separator:a30f43185518d07a4972af6391036524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955b674bc3eef5b4e11be15854f4a58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab955b674bc3eef5b4e11be15854f4a58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (FloatToRowwiseQuantized8Bits)</td></tr>
<tr class="separator:ab955b674bc3eef5b4e11be15854f4a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31761fa6a21e4722cad8b5b8336433f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31761fa6a21e4722cad8b5b8336433f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsSum8BitsRowwise)</td></tr>
<tr class="separator:a31761fa6a21e4722cad8b5b8336433f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6e17cd7f773983c7ff8958cfbe1a6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd6e17cd7f773983c7ff8958cfbe1a6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsWeightedSum8BitsRowwise)</td></tr>
<tr class="separator:acd6e17cd7f773983c7ff8958cfbe1a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28abebee9dcb7db4b73ea9a334981e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28abebee9dcb7db4b73ea9a334981e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsMean8BitsRowwise)</td></tr>
<tr class="separator:af28abebee9dcb7db4b73ea9a334981e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338e633b6c9b6d53aa17d141c2173d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae338e633b6c9b6d53aa17d141c2173d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsWeightedMean8BitsRowwise)</td></tr>
<tr class="separator:ae338e633b6c9b6d53aa17d141c2173d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba780c03088ffdf5e3d08f6d274a4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38ba780c03088ffdf5e3d08f6d274a4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTile, <a class="el" href="classcaffe2_1_1_lengths_tile_op.html">LengthsTileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38ba780c03088ffdf5e3d08f6d274a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3db8301af4ab684ea15332b24e8f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cd3db8301af4ab684ea15332b24e8f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LengthsTile, <a class="el" href="classcaffe2_1_1_lengths_tile_op.html">LengthsTileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6cd3db8301af4ab684ea15332b24e8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706e4dfb2e27ede3b5f7690d961ad2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1706e4dfb2e27ede3b5f7690d961ad2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTopK, <a class="el" href="classcaffe2_1_1_lengths_top_k_op.html">LengthsTopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1706e4dfb2e27ede3b5f7690d961ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a580d523aaa232eb0d30a9e9c1d0ae8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a580d523aaa232eb0d30a9e9c1d0ae8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTopKGradient, <a class="el" href="classcaffe2_1_1_lengths_top_k_gradient_op.html">LengthsTopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a580d523aaa232eb0d30a9e9c1d0ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4405504dd7c0aa41a0aa7a184148b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4405504dd7c0aa41a0aa7a184148b0"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;DATA&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of rank 1. First dimension must be equal to the sum of &quot;&quot;lengths&quot;).Input(1</td></tr>
<tr class="separator:aec4405504dd7c0aa41a0aa7a184148b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe2cde672489d8ce983c5eda0bbfbe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafe2cde672489d8ce983c5eda0bbfbe4"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of int32 lengths of rank&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;TopKValue&quot;,&quot;Output top k elements for each segment, with&quot;&quot;shape=(SIZE(lengths), k)&quot;).Output(1</td></tr>
<tr class="separator:aafe2cde672489d8ce983c5eda0bbfbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab549efed88fc7cc80733e3b07ca9a4ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab549efed88fc7cc80733e3b07ca9a4ed"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of int32 lengths of rank Output indices in DATA corresponding to value in TopKValue&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;k&quot;,&quot;the number of top values to return for each segment, if the number &quot;&quot;of values is smaller than k, the values would be padded with 0 and &quot;&quot;indices would be padded with -1.&quot;)</td></tr>
<tr class="separator:ab549efed88fc7cc80733e3b07ca9a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9882aad183ec1a93cbdef02f529bdbb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9882aad183ec1a93cbdef02f529bdbb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsTopKGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a9882aad183ec1a93cbdef02f529bdbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a103f939c0cd701c1548e4d7a8ca1b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a103f939c0cd701c1548e4d7a8ca1b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LengthsTopK, GetLengthsTopKGradient)</td></tr>
<tr class="separator:a3a103f939c0cd701c1548e4d7a8ca1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9327141f225d709f7ffc9c4049768167"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9327141f225d709f7ffc9c4049768167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DBExists, <a class="el" href="classcaffe2_1_1_d_b_exists_op.html">DBExistsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9327141f225d709f7ffc9c4049768167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a3c43568d2c93a45f3cf3313bfa02f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a3c43568d2c93a45f3cf3313bfa02f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Load, <a class="el" href="classcaffe2_1_1_load_op.html">LoadOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a83a3c43568d2c93a45f3cf3313bfa02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857a64f8d05730bf604eb9b6f789da8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4857a64f8d05730bf604eb9b6f789da8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Save, <a class="el" href="classcaffe2_1_1_save_op.html">SaveOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4857a64f8d05730bf604eb9b6f789da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89777888c5fe5010a5db2e9fa335fae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89777888c5fe5010a5db2e9fa335fae6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Checkpoint, <a class="el" href="classcaffe2_1_1_checkpoint_op.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a89777888c5fe5010a5db2e9fa335fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34354f11cf682249cc1ce24a8114cd1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34354f11cf682249cc1ce24a8114cd1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Snapshot, <a class="el" href="classcaffe2_1_1_checkpoint_op.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a34354f11cf682249cc1ce24a8114cd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30135298d4be7b674d77d037e904efb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab30135298d4be7b674d77d037e904efb"></a>
A scalar bool <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;absolute_path&quot;,&quot;(int, default 0) if set, use the db path directly and do not prepend &quot;&quot;the current root folder of the workspace.&quot;).Arg(&quot;db_name&quot;</td></tr>
<tr class="separator:ab30135298d4be7b674d77d037e904efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350767e2c7a9a6d30c6790d4b94d37cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a350767e2c7a9a6d30c6790d4b94d37cc"></a>
A scalar bool <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> string the path to the db to load&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;db_type&quot;,&quot;(string) the type of the db.&quot;)</td></tr>
<tr class="separator:a350767e2c7a9a6d30c6790d4b94d37cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08b4dcb85e6a72c5f1636e692bf7b9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab08b4dcb85e6a72c5f1636e692bf7b9a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, INT_MAX).NumOutputs(0</td></tr>
<tr class="separator:ab08b4dcb85e6a72c5f1636e692bf7b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabfac0c4185eb57f346547dd55b6ba2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afabfac0c4185eb57f346547dd55b6ba2"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The Load operator loads a set of serialized blobs from a db or multiple dbs. It
takes [0, infinity) number of inputs and [0, infinity) number of outputs, using
the db keys to match the db entries with the outputs.

If at least one input is passed, then it is assumed that that input blobs are a
set of DBReaders to load from. Otherwise the db or dbs argument is used to load
blobs from one single db or multiple dbs respectively. db_type argument is used
to specify the type of the input db/dbs.
)DOC&quot;).Arg(&quot;absolute_path&quot;</td></tr>
<tr class="separator:afabfac0c4185eb57f346547dd55b6ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9983916aaf451c113a9d8e1ba10803"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9983916aaf451c113a9d8e1ba10803"></a>
INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;add_prefix&quot;,&quot;(string, default=\&quot;\&quot;) blobs will be prefixed with this when loading.&quot;&quot;Useful for avoiding collisions with blobs existing in the workspace.&quot;&quot;The output blob names specified to this op should include this prefix.&quot;).Arg(&quot;strip_prefix&quot;</td></tr>
<tr class="separator:abe9983916aaf451c113a9d8e1ba10803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42aaf8a2f399dcee5aa8594756992b3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42aaf8a2f399dcee5aa8594756992b3a"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a42aaf8a2f399dcee5aa8594756992b3a"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FormatString</b> (const string &amp;pattern, Ts...values)</td></tr>
<tr class="separator:a42aaf8a2f399dcee5aa8594756992b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8186606e8b24d29010b076a7c9ccc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab8186606e8b24d29010b076a7c9ccc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Load, <a class="el" href="classcaffe2_1_1_load_op.html">LoadOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aab8186606e8b24d29010b076a7c9ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af101d9b19521d084f15edd39e20c43e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af101d9b19521d084f15edd39e20c43e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Save, <a class="el" href="classcaffe2_1_1_save_op.html">SaveOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af101d9b19521d084f15edd39e20c43e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8145f81bb04342575425becdd999e2f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8145f81bb04342575425becdd999e2f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Checkpoint, <a class="el" href="classcaffe2_1_1_checkpoint_op.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a8145f81bb04342575425becdd999e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7702dd289068377c4356b52ee90b74ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7702dd289068377c4356b52ee90b74ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LRN, <a class="el" href="classcaffe2_1_1_l_r_n_op.html">LRNOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7702dd289068377c4356b52ee90b74ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dbd0b26aaca2fac07d5191c2ffb419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05dbd0b26aaca2fac07d5191c2ffb419"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LRNGradient, <a class="el" href="classcaffe2_1_1_l_r_n_gradient_op.html">LRNGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a05dbd0b26aaca2fac07d5191c2ffb419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e642c413569153b1122d6e5acbefea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e642c413569153b1122d6e5acbefea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LRN).NumInputs(1).NumOutputs(1</td></tr>
<tr class="separator:a86e642c413569153b1122d6e5acbefea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887777439f2aa62e31317e81d3ebf359"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a887777439f2aa62e31317e81d3ebf359"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LRNGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a887777439f2aa62e31317e81d3ebf359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c499f29f00ec4a299b806f50d19b83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3c499f29f00ec4a299b806f50d19b83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LRN, <a class="el" href="classcaffe2_1_1_get_l_r_n_gradient.html">GetLRNGradient</a>)</td></tr>
<tr class="separator:af3c499f29f00ec4a299b806f50d19b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1b86cbff4a05b3c01cdb4c9f045fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a1b86cbff4a05b3c01cdb4c9f045fe4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6a1b86cbff4a05b3c01cdb4c9f045fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae234337a0f5b723601a468cc35d61e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae234337a0f5b723601a468cc35d61e"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC1D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4ae234337a0f5b723601a468cc35d61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecaff2efc994a1396203c6d75cff4a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ecaff2efc994a1396203c6d75cff4a6"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC2D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3ecaff2efc994a1396203c6d75cff4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32e2253300a3fd1b58d636a7d9bacd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac32e2253300a3fd1b58d636a7d9bacd4"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC3D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac32e2253300a3fd1b58d636a7d9bacd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3691743e6c1b60e8bf613c05ab0c125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3691743e6c1b60e8bf613c05ab0c125"></a>
NumInputs(2, 3).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LCGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab3691743e6c1b60e8bf613c05ab0c125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8426a407adb929ab24a730ff53fee83a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8426a407adb929ab24a730ff53fee83a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LCGradient).NumInputs(2</td></tr>
<tr class="separator:a8426a407adb929ab24a730ff53fee83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164978d7deef2ba12deb94e1f0be5380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a164978d7deef2ba12deb94e1f0be5380"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC1DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a164978d7deef2ba12deb94e1f0be5380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9828214ab329c658ea2dec0557ae20f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9828214ab329c658ea2dec0557ae20f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LC1DGradient).NumInputs(2</td></tr>
<tr class="separator:ae9828214ab329c658ea2dec0557ae20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7be3ac8dd05e2696316efb5b3c2e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7be3ac8dd05e2696316efb5b3c2e6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC2DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6c7be3ac8dd05e2696316efb5b3c2e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922e5441460996843774046bb54f1b41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a922e5441460996843774046bb54f1b41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LC2DGradient).NumInputs(2</td></tr>
<tr class="separator:a922e5441460996843774046bb54f1b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92c83d050f7aa5379fa4a80aefa102d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab92c83d050f7aa5379fa4a80aefa102d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LC3DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab92c83d050f7aa5379fa4a80aefa102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ff6d35b42931a85ace3074ac3de8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb2ff6d35b42931a85ace3074ac3de8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LC3DGradient).NumInputs(2</td></tr>
<tr class="separator:adb2ff6d35b42931a85ace3074ac3de8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeea10cda4338df72063c16742af28a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeea10cda4338df72063c16742af28a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LC, GetLocallyConnectedGradient)</td></tr>
<tr class="separator:afeea10cda4338df72063c16742af28a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492be997ec6d0e35a30d2183d6e664a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a492be997ec6d0e35a30d2183d6e664a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LC1D, GetLocallyConnectedGradient)</td></tr>
<tr class="separator:a492be997ec6d0e35a30d2183d6e664a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769e348f517d725c973cfb5f52a6a7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3769e348f517d725c973cfb5f52a6a7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LC2D, GetLocallyConnectedGradient)</td></tr>
<tr class="separator:a3769e348f517d725c973cfb5f52a6a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f8bf91a78f04b115ddddfc2175d2a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63f8bf91a78f04b115ddddfc2175d2a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LC3D, GetLocallyConnectedGradient)</td></tr>
<tr class="separator:a63f8bf91a78f04b115ddddfc2175d2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf90cd104587ffd347097e80454527f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf90cd104587ffd347097e80454527f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:acf90cd104587ffd347097e80454527f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaea276dbc3b70723aef025f48070ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eaea276dbc3b70723aef025f48070ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LCGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7eaea276dbc3b70723aef025f48070ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2754d35f306a7cc7f5155d9c085da7b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2754d35f306a7cc7f5155d9c085da7b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC1D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2754d35f306a7cc7f5155d9c085da7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c984f58b64f42af2c571b84bcc4147"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c984f58b64f42af2c571b84bcc4147"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC1DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a94c984f58b64f42af2c571b84bcc4147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65346e779cc27df7c07a1cb3c389c19e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65346e779cc27df7c07a1cb3c389c19e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC2D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a65346e779cc27df7c07a1cb3c389c19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8723c1666cf781d42fb3ad667465c8f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8723c1666cf781d42fb3ad667465c8f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC2DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a8723c1666cf781d42fb3ad667465c8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802124c6027b6873fb8c424d2ceb8a45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802124c6027b6873fb8c424d2ceb8a45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC3D, <a class="el" href="classcaffe2_1_1_locally_connected_op.html">LocallyConnectedOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a802124c6027b6873fb8c424d2ceb8a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c09c3d303e397f74050b8cb5d1c587"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c09c3d303e397f74050b8cb5d1c587"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LC3DGradient, <a class="el" href="classcaffe2_1_1_locally_connected_gradient_op.html">LocallyConnectedGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a41c09c3d303e397f74050b8cb5d1c587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9fdf95c6a6174779262572e85ae15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33d9fdf95c6a6174779262572e85ae15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Log, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_log_c_p_u_functor.html">LogCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a33d9fdf95c6a6174779262572e85ae15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f7b405b7c8bab8fb79c8174334e6b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f7b405b7c8bab8fb79c8174334e6b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Log, <a class="el" href="classcaffe2_1_1_get_log_gradient.html">GetLogGradient</a>)</td></tr>
<tr class="separator:a58f7b405b7c8bab8fb79c8174334e6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ed5092331240ad4d9dafee72589e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250ed5092331240ad4d9dafee72589e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Logit, <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_logit_c_p_u_functor.html">LogitCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a250ed5092331240ad4d9dafee72589e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f92115b6b354c26c521c337d50f02d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7f92115b6b354c26c521c337d50f02d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LogitGradient, <a class="el" href="classcaffe2_1_1_logit_gradient_op.html">LogitGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae7f92115b6b354c26c521c337d50f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a546b2bb8f24d41dc111c6b57f08d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b6a546b2bb8f24d41dc111c6b57f08d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a>, <a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9b6a546b2bb8f24d41dc111c6b57f08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e97ffdbe98d84cba77c1e2ea9bd950"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75e97ffdbe98d84cba77c1e2ea9bd950"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_averaged_loss_gradient.html">AveragedLossGradient</a>, <a class="el" href="classcaffe2_1_1_averaged_loss_gradient.html">AveragedLossGradient</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a75e97ffdbe98d84cba77c1e2ea9bd950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44131466951f0c7f19ca61bbd332e921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44131466951f0c7f19ca61bbd332e921"></a>
NumInputs(1).NumOutputs(1).ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (<a class="el" href="classcaffe2_1_1_averaged_loss_gradient.html">AveragedLossGradient</a>).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a44131466951f0c7f19ca61bbd332e921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70fd91f38572036a41ec4bec609a830"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae70fd91f38572036a41ec4bec609a830"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_averaged_loss.html">AveragedLoss</a>, <a class="el" href="classcaffe2_1_1_get_averaged_loss_gradient.html">GetAveragedLossGradient</a>)</td></tr>
<tr class="separator:ae70fd91f38572036a41ec4bec609a830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eea3b2df140dd6963ab3f3a69df3ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16eea3b2df140dd6963ab3f3a69df3ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_lp_pool.html">LpPool</a>, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_lp_pool.html">LpPool</a> &gt;)</td></tr>
<tr class="separator:a16eea3b2df140dd6963ab3f3a69df3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c17fe3eeb5785b7dde994ceea34ecab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c17fe3eeb5785b7dde994ceea34ecab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LpPoolGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_lp_pool.html">LpPool</a> &gt;)</td></tr>
<tr class="separator:a7c17fe3eeb5785b7dde994ceea34ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098bd22e76e590fc425aa7542adf307"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3098bd22e76e590fc425aa7542adf307"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator.L-p pooling consisting of taking the L-p norm of a subset of the input tensor according to the kernel size and downsampling the data into the output blob Y for further processing.) DOC&quot;) .Input</b> (0,&quot;X&quot;,&quot;Input data tensor from the previous operator; dimensions &quot;&quot;depend on whether the NCHW or NHWC operators are being used. For example, &quot;&quot;in the former, the input has size (N x C x H x W), where N is the batch &quot;&quot;size, C is the number of channels, and H and W are the height and the width &quot;&quot;of the data. The corresponding permutation of dimensions is used in the &quot;&quot;latter case. &quot;).Output(0</td></tr>
<tr class="separator:a3098bd22e76e590fc425aa7542adf307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab436155bdeca962ec444820f3aa30b7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab436155bdeca962ec444820f3aa30b7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LpPoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ab436155bdeca962ec444820f3aa30b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41bcbb51139cc41b96eaae6c31182a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae41bcbb51139cc41b96eaae6c31182a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_lp_pool.html">LpPool</a>, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ae41bcbb51139cc41b96eaae6c31182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233cbd96ab2aa3f1dac368f5af4776a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4233cbd96ab2aa3f1dac368f5af4776a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LSTMUnit, <a class="el" href="classcaffe2_1_1_l_s_t_m_unit_op.html">LSTMUnitOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4233cbd96ab2aa3f1dac368f5af4776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b805b430b58da15a61e93b165a723a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b805b430b58da15a61e93b165a723a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (4, 5).NumOutputs(2).SetDoc(R&quot;DOC( LSTMUnit computes the activations of a standard LSTM (without peephole connections)</td></tr>
<tr class="separator:a81b805b430b58da15a61e93b165a723a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556702783a95dfa3475ae030ec0fa82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae556702783a95dfa3475ae030ec0fa82"></a>
in a sequence length aware fashion given the previous cell and the sequence computes the LSTM avoiding computation if the input is&#160;</td><td class="memItemRight" valign="bottom"><b>invalid</b> (as in, the value at X{t][n] &gt;=seqLengths[n].) DOC&quot;) .Arg(&quot;forget_bias&quot;</td></tr>
<tr class="separator:ae556702783a95dfa3475ae030ec0fa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d1a5de72aa682f38ea6ba570466b89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4d1a5de72aa682f38ea6ba570466b89"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LSTMUnitGradient, <a class="el" href="classcaffe2_1_1_l_s_t_m_unit_gradient_op.html">LSTMUnitGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab4d1a5de72aa682f38ea6ba570466b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1b7a763f73632a332d11ed579f7361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef1b7a763f73632a332d11ed579f7361"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (8, 9).NumOutputs(3).Arg(&quot;sequence_lengths&quot;</td></tr>
<tr class="separator:aef1b7a763f73632a332d11ed579f7361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077ac830f10218a734569cd51deb4410"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a077ac830f10218a734569cd51deb4410"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LSTMUnit, <a class="el" href="classcaffe2_1_1_get_l_s_t_m_unit_gradient.html">GetLSTMUnitGradient</a>)</td></tr>
<tr class="separator:a077ac830f10218a734569cd51deb4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935a0791880f503ec8ee08fa44991230"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a935a0791880f503ec8ee08fa44991230"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (MapType64To64)</td></tr>
<tr class="separator:a935a0791880f503ec8ee08fa44991230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a404643b4e355cd537ac2b294511e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d3a404643b4e355cd537ac2b294511e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MarginRankingCriterion, <a class="el" href="classcaffe2_1_1_margin_ranking_criterion_op.html">MarginRankingCriterionOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6d3a404643b4e355cd537ac2b294511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb68f6a378891063c08d234a8677c18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb68f6a378891063c08d234a8677c18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MarginRankingCriterionGradient, <a class="el" href="classcaffe2_1_1_margin_ranking_criterion_gradient_op.html">MarginRankingCriterionGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1fb68f6a378891063c08d234a8677c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221530d69644f1bd4394db1c33e53908"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a221530d69644f1bd4394db1c33e53908"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>X2</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt;)</td></tr>
<tr class="separator:a221530d69644f1bd4394db1c33e53908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e52233068529b83316f48ac31d09be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9e52233068529b83316f48ac31d09be"></a>
and label&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; int &gt;) to produce the loss(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt;) where the loss function</td></tr>
<tr class="separator:af9e52233068529b83316f48ac31d09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96e20a3a753848fc97b32479cf08fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c96e20a3a753848fc97b32479cf08fc"></a>
and label&#160;</td><td class="memItemRight" valign="bottom"><b>loss</b> (X1, X2, Y)</td></tr>
<tr class="separator:a1c96e20a3a753848fc97b32479cf08fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a741fa9b09cc187138f4a426ab86917"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a741fa9b09cc187138f4a426ab86917"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sqr, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_sqr_c_p_u_functor.html">SqrCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a9a741fa9b09cc187138f4a426ab86917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1e25ac26049fef3df7ddae74d74430"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b1e25ac26049fef3df7ddae74d74430"></a>
Input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;Squared elements of the input&quot;)</td></tr>
<tr class="separator:a0b1e25ac26049fef3df7ddae74d74430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcb2d245e7e6b81d316fa21f29d9c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24fcb2d245e7e6b81d316fa21f29d9c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sqr, <a class="el" href="classcaffe2_1_1_get_sqr_gradient.html">GetSqrGradient</a>)</td></tr>
<tr class="separator:a24fcb2d245e7e6b81d316fa21f29d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7db41b70dd41a1fcfa5939c9116f5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a7db41b70dd41a1fcfa5939c9116f5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sign, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_sign_c_p_u_functor.html">SignCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a6a7db41b70dd41a1fcfa5939c9116f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71862c888d76ce10dd13ba7f842c8662"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71862c888d76ce10dd13ba7f842c8662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MatMul, <a class="el" href="classcaffe2_1_1_mat_mul_op.html">MatMulOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a71862c888d76ce10dd13ba7f842c8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4798b759aa7e727e9dba79fa8442be63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4798b759aa7e727e9dba79fa8442be63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (trans_a)</td></tr>
<tr class="separator:a4798b759aa7e727e9dba79fa8442be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56694d062fe35e23b4e0066303e67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a56694d062fe35e23b4e0066303e67b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (trans_b)</td></tr>
<tr class="separator:a0a56694d062fe35e23b4e0066303e67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ebf379af3fc6d0a7a0546550717ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a802ebf379af3fc6d0a7a0546550717ee"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (M)</td></tr>
<tr class="separator:a802ebf379af3fc6d0a7a0546550717ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2021ee2afe42aa981c2e83b89b685d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2021ee2afe42aa981c2e83b89b685d4"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (N)</td></tr>
<tr class="separator:ac2021ee2afe42aa981c2e83b89b685d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0b6a4783cf8b0b82e78ad19ae2de70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac0b6a4783cf8b0b82e78ad19ae2de70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Matrix multiplication Y = A * B, where A has size (M x K), B has size (K x N),
and Y will have a size (M x N).
)DOC&quot;).Input(0</td></tr>
<tr class="separator:aac0b6a4783cf8b0b82e78ad19ae2de70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e53f15e11f648a2eb242160aa87d54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e53f15e11f648a2eb242160aa87d54"></a>
matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (M x K)&quot;) .Input(1</td></tr>
<tr class="separator:a63e53f15e11f648a2eb242160aa87d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cc5552a591d1184cdb922fd126081b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1cc5552a591d1184cdb922fd126081b"></a>
matrix of matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (K x N)&quot;) .Output(0</td></tr>
<tr class="separator:af1cc5552a591d1184cdb922fd126081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea93f007b9e00ddf2b2277078595bba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea93f007b9e00ddf2b2277078595bba"></a>
matrix of matrix of matrix of Exclusive axis that divides the first and second dimension of matrix default to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis_b&quot;,&quot;Exclusive axis that divides the first and second dimension \
of matrix B, default to 1&quot;).Arg(&quot;trans_a&quot;</td></tr>
<tr class="separator:a5ea93f007b9e00ddf2b2277078595bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452acecd416b0c04009c4590da881cd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a452acecd416b0c04009c4590da881cd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MatMul, <a class="el" href="classcaffe2_1_1_get_mat_mul_gradient.html">GetMatMulGradient</a>)</td></tr>
<tr class="separator:a452acecd416b0c04009c4590da881cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab02d720682a23fd6585d9b0ac6194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3ab02d720682a23fd6585d9b0ac6194"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (MatMul, <a class="el" href="classcaffe2_1_1_mat_mul_op.html">MatMulOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad3ab02d720682a23fd6585d9b0ac6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f39d90a6f6e5308b985741ecff82c7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f39d90a6f6e5308b985741ecff82c7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Mean, <a class="el" href="classcaffe2_1_1_mean_op.html">MeanOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7f39d90a6f6e5308b985741ecff82c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de6e3acf48f74383904f288fbd5fe16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8de6e3acf48f74383904f288fbd5fe16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MeanGradient, <a class="el" href="classcaffe2_1_1_mean_gradient_op.html">MeanGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8de6e3acf48f74383904f288fbd5fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a722a0e5286d45edc1fa9c502b4c216"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a722a0e5286d45edc1fa9c502b4c216"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Element-wise mean of each of the input tensors. The first input tensor can be
used in-place as the output tensor, in which case the mean will be done in
place and results will be accumulated in input0. All inputs and outputs must
have the same shape and data type.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a5a722a0e5286d45edc1fa9c502b4c216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789cef9cbabfa13147d207a5d2d71456"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a789cef9cbabfa13147d207a5d2d71456"></a>
First of the input tensors Can be inplace&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;mean&quot;,&quot;Output tensor. Same dimension as inputs.&quot;)</td></tr>
<tr class="separator:a789cef9cbabfa13147d207a5d2d71456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0745ab798aa53d54518fe141dcc313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e0745ab798aa53d54518fe141dcc313"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Mean, <a class="el" href="classcaffe2_1_1_get_mean_gradient.html">GetMeanGradient</a>)</td></tr>
<tr class="separator:a3e0745ab798aa53d54518fe141dcc313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b700ff5275b79e6ee47b1c9d533e1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42b700ff5275b79e6ee47b1c9d533e1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxGradient, <a class="el" href="classcaffe2_1_1_max_gradient_op.html">MaxGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a42b700ff5275b79e6ee47b1c9d533e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3d39eed02e48d9f7f4be7f6b0771e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55a3d39eed02e48d9f7f4be7f6b0771e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MinGradient, <a class="el" href="classcaffe2_1_1_min_gradient_op.html">MinGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a55a3d39eed02e48d9f7f4be7f6b0771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1f67d0b6b7956e78665e29187905aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c1f67d0b6b7956e78665e29187905aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxGradient).NumInputs(3</td></tr>
<tr class="separator:a0c1f67d0b6b7956e78665e29187905aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a43f44a3cd087418865a013a312ee7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15a43f44a3cd087418865a013a312ee7"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, INT_MAX)</td></tr>
<tr class="separator:a15a43f44a3cd087418865a013a312ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f31a858fc0d60a2b0d78c52d121ff5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74f31a858fc0d60a2b0d78c52d121ff5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MinGradient).NumInputs(3</td></tr>
<tr class="separator:a74f31a858fc0d60a2b0d78c52d121ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c226db9d74ed03cb6b85db10f4519c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c226db9d74ed03cb6b85db10f4519c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Max, <a class="el" href="classcaffe2_1_1_get_max_gradient.html">GetMaxGradient</a>)</td></tr>
<tr class="separator:a9c226db9d74ed03cb6b85db10f4519c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d532ada2a3b864a2b6183c87f507861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d532ada2a3b864a2b6183c87f507861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Min, <a class="el" href="classcaffe2_1_1_get_min_gradient.html">GetMinGradient</a>)</td></tr>
<tr class="separator:a7d532ada2a3b864a2b6183c87f507861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc233420d643a3a47c38bea14d6f90a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebc233420d643a3a47c38bea14d6f90a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Max, <a class="el" href="classcaffe2_1_1_max_op.html">MaxOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aebc233420d643a3a47c38bea14d6f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc565a8b3aff1ff2ea7e134c2a744f8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc565a8b3aff1ff2ea7e134c2a744f8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Min, <a class="el" href="classcaffe2_1_1_min_op.html">MinOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acc565a8b3aff1ff2ea7e134c2a744f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683c61a99d45d137e9b86dae33f5caf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a683c61a99d45d137e9b86dae33f5caf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Element-wise max of each of the input tensors. The first input tensor can be
used in-place as the output tensor, in which case the max will be done in
place and results will be accumulated in input0. All inputs and outputs must
have the same shape and data type.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a683c61a99d45d137e9b86dae33f5caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5c5136c7d786c9932b42740d062b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a5c5136c7d786c9932b42740d062b8b"></a>
First of the input tensors Can be inplace&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;max&quot;,&quot;Output tensor. Same dimension as inputs.&quot;)</td></tr>
<tr class="separator:a2a5c5136c7d786c9932b42740d062b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6ddb1e7d4e031e1e3fdaa2a68ce7c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd6ddb1e7d4e031e1e3fdaa2a68ce7c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Element-wise min of each of the input tensors. The first input tensor can be
used in-place as the output tensor, in which case the min will be done in
place and results will be accumulated in input0. All inputs and outputs must
have the same shape and data type.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:afd6ddb1e7d4e031e1e3fdaa2a68ce7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fac6f81a5b2d3e78ef7bc8c974cba7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fac6f81a5b2d3e78ef7bc8c974cba7e"></a>
First of the input tensors Can be inplace&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;min&quot;,&quot;Output tensor. Same dimension as inputs.&quot;)</td></tr>
<tr class="separator:a9fac6f81a5b2d3e78ef7bc8c974cba7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73741e5100acaea710d5a2f66a282df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73741e5100acaea710d5a2f66a282df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MultiClassAccuracy, <a class="el" href="classcaffe2_1_1_multi_class_accuracy_op.html">MultiClassAccuracyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae73741e5100acaea710d5a2f66a282df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbc859825b4614b5341b5846a4e8890"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dbc859825b4614b5341b5846a4e8890"></a>
D float&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (N, D,) of predicted scores of each class for&quot; &quot;each data.N is the number of instances</td></tr>
<tr class="separator:a6dbc859825b4614b5341b5846a4e8890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03fcbc04ff2ed71d5734afe16528b213"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03fcbc04ff2ed71d5734afe16528b213"></a>
D float i batch size D is number of possible classes labels&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;labels&quot;,&quot;1-D int tensor (N,) of labels for each instance.&quot;).Output(0</td></tr>
<tr class="separator:a03fcbc04ff2ed71d5734afe16528b213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cc69aebdb2b17b6c067c22978a4f43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98cc69aebdb2b17b6c067c22978a4f43"></a>
D float i batch size D is number of possible classes labels D float&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (D,) of accuracy for each class.If a class has no&quot; &quot;instance in the batch</td></tr>
<tr class="separator:a98cc69aebdb2b17b6c067c22978a4f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bebaeff9482820483a8f59d2ce20a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bebaeff9482820483a8f59d2ce20a4"></a>
D float i batch size D is number of possible classes labels D float its accuracy score is set to zero&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;amounts&quot;,&quot;1-D int tensor (D,) of number of instances for each class in the batch.&quot;)</td></tr>
<tr class="separator:a07bebaeff9482820483a8f59d2ce20a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2bd7525f78337eed917c64c744995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fc2bd7525f78337eed917c64c744995"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MultiClassAccuracy)</td></tr>
<tr class="separator:a9fc2bd7525f78337eed917c64c744995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74d9ce08d54b01200e60d08738f416"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a74d9ce08d54b01200e60d08738f416"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NegateGradient, <a class="el" href="classcaffe2_1_1_negate_gradient_op.html">NegateGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a74d9ce08d54b01200e60d08738f416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca61e8187d209a1b44b9b69bb0f92b73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca61e8187d209a1b44b9b69bb0f92b73"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
NegagteGradient operator in forward pass simply copies input to the
output, and in backward pass, flips the sign of the output gradient
)DOC&quot;)</td></tr>
<tr class="separator:aca61e8187d209a1b44b9b69bb0f92b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308242536221240cfb3c23408915176e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a308242536221240cfb3c23408915176e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NegateGradient, <a class="el" href="structcaffe2_1_1_get_negate_gradient_gradient.html">GetNegateGradientGradient</a>)</td></tr>
<tr class="separator:a308242536221240cfb3c23408915176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6c52a69d194a2098b41acb41f67a33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa6c52a69d194a2098b41acb41f67a33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Negative, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float, double, int, long &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_negative_c_p_u_functor.html">NegativeCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:aaa6c52a69d194a2098b41acb41f67a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa3a02f77c61a1b5b1b7f127ca2be0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aa3a02f77c61a1b5b1b7f127ca2be0a"></a>
input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;1D input tensor&quot;)</td></tr>
<tr class="separator:a6aa3a02f77c61a1b5b1b7f127ca2be0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac173195453631efd6a218de8a6bb416a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac173195453631efd6a218de8a6bb416a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Negative, <a class="el" href="classcaffe2_1_1_get_negative_gradient.html">GetNegativeGradient</a>)</td></tr>
<tr class="separator:ac173195453631efd6a218de8a6bb416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bf32e1267f4b6f436f3c01f51b1752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57bf32e1267f4b6f436f3c01f51b1752"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NGramFromCategorical, <a class="el" href="classcaffe2_1_1_n_gram_from_categorical_op.html">NGramFromCategoricalOp</a>&lt; float, int64_t, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a57bf32e1267f4b6f436f3c01f51b1752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c58fd6a8fa1ebee21fca0a8ebe3c8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c58fd6a8fa1ebee21fca0a8ebe3c8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (NGramFromCategorical)</td></tr>
<tr class="separator:a72c58fd6a8fa1ebee21fca0a8ebe3c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac714bb28e95b298bd3f501a148bd6896"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac714bb28e95b298bd3f501a148bd6896"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (NGramFromCategorical).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:ac714bb28e95b298bd3f501a148bd6896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bda0e37849040ded81e611019e5b21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7bda0e37849040ded81e611019e5b21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NormalizeL1, <a class="el" href="classcaffe2_1_1_normalize_l1_op.html">NormalizeL1Op</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac7bda0e37849040ded81e611019e5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996da1960a88803183debe3c722f25dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a996da1960a88803183debe3c722f25dd"></a>
axis to normalize&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a matrix, apply L1-normalization along the specified axis.
)DOC&quot;)</td></tr>
<tr class="separator:a996da1960a88803183debe3c722f25dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd9d79e49c3a5064c3ee6f99033f3cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bd9d79e49c3a5064c3ee6f99033f3cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Normalize, <a class="el" href="classcaffe2_1_1_normalize_op.html">NormalizeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7bd9d79e49c3a5064c3ee6f99033f3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e55345465d459ec697cbaff5bd0110"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15e55345465d459ec697cbaff5bd0110"></a>
axis to normalize&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a matrix, apply L2-normalization along the specified dimension.
)DOC&quot;).IdenticalTypeAndShape()</td></tr>
<tr class="separator:a15e55345465d459ec697cbaff5bd0110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552fc0720d25da3121d3bfbda2c398dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a552fc0720d25da3121d3bfbda2c398dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NormalizeGradient, <a class="el" href="classcaffe2_1_1_normalize_gradient_op.html">NormalizeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a552fc0720d25da3121d3bfbda2c398dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc0f1046ef0f5ef46728f3fe5d5621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeadc0f1046ef0f5ef46728f3fe5d5621"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Normalize, <a class="el" href="classcaffe2_1_1_get_normalize_gradient.html">GetNormalizeGradient</a>)</td></tr>
<tr class="separator:aeadc0f1046ef0f5ef46728f3fe5d5621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e0c977e2e446394bd48ca32da569f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6e0c977e2e446394bd48ca32da569f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchBucketOneHot, <a class="el" href="classcaffe2_1_1_batch_bucket_one_hot_op.html">BatchBucketOneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa6e0c977e2e446394bd48ca32da569f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581ceb6d55bc4b925d4a76f6abed791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5581ceb6d55bc4b925d4a76f6abed791"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchOneHot, <a class="el" href="classcaffe2_1_1_batch_one_hot_op.html">BatchOneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5581ceb6d55bc4b925d4a76f6abed791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b518ed406ae2a637c91866b35b949a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b518ed406ae2a637c91866b35b949a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OneHot, <a class="el" href="classcaffe2_1_1_one_hot_op.html">OneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af2b518ed406ae2a637c91866b35b949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87576f4d67a3c7ce8a0c13a06a869231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87576f4d67a3c7ce8a0c13a06a869231"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentOneHot, <a class="el" href="classcaffe2_1_1_segment_one_hot_op.html">SegmentOneHotOp</a>)</td></tr>
<tr class="separator:a87576f4d67a3c7ce8a0c13a06a869231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0966ddf36b0cdaaec4a3f9fb19f01baf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0966ddf36b0cdaaec4a3f9fb19f01baf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ONNXWhile, <a class="el" href="classcaffe2_1_1_o_n_n_x_while_op.html">ONNXWhileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0966ddf36b0cdaaec4a3f9fb19f01baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633d23021135a47fdd095abc1dacebab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a633d23021135a47fdd095abc1dacebab"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
*** EXPERIMENTAL. This operator is a work-in-progress. No assumption should be
made about the stability or correctness of this op. ***

Generic Looping construct confirming to the ONNX Loop operator spec. This loop
has multiple termination conditions:

1. Trip count. Iteration count specified at runtime. Set by specifying the
    input M. Optional. Set to empty string to omit. Note that a static trip
    count (specified at graph construction time) can be specified by passing
    in a constant node for input M.
2. Loop termination condition. This is an input to the op that determines
    whether to run the first interation and also a loop-carried dependency for
    the body graph. The body graph must yield a value for the condition
    variable, whether this input is provided or not.

This table summarizes the operating modes of this operator with equivalent
C-style code:

<a class="el" href="classcaffe2_1_1_operator.html">Operator</a> inputs defined as (max_trip_count, condition_var). Omitted optional
inputs are represented as empty string. Concretely, in this caffe2 op an input
is marked as omitted by setting its 'has_{name}' argument to False.

    input (&quot;&quot;, &quot;&quot;):
        for (int i=0; ; ++i) {
          cond = ... // Note this value is ignored, but is required in the body
        }

    input (&quot;&quot;, cond) // Note this is analogous to a while loop
        bool cond = ...;
        for (int i=0; cond; ++i) {
          cond = ...;
        }

    input (&quot;&quot;, 1) // Note this is analogous to a do-while loop
        bool cond = true
        for (int i=0; cond; ++i) {
          cond = ...;
        }

    input (trip_count, &quot;&quot;) // Note this is analogous to a for loop
        int trip_count = ...
        for (int i=0; i &lt; trip_count; ++i) {
          cond = ...; // ignored
        }

    input (trip_count, cond)
        int trip_count = ...;
        bool cond = ...;
        for (int i=0; i &lt; trip_count &amp;&amp; cond; ++i) {
          cond = ...;
        }
    )DOC&quot;).Arg(&quot;loop_net&quot;</td></tr>
<tr class="separator:a633d23021135a47fdd095abc1dacebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d404cf83563a4699221ea75a819084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0d404cf83563a4699221ea75a819084"></a>
INT_MAX Net executed on each iteration&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;condition&quot;,&quot;Scalar boolean condition&quot;).AllowInplace([](int in</td></tr>
<tr class="separator:ad0d404cf83563a4699221ea75a819084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92947fc7103428f88eb5f1462c6c1c88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92947fc7103428f88eb5f1462c6c1c88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NHWC2NCHW, <a class="el" href="classcaffe2_1_1_n_h_w_c2_n_c_h_w_op.html">NHWC2NCHWOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a92947fc7103428f88eb5f1462c6c1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b43075b2d68e8b1b43712e35b9e6ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08b43075b2d68e8b1b43712e35b9e6ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NCHW2NHWC, <a class="el" href="classcaffe2_1_1_n_c_h_w2_n_h_w_c_op.html">NCHW2NHWCOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a08b43075b2d68e8b1b43712e35b9e6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb29a6a84d03b75bd36da6a80e38f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5bb29a6a84d03b75bd36da6a80e38f0"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(3))</td></tr>
<tr class="separator:ac5bb29a6a84d03b75bd36da6a80e38f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3906a56bf1823905ea60c8a63bda92ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3906a56bf1823905ea60c8a63bda92ca"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(1))</td></tr>
<tr class="separator:a3906a56bf1823905ea60c8a63bda92ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeaa79a67fecbd0ad33c2d03e1a5fd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eeaa79a67fecbd0ad33c2d03e1a5fd0"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(2))</td></tr>
<tr class="separator:a6eeaa79a67fecbd0ad33c2d03e1a5fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177cfcde485027ac42fc06f8f96b4026"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177cfcde485027ac42fc06f8f96b4026"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The operator switches the order of data in a tensor from NHWC- sample index N,
height H, width H and channels C, to the NCHW order.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a177cfcde485027ac42fc06f8f96b4026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe0bd0d6040a6dd2b132aef027620e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2efe0bd0d6040a6dd2b132aef027620e"></a>
The input&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt;) in the NHWC order.&quot;) .Output( 0</td></tr>
<tr class="separator:a2efe0bd0d6040a6dd2b132aef027620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3256eb7c57617589fd013881ad709f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3256eb7c57617589fd013881ad709f4"></a>
The input The output&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt;) in the NCHW order.&quot;)</td></tr>
<tr class="separator:ab3256eb7c57617589fd013881ad709f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826ec67a0c285332df5d7ea101546085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826ec67a0c285332df5d7ea101546085"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (NCHW2NHWC).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( The operator switches the order of data in a tensor from NCHW- sample index N</td></tr>
<tr class="separator:a826ec67a0c285332df5d7ea101546085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92cf159a915d458bafc417761fb6a2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac92cf159a915d458bafc417761fb6a2b"></a>
channels height H and width to the NHWC order DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;data&quot;,&quot;The input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) in the NCHW order.&quot;).Output(0</td></tr>
<tr class="separator:ac92cf159a915d458bafc417761fb6a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ec495208cca7f46a3a7cf2fe65c74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa46ec495208cca7f46a3a7cf2fe65c74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NHWC2NCHW, <a class="el" href="classcaffe2_1_1_get_n_h_w_c2_n_c_h_w_gradient.html">GetNHWC2NCHWGradient</a>)</td></tr>
<tr class="separator:aa46ec495208cca7f46a3a7cf2fe65c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473f8847c5a73688ae867f99668fb04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6473f8847c5a73688ae867f99668fb04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NCHW2NHWC, <a class="el" href="classcaffe2_1_1_get_n_c_h_w2_n_h_w_c_gradient.html">GetNCHW2NHWCGradient</a>)</td></tr>
<tr class="separator:a6473f8847c5a73688ae867f99668fb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f6874cc7bae3a02ea9fe8496b0d840"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76f6874cc7bae3a02ea9fe8496b0d840"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PackSegments, <a class="el" href="classcaffe2_1_1_pack_segments_op.html">PackSegmentsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a76f6874cc7bae3a02ea9fe8496b0d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af875c2b05a6e7c2c3a5f81b8efe3178f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af875c2b05a6e7c2c3a5f81b8efe3178f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UnpackSegments, <a class="el" href="classcaffe2_1_1_unpack_segments_op.html">UnpackSegmentsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af875c2b05a6e7c2c3a5f81b8efe3178f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcb07318d67d9a7270c277820cd9df1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefcb07318d67d9a7270c277820cd9df1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Map N dim tensor to N+1 dim based on length blob. Sequences that \
    are shorter than the longest sequence are padded with zeros.&quot;).Input(0</td></tr>
<tr class="separator:aefcb07318d67d9a7270c277820cd9df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ddbdf2041b52ac4fad644d8a84c142"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13ddbdf2041b52ac4fad644d8a84c142"></a>
d int long tensor contains the length in each of the output&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;tensor&quot;,&quot;N dim Tensor.&quot;).Output(0</td></tr>
<tr class="separator:a13ddbdf2041b52ac4fad644d8a84c142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc46a1c3f583346191918e4e2292a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bfc46a1c3f583346191918e4e2292a1"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> (1) is the max length&quot; &quot;</td></tr>
<tr class="separator:a9bfc46a1c3f583346191918e4e2292a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090655e96781383f208c797375a048f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0090655e96781383f208c797375a048f"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> (0) is the batch size.&quot;) .Output( 1</td></tr>
<tr class="separator:a0090655e96781383f208c797375a048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7039689a81696de9a88b8db72f94fb39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7039689a81696de9a88b8db72f94fb39"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> where dim boolean false where packed_tensor is true otherwise&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;pad_minf&quot;,&quot;Padding number in the packed segments. Use true to pad \
    -infinity, otherwise pad zeros&quot;).Arg(&quot;return_presence_mask&quot;</td></tr>
<tr class="separator:a7039689a81696de9a88b8db72f94fb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3ae04b0399d6d7e3386f3630724690"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c3ae04b0399d6d7e3386f3630724690"></a>
d int long tensor contains the length in each of the input&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;tensor&quot;,&quot;N+1 dim Tensor.&quot;).Output(0</td></tr>
<tr class="separator:a9c3ae04b0399d6d7e3386f3630724690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdfabeddd0d829f0988af5af2da65c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cdfabeddd0d829f0988af5af2da65c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PackSegments, <a class="el" href="classcaffe2_1_1_get_pack_segments_gradient.html">GetPackSegmentsGradient</a>)</td></tr>
<tr class="separator:a9cdfabeddd0d829f0988af5af2da65c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b8eaf7a8b51e5332b0dc8ceadaff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceb4b8eaf7a8b51e5332b0dc8ceadaff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (UnpackSegments, <a class="el" href="classcaffe2_1_1_get_unpack_segments_gradient.html">GetUnpackSegmentsGradient</a>)</td></tr>
<tr class="separator:aceb4b8eaf7a8b51e5332b0dc8ceadaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2af09f03e9d2413d9e2c860a3da048c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2af09f03e9d2413d9e2c860a3da048c"></a>
PadMode&#160;</td><td class="memItemRight" valign="bottom"><b>StringToPadMode</b> (const string &amp;mode)</td></tr>
<tr class="separator:ad2af09f03e9d2413d9e2c860a3da048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15517e7b5a1a5ebd97ed7196fb69f94f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15517e7b5a1a5ebd97ed7196fb69f94f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadImage, <a class="el" href="classcaffe2_1_1_pad_image_op.html">PadImageOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a15517e7b5a1a5ebd97ed7196fb69f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98fa75125dd0cc980d653687d4e17af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98fa75125dd0cc980d653687d4e17af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadImageGradient, <a class="el" href="classcaffe2_1_1_pad_image_gradient_op.html">PadImageGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab98fa75125dd0cc980d653687d4e17af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a370b1ef2396b1ff2c5721ab0de1c48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a370b1ef2396b1ff2c5721ab0de1c48"></a>
CPUContext::PadTensorInference&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
PadImage pads values around the boundary of an image according to the pad
values and stride sizes defined by the <a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a> operator.
  )DOC&quot;).Input(0</td></tr>
<tr class="separator:a3a370b1ef2396b1ff2c5721ab0de1c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f84b5447012247667b8f1414bee805"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f84b5447012247667b8f1414bee805"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the the input has&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (N x C x H x W)</td></tr>
<tr class="separator:a04f84b5447012247667b8f1414bee805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58770cbe28c91a680894739ac8b1527f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58770cbe28c91a680894739ac8b1527f"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the the input has where N is the batch C is the number of and H and W are the height and the width of the data The corresponding permutation of dimensions is used in the latter case&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;Output data tensor from padding the H and W dimensions on &quot;&quot;the tensor. Dimensions will vary based on various pad and stride &quot;&quot;sizes.&quot;)</td></tr>
<tr class="separator:a58770cbe28c91a680894739ac8b1527f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (PadImageGradient).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabfd45bcf5afac18be7162dfa9d0ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afabfd45bcf5afac18be7162dfa9d0ac3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PadImage, <a class="el" href="classcaffe2_1_1_get_pad_image_gradient.html">GetPadImageGradient</a>)</td></tr>
<tr class="separator:afabfd45bcf5afac18be7162dfa9d0ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b411f3767afb32fffa1080f9b38afa3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b411f3767afb32fffa1080f9b38afa3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Percentile, <a class="el" href="classcaffe2_1_1_percentile_op.html">PercentileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0b411f3767afb32fffa1080f9b38afa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a3eef2f3efde81d2b994fb30ad93b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12a3eef2f3efde81d2b994fb30ad93b7"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this&#160;</td><td class="memItemRight" valign="bottom"><b>operator takes as input a tensor of floats to find the percentile values for, a 2D tensor of floats, where the first column of the tensor represents sampled values, and the second column represents the percentile labels, and a tensor of integers lengths.This lengths tensor is used because the operator works on multiple sets of raw values at the same time.For example, for an input:original_values=[[3, 5, 3], [5, 1, 6]], lengths=[2, 1, 1], value_to_pct=[[3, 0.2],[5, 0.5],[1, 0.3],[3.0.6]] Our operator expects that each column i of the input tensor is sampled from distribution i.Lengths tells us that the first two elements in value_to_pct are sampled from distribution 1, the next is from distribution two, and the last is from distribution 3.We expect the output of our operator to give us[[0.2, 1.0, 0.6],[0.5, 0.3, 1.0]].To calculate the percentile of an element, we check to see if its value is already mapped to a percentile in value_to_pct.If so, we return that value.If not, we linearly interpolate between the two closest values in value_to_pct.If the value is larger than all values in value_to_pct, we return 1.If it's smaller than all the values, we return 0.) DOC&quot;) .Input</b> (0,&quot;original_values&quot;,&quot;Input 2D tensor of floats, representing the original, raw data to calculate percentiles for.&quot;).Input(1</td></tr>
<tr class="separator:a12a3eef2f3efde81d2b994fb30ad93b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b343b9a0305d399016cd967c1a92125"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b343b9a0305d399016cd967c1a92125"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this Sorted with columns Each element in the first column is a float representing the raw value of a sample Its corresponding element in the next column represents the percentile it maps to&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;lengths&quot;,&quot;1D tensor, representing the length of each distribution. We expect that the sum of elements of this tensor&quot;&quot; is equal to the total length of value_to_pct.&quot;).Output(0</td></tr>
<tr class="separator:a2b343b9a0305d399016cd967c1a92125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42ee021aa8e4e81fb4f2289192b2754"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad42ee021aa8e4e81fb4f2289192b2754"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Percentile)</td></tr>
<tr class="separator:ad42ee021aa8e4e81fb4f2289192b2754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cdcbfd982aeba7cdf0893b2f1f5a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b4cdcbfd982aeba7cdf0893b2f1f5a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Perplexity, <a class="el" href="classcaffe2_1_1_perplexity_op.html">PerplexityOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3b4cdcbfd982aeba7cdf0893b2f1f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b91551137ecac7ce6feb33a25fe23c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17b91551137ecac7ce6feb33a25fe23c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Perplexity).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( Perplexity calculates how well a probability distribution predicts a sample. Perplexity takes a 1-D tensor containing a batch of probabilities. Each value in the tensor belongs to a different sample and represents the probability of the model predicting the true label for that sample. The operator returns a single (float) perplexity value for the batch. )DOC&quot;).Input(0</td></tr>
<tr class="separator:a17b91551137ecac7ce6feb33a25fe23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959e5f76637c01917e37772b41bef30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3959e5f76637c01917e37772b41bef30"></a>
The input data as <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> It contains a batch of true label or target probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;The output- a single (float) perplexity value for the &quot;&quot;batch&quot;)</td></tr>
<tr class="separator:a3959e5f76637c01917e37772b41bef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d654419d43877e9d2478f97c220819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d654419d43877e9d2478f97c220819"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Perplexity)</td></tr>
<tr class="separator:a63d654419d43877e9d2478f97c220819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc450c1226f6ce99e5e46134b2442379"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc450c1226f6ce99e5e46134b2442379"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PiecewiseLinearTransform, <a class="el" href="classcaffe2_1_1_piecewise_linear_transform_op.html">PiecewiseLinearTransformOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adc450c1226f6ce99e5e46134b2442379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a73e145bfe9731125ef6a3290b9c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233a73e145bfe9731125ef6a3290b9c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 4).NumOutputs(1).SetDoc(R&quot;DOC( PiecewiseLinearTransform takes inputs -- predictions</td></tr>
<tr class="separator:a233a73e145bfe9731125ef6a3290b9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132380591116ed2ac218a3ad71a05f58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a132380591116ed2ac218a3ad71a05f58"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary&#160;</td><td class="memItemRight" valign="bottom"><b>predictions</b> (Nx2 or Nx1 tensor)</td></tr>
<tr class="separator:a132380591116ed2ac218a3ad71a05f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2ee1504b7b5da2d7275c3001ed0281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae2ee1504b7b5da2d7275c3001ed0281"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is&#160;</td><td class="memItemRight" valign="bottom"><b>needed</b> (see details below).-The transform parameters(bounds</td></tr>
<tr class="separator:aae2ee1504b7b5da2d7275c3001ed0281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa839f9409e00ca93677063adb8da95d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa839f9409e00ca93677063adb8da95d0"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the it is capped to the smallest or largest bound DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;bounds&quot;,&quot;1-D vector of size (prediction_dimensions x (pieces+1)) contain the &quot;&quot;upper bounds of each piece of linear function. One special case is &quot;&quot;the first bound is the lower bound of whole piecewise function and we &quot;&quot;treat it the same as the left most functions. (bounds, slopes, &quot;&quot;intercepts) can be passed through either arg or input blobs.&quot;).Arg(&quot;slopes&quot;</td></tr>
<tr class="separator:aa839f9409e00ca93677063adb8da95d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e648ed7306bd3b0b9611bccbc63655"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e648ed7306bd3b0b9611bccbc63655"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the it is capped to the smallest or largest bound DOC D vector of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (prediction_dimensions x pieces) containing the&quot; &quot;slopes of linear function&quot;) .Arg( &quot;intercepts&quot;</td></tr>
<tr class="separator:ab1e648ed7306bd3b0b9611bccbc63655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a983138aaa83cd635063465388149d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a983138aaa83cd635063465388149d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePoolGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a3a983138aaa83cd635063465388149d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e2194022fa086582f7482cf90be08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a588e2194022fa086582f7482cf90be08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a588e2194022fa086582f7482cf90be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7185b96dc45dc5dd140b5d64d2e408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7185b96dc45dc5dd140b5d64d2e408"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool1DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a6c7185b96dc45dc5dd140b5d64d2e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f77a2198a9ab1eb4502ef3d16c2f40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7f77a2198a9ab1eb4502ef3d16c2f40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool1DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ae7f77a2198a9ab1eb4502ef3d16c2f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9334327b6fd9b880d6d1a2e1beee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4f9334327b6fd9b880d6d1a2e1beee1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool2DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:ab4f9334327b6fd9b880d6d1a2e1beee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2168d639116e0d1649c1ef157cb2418f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2168d639116e0d1649c1ef157cb2418f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool2DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a2168d639116e0d1649c1ef157cb2418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd55e370a5e4b40b6e7df890daed1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dbd55e370a5e4b40b6e7df890daed1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool3DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a8dbd55e370a5e4b40b6e7df890daed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea9ef7f8abe4a1e39be24269257ccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0ea9ef7f8abe4a1e39be24269257ccb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool3DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ab0ea9ef7f8abe4a1e39be24269257ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7b769f27f271bba0d44ff38679992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d7b769f27f271bba0d44ff38679992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPoolGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:af6d7b769f27f271bba0d44ff38679992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51c26b383feb3ebd03cf5e4e8ab379d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af51c26b383feb3ebd03cf5e4e8ab379d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af51c26b383feb3ebd03cf5e4e8ab379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8032c63297df7b003b5a11eae1e967"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a8032c63297df7b003b5a11eae1e967"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool1DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a5a8032c63297df7b003b5a11eae1e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bf8ecae4818d45fc794429c8e34b93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67bf8ecae4818d45fc794429c8e34b93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool1DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a67bf8ecae4818d45fc794429c8e34b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d2effb6608170f07c960555aca060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a188d2effb6608170f07c960555aca060"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool2DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a188d2effb6608170f07c960555aca060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdef69d939d16f9337ca4cf1f106bbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bdef69d939d16f9337ca4cf1f106bbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool2DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a1bdef69d939d16f9337ca4cf1f106bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfc54e93574ce6b5e9a45911f18c85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05dfc54e93574ce6b5e9a45911f18c85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool3DGradient, <a class="el" href="classcaffe2_1_1_pool_gradient_op.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a05dfc54e93574ce6b5e9a45911f18c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93ac8a4382768cc2511c81344854d02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93ac8a4382768cc2511c81344854d02"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool3DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ae93ac8a4382768cc2511c81344854d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4226d56a6213572c7988e55cd1f6de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4226d56a6213572c7988e55cd1f6de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:adc4226d56a6213572c7988e55cd1f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aae647d6c84627cc840be61fdf823b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97aae647d6c84627cc840be61fdf823b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool1D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a97aae647d6c84627cc840be61fdf823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a554f3ca4d4714256f3c373af1e11f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1a554f3ca4d4714256f3c373af1e11f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool2D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:af1a554f3ca4d4714256f3c373af1e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb76fffa78fd438c0fe1af0e0176d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5bb76fffa78fd438c0fe1af0e0176d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool3D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ab5bb76fffa78fd438c0fe1af0e0176d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e163b376d2fb7de32f7da191e3ab229"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e163b376d2fb7de32f7da191e3ab229"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a7e163b376d2fb7de32f7da191e3ab229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc4a60c9bf1d52880be12e2ecc2509"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17fc4a60c9bf1d52880be12e2ecc2509"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool1D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a17fc4a60c9bf1d52880be12e2ecc2509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1aaa9d4ff6886c2071b36f7b73841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0a1aaa9d4ff6886c2071b36f7b73841"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool2D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ac0a1aaa9d4ff6886c2071b36f7b73841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10c955e7d5d7c2869698bdcc7e0a141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af10c955e7d5d7c2869698bdcc7e0a141"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool3D, <a class="el" href="classcaffe2_1_1_get_pool_gradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:af10c955e7d5d7c2869698bdcc7e0a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c465b386eeb12caabd612a2f3da9b81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c465b386eeb12caabd612a2f3da9b81"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AveragePoolDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a1c465b386eeb12caabd612a2f3da9b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5813eb9fe43aa4c9ba4d319da95805ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5813eb9fe43aa4c9ba4d319da95805ef"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1_op_schema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MaxPoolDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a5813eb9fe43aa4c9ba4d319da95805ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d95c52309f93f7c03ebf623d536ab3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74d95c52309f93f7c03ebf623d536ab3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a74d95c52309f93f7c03ebf623d536ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf295f707082e03bf3f3ec7e60c300c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf295f707082e03bf3f3ec7e60c300c6"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool1D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:abf295f707082e03bf3f3ec7e60c300c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f82f8490a15449b06589d117667204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3f82f8490a15449b06589d117667204"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool2D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:ae3f82f8490a15449b06589d117667204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b031f6ed43efb3a89eb8b3acae011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840b031f6ed43efb3a89eb8b3acae011"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool3D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a840b031f6ed43efb3a89eb8b3acae011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0675b41cf8043e1eb4aeb3df482555"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf0675b41cf8043e1eb4aeb3df482555"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:abf0675b41cf8043e1eb4aeb3df482555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3678b83690eb2b0586d64bdf90d51496"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3678b83690eb2b0586d64bdf90d51496"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool1D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a3678b83690eb2b0586d64bdf90d51496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fc729f84d0fa2cf1f18dd4e7e5c6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a987fc729f84d0fa2cf1f18dd4e7e5c6f"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool2D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a987fc729f84d0fa2cf1f18dd4e7e5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9998dcc0fdc07b2afa293b1d8911f43c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9998dcc0fdc07b2afa293b1d8911f43c"></a>
NumInputs(1).NumOutputs(1).TensorInferenceFunction(<a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool3D, <a class="el" href="classcaffe2_1_1_pool_op.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a9998dcc0fdc07b2afa293b1d8911f43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675895d042aa981cffa018ac9ccf519b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675895d042aa981cffa018ac9ccf519b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Pow, <a class="el" href="classcaffe2_1_1_pow_op.html">PowOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_eigen_pow_functor.html">EigenPowFunctor</a>, <a class="el" href="structcaffe2_1_1_same_type_as_input.html">SameTypeAsInput</a> &gt;).NumInputs(1</td></tr>
<tr class="separator:a675895d042aa981cffa018ac9ccf519b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53172da9ec90ca49ea4ffc41ac7010e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad53172da9ec90ca49ea4ffc41ac7010e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1).Arg(&quot;exponent&quot;</td></tr>
<tr class="separator:ad53172da9ec90ca49ea4ffc41ac7010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458ed24e64fa02b3f92f618907a3981b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a458ed24e64fa02b3f92f618907a3981b"></a>
The exponent of the power function&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{0, 0},{1, 0}}).IdenticalTypeAndShapeOfInput(0).SetDoc(R&quot;DOC( Pow takes input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) and an argument exponent</td></tr>
<tr class="separator:a458ed24e64fa02b3f92f618907a3981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519015529c49ba9edba9b9afcf109a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae519015529c49ba9edba9b9afcf109a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PRelu, <a class="el" href="classcaffe2_1_1_p_relu_op.html">PReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae519015529c49ba9edba9b9afcf109a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3599f81fae89f3efaa9155d9b764dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c3599f81fae89f3efaa9155d9b764dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PReluGradient, <a class="el" href="classcaffe2_1_1_p_relu_gradient_op.html">PReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9c3599f81fae89f3efaa9155d9b764dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1d9282174179e72e3b4618e19503a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d1d9282174179e72e3b4618e19503a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (PReluGradient).NumInputs(4).NumOutputs(2).SetDoc(R&quot;DOC( PReluGradient takes both Y and dY and uses this to update dX and dW according to the chain rule and derivatives of the rectified linear function. )DOC&quot;)</td></tr>
<tr class="separator:a99d1d9282174179e72e3b4618e19503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086afa020de70cef3cba3e02c291d870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a086afa020de70cef3cba3e02c291d870"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PRelu, <a class="el" href="classcaffe2_1_1_get_p_relu_gradient.html">GetPReluGradient</a>)</td></tr>
<tr class="separator:a086afa020de70cef3cba3e02c291d870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172cf6c8bb4ccdab15e468b80388fc38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172cf6c8bb4ccdab15e468b80388fc38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PrependDim, <a class="el" href="classcaffe2_1_1_prepend_dim_op.html">PrependDimOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a172cf6c8bb4ccdab15e468b80388fc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7888791d15ee3ce8aa591ef922e8e05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7888791d15ee3ce8aa591ef922e8e05b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MergeDim, <a class="el" href="classcaffe2_1_1_merge_dim_op.html">MergeDimOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7888791d15ee3ce8aa591ef922e8e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552edd379cd773b36d42607c8c1184d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a552edd379cd773b36d42607c8c1184d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reshape the tensor by prepending a dimension of fixed size and dividing the
size of the next dimension by that amount.
)DOC&quot;).Arg(&quot;dim_size&quot;</td></tr>
<tr class="separator:a552edd379cd773b36d42607c8c1184d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e2de9adfdf02535b723678e6e61c59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e2de9adfdf02535b723678e6e61c59"></a>
Size of the dimension to prepend&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;data&quot;,&quot;An input tensor.&quot;).Output(0</td></tr>
<tr class="separator:a29e2de9adfdf02535b723678e6e61c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa39b62274ae8c5eecc075b2d29b82c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa39b62274ae8c5eecc075b2d29b82c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Merge first two dimensions in a single dimension with size dim(0) * dim(1).
)DOC&quot;).Input(0</td></tr>
<tr class="separator:aaa39b62274ae8c5eecc075b2d29b82c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62be62fcc6c42ec30bacf3ad11bf9253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62be62fcc6c42ec30bacf3ad11bf9253"></a>
An input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;reshaped&quot;,&quot;Reshaped tensor.&quot;)</td></tr>
<tr class="separator:a62be62fcc6c42ec30bacf3ad11bf9253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36531a3054c60c1b16fc40150b08aae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac36531a3054c60c1b16fc40150b08aae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PrependDim, <a class="el" href="classcaffe2_1_1_get_prepend_dim_gradient.html">GetPrependDimGradient</a>)</td></tr>
<tr class="separator:ac36531a3054c60c1b16fc40150b08aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3258a81ad064d50d0deda05b001a002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3258a81ad064d50d0deda05b001a002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (PrependDim, <a class="el" href="classcaffe2_1_1_prepend_dim_op.html">PrependDimOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad3258a81ad064d50d0deda05b001a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc671ac6dd953c08ba8a1020b119753b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc671ac6dd953c08ba8a1020b119753b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (MergeDim, <a class="el" href="classcaffe2_1_1_merge_dim_op.html">MergeDimOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adc671ac6dd953c08ba8a1020b119753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f06fe45c8edaeaf575855649fe12d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f06fe45c8edaeaf575855649fe12d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecode, <a class="el" href="classcaffe2_1_1_quant_decode_op.html">QuantDecodeOp</a>&lt; QuantDecodeRunTy::RUN_ALWAYS &gt;)</td></tr>
<tr class="separator:a58f06fe45c8edaeaf575855649fe12d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487dd141d82f2fda0f17f52d1631c955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a487dd141d82f2fda0f17f52d1631c955"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecodeGradient, <a class="el" href="classcaffe2_1_1_quant_decode_gradient_op.html">QuantDecodeGradientOp</a>)</td></tr>
<tr class="separator:a487dd141d82f2fda0f17f52d1631c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f18da68fe856b465261495e1c3d156"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f18da68fe856b465261495e1c3d156"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetworkBlobFetcher, <a class="el" href="classcaffe2_1_1_recurrent_network_blob_fetcher_op.html">RecurrentNetworkBlobFetcherOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad9f18da68fe856b465261495e1c3d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4955b328bef2d421be2e834b2eb865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e4955b328bef2d421be2e834b2eb865"></a>
Prefix string to prepend extracted blobs&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;ScratchWorkspaceBlob&quot;,&quot;Name of scratch workspace blob returned by recurrent network.&quot;).Output(0</td></tr>
<tr class="separator:a5e4955b328bef2d421be2e834b2eb865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9839977af794578804bb99724f69db55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9839977af794578804bb99724f69db55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RecurrentNetworkBlobFetcher)</td></tr>
<tr class="separator:a9839977af794578804bb99724f69db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07e42c9acb1494e637f6b6489d842b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd07e42c9acb1494e637f6b6489d842b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RecurrentNetworkBlobFetcher, <a class="el" href="classcaffe2_1_1_recurrent_network_blob_fetcher_op.html">RecurrentNetworkBlobFetcherOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:afd07e42c9acb1494e637f6b6489d842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af626e8bd4defd97004472e4618071467"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af626e8bd4defd97004472e4618071467"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_recurrent_network_executor_base.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af626e8bd4defd97004472e4618071467">createRNNExecutor&lt; CPUContext &gt;</a> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> rnn_args)</td></tr>
<tr class="memdesc:af626e8bd4defd97004472e4618071467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of RecurrentNetworkExecutor that uses thread pool for multithreaded execution of RNNs.  <a href="#af626e8bd4defd97004472e4618071467">More...</a><br /></td></tr>
<tr class="separator:af626e8bd4defd97004472e4618071467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41508631ed84d5827070d1d204621b45"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41508631ed84d5827070d1d204621b45"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a41508631ed84d5827070d1d204621b45"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_recurrent_network_executor_base.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createRNNExecutor</b> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> rnn_args)</td></tr>
<tr class="separator:a41508631ed84d5827070d1d204621b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ea3a6c453620aaf4bc05db9979b8f2b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_recurrent_network_executor_base.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createRNNExecutor&lt; CUDAContext &gt;</b> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> arg_helper)</td></tr>
<tr class="separator:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2440d0d739a8ff7780ca788a0e9c6fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2440d0d739a8ff7780ca788a0e9c6fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="structcaffe2_1_1detail_1_1_scratch_workspaces.html">detail::ScratchWorkspaces</a>)</td></tr>
<tr class="separator:ad2440d0d739a8ff7780ca788a0e9c6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4e5e322c97dfc904b690f67b3a7ed4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e4e5e322c97dfc904b690f67b3a7ed4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetwork, <a class="el" href="classcaffe2_1_1_recurrent_network_op.html">RecurrentNetworkOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1e4e5e322c97dfc904b690f67b3a7ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f20ebf7a9f4b7d043508e628d578bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7f20ebf7a9f4b7d043508e628d578bd"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Run the input network in a recurrent fashion. This can be used to
implement fairly general recurrent neural networks (RNNs).

The operator proceeds as follows.

- First, initialized the states from the input recurrent states
- For each timestep T, apply the links (that map offsets from input/output
tensors into the inputs/outputs for the `step` network)
- Finally, alias the recurrent states to the specified output blobs.

This is a fairly special-case meta-operator, and so the implementation
is somewhat complex. It trades of generality (and frankly usability)
against performance and control (compared to e.g. TF
dynamic_rnn, Theano scan, etc).

See the usage examples for a flavor of how to use it.
)DOC&quot;)</td></tr>
<tr class="separator:ac7f20ebf7a9f4b7d043508e628d578bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3072d167ef5ca0c7db265ef083e6a5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3072d167ef5ca0c7db265ef083e6a5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetworkGradient, <a class="el" href="classcaffe2_1_1_recurrent_network_gradient_op.html">RecurrentNetworkGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af3072d167ef5ca0c7db265ef083e6a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1ac23d3f7602f3d04576798ec8736b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1ac23d3f7602f3d04576798ec8736b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (RecurrentNetworkGradient)</td></tr>
<tr class="separator:a7b1ac23d3f7602f3d04576798ec8736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e7a17169132702eab06cd99f41083c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e7a17169132702eab06cd99f41083c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (rnn_internal_accumulate_gradient_input, <a class="el" href="classcaffe2_1_1_accumulate_input_gradient_op.html">AccumulateInputGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a60e7a17169132702eab06cd99f41083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122355b1a16b247872c691033387bde6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a122355b1a16b247872c691033387bde6"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{2, 0}}).Private().SetDoc(R&quot;DOC( Internal RNN operator. )DOC&quot;)</td></tr>
<tr class="separator:a122355b1a16b247872c691033387bde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3b03cb18e129bd217ab2a049529add"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a3b03cb18e129bd217ab2a049529add"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (rnn_internal_apply_link, <a class="el" href="classcaffe2_1_1_r_n_n_apply_link_op.html">RNNApplyLinkOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5a3b03cb18e129bd217ab2a049529add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bac68523a2edaa6d77434877f9f504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9bac68523a2edaa6d77434877f9f504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Private</b> ().SetDoc(R&quot;DOC( Internal RNN operator. )DOC&quot;)</td></tr>
<tr class="separator:ad9bac68523a2edaa6d77434877f9f504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ca4e0250dfc68055be3726ad3322b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f3ca4e0250dfc68055be3726ad3322b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RecurrentNetwork, <a class="el" href="structcaffe2_1_1_get_recurrent_network_gradient.html">GetRecurrentNetworkGradient</a>)</td></tr>
<tr class="separator:a9f3ca4e0250dfc68055be3726ad3322b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912783262e703e193dcd0a6961569055"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a912783262e703e193dcd0a6961569055"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Recurrent, <a class="el" href="classcaffe2_1_1_recurrent_op.html">RecurrentOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a912783262e703e193dcd0a6961569055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009f0878a4ce0b5c4278150e3e1c639"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9009f0878a4ce0b5c4278150e3e1c639"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Recurrent).NumInputs(4).NumOutputs(5).SetDoc(R&quot;DOC( Recurrent wraps the CuDNN R5 RNN implementation. See the CuDNN R5 documentation for more information. In general</td></tr>
<tr class="separator:a9009f0878a4ce0b5c4278150e3e1c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad641a8ec93c63bf32de0f552aeec1c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad641a8ec93c63bf32de0f552aeec1c87"></a>
the implementation takes an&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (TxNxD) tensor</td></tr>
<tr class="separator:ad641a8ec93c63bf32de0f552aeec1c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49f4bd63db29f2344f61892e922a5f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa49f4bd63db29f2344f61892e922a5f8"></a>
the implementation takes an the hidden state&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (NxD)</td></tr>
<tr class="separator:aa49f4bd63db29f2344f61892e922a5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ea117f2274758ce3e6d8e8c36a420c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76ea117f2274758ce3e6d8e8c36a420c"></a>
the implementation takes an the hidden state the cell and a weight&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (effectively an opaque blob, where the size and layout is dictated by CuDNN).The outputs are the output(again</td></tr>
<tr class="separator:a76ea117f2274758ce3e6d8e8c36a420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5cd275fcfa21ebde9feaabceea717c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f5cd275fcfa21ebde9feaabceea717c"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>states</b> (NxD).These can be reset(at sequence boundaries across minibatches) by multiplying by zero.The CuDNN arguments(hidden_size</td></tr>
<tr class="separator:a7f5cd275fcfa21ebde9feaabceea717c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43040ba9ca5c850af8a6bfae5ba33446"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43040ba9ca5c850af8a6bfae5ba33446"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentGradient, <a class="el" href="classcaffe2_1_1_recurrent_gradient_op.html">RecurrentGradientOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a43040ba9ca5c850af8a6bfae5ba33446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e6ac81e8902d9e9d6a48eb5f0a7e9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4e6ac81e8902d9e9d6a48eb5f0a7e9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (7).NumOutputs(6).AllowInplace(</td></tr>
<tr class="separator:af4e6ac81e8902d9e9d6a48eb5f0a7e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b4e71b179d2b7110046d646a4913b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad63b4e71b179d2b7110046d646a4913b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentParamSet, <a class="el" href="classcaffe2_1_1_recurrent_param_access_op.html">RecurrentParamAccessOp</a>&lt; float, SET_PARAM &gt;)</td></tr>
<tr class="separator:ad63b4e71b179d2b7110046d646a4913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e34f7c76611f9cb71ac58ace79cec17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e34f7c76611f9cb71ac58ace79cec17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Set individual parameters of a recurrent net.&quot;).Arg(&quot;param_type&quot;</td></tr>
<tr class="separator:a8e34f7c76611f9cb71ac58ace79cec17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25895797aeae6de8161aaedbb06e44d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25895797aeae6de8161aaedbb06e44d2"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b> (Type of param to be set:&quot;input_gate_w&quot;,&quot;forget_gate_w&quot;,&quot;cell_w&quot;,&quot;output_gate_w&quot;&quot;input_gate_b&quot;,&quot;forget_gate_b&quot;,&quot;cell_b&quot;,&quot;output_gate_b&quot;) DOC&quot;) .Arg(&quot;input_type&quot;</td></tr>
<tr class="separator:a25895797aeae6de8161aaedbb06e44d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5a4d2eefc0b0ebc6a59c4fb6965f15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e5a4d2eefc0b0ebc6a59c4fb6965f15"></a>
R recurrent or input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;layer&quot;,&quot;layer index (starting from 0)&quot;).Input(0</td></tr>
<tr class="separator:a1e5a4d2eefc0b0ebc6a59c4fb6965f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8296acd052e5c2f3130bf3a3f9031a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8296acd052e5c2f3130bf3a3f9031a46"></a>
R recurrent or input R&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b> (Input blob.Needed for inferring the shapes.A dummy tensor matching the input shape is ok.) DOC&quot;) .Input(1</td></tr>
<tr class="separator:a8296acd052e5c2f3130bf3a3f9031a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd648a0c5fc20affdb53b3c36cba0201"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd648a0c5fc20affdb53b3c36cba0201"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> holding all the parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;param&quot;,&quot;Values for the specified parameter&quot;).Output(0</td></tr>
<tr class="separator:abd648a0c5fc20affdb53b3c36cba0201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f749bf3fab03c4b1604a866d40a6202"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f749bf3fab03c4b1604a866d40a6202"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> holding all the parameters <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> holding all the&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b> (same as input(1))&quot;)</td></tr>
<tr class="separator:a1f749bf3fab03c4b1604a866d40a6202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd748f8781f46aa04974d549c5501b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cd748f8781f46aa04974d549c5501b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentParamGet, <a class="el" href="classcaffe2_1_1_recurrent_param_access_op.html">RecurrentParamAccessOp</a>&lt; float, GET_PARAM &gt;)</td></tr>
<tr class="separator:a0cd748f8781f46aa04974d549c5501b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61289012b80f52b2b2c58fd9c3aae241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61289012b80f52b2b2c58fd9c3aae241"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> holding all the parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;param&quot;,&quot;<a class="el" href="classcaffe2_1_1_blob.html">Blob</a> holding the requested values&quot;)</td></tr>
<tr class="separator:a61289012b80f52b2b2c58fd9c3aae241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620fcbf44947b5e8e7b6aa94843a479d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a620fcbf44947b5e8e7b6aa94843a479d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Recurrent, <a class="el" href="structcaffe2_1_1_get_recurrent_gradient.html">GetRecurrentGradient</a>)</td></tr>
<tr class="separator:a620fcbf44947b5e8e7b6aa94843a479d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b5dba8b06a474f736631f78ca3b77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a943b5dba8b06a474f736631f78ca3b77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontSum, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_op.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true, false &gt;)</td></tr>
<tr class="separator:a943b5dba8b06a474f736631f78ca3b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cae50e8868524aa652487bdbddb34c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74cae50e8868524aa652487bdbddb34c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontSumGradient, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_gradient_op.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true, false &gt;)</td></tr>
<tr class="separator:a74cae50e8868524aa652487bdbddb34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa63b38160fa88432cf89e19d35d5158"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa63b38160fa88432cf89e19d35d5158"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontSum, <a class="el" href="classcaffe2_1_1_get_reduce_front_sum_gradient.html">GetReduceFrontSumGradient</a>)</td></tr>
<tr class="separator:afa63b38160fa88432cf89e19d35d5158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461180cd1ece4b4e934ab89cb67101ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a461180cd1ece4b4e934ab89cb67101ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackSum, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_op.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false, false &gt;)</td></tr>
<tr class="separator:a461180cd1ece4b4e934ab89cb67101ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf19504c08e225f1216d8efd39c1580"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcf19504c08e225f1216d8efd39c1580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackSumGradient, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_gradient_op.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false, false &gt;)</td></tr>
<tr class="separator:afcf19504c08e225f1216d8efd39c1580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf18ca8ca4422f8813c2e004b56badf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf18ca8ca4422f8813c2e004b56badf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackSum, <a class="el" href="classcaffe2_1_1_get_reduce_back_sum_gradient.html">GetReduceBackSumGradient</a>)</td></tr>
<tr class="separator:acbf18ca8ca4422f8813c2e004b56badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae190efacf6695e69d764dac5cd6007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae190efacf6695e69d764dac5cd6007"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the first dimension of the input
tensor by applying 'Sum'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:acae190efacf6695e69d764dac5cd6007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a58264bb40fc4b27c9aec7f9732e2d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a58264bb40fc4b27c9aec7f9732e2d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontSumGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a8a58264bb40fc4b27c9aec7f9732e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac335e9dd430108d1f0e7ee35c550b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac335e9dd430108d1f0e7ee35c550b9"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the last dimension of the
input tensor by applying 'Sum'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a7ac335e9dd430108d1f0e7ee35c550b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeabe746137ba44ac37c426cec413f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eeabe746137ba44ac37c426cec413f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackSumGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a7eeabe746137ba44ac37c426cec413f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9583603fed1bf04f85e3e8f9bdcb77a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9583603fed1bf04f85e3e8f9bdcb77a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMean, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_op.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true, true &gt;)</td></tr>
<tr class="separator:ac9583603fed1bf04f85e3e8f9bdcb77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d75f2b4c4c21fa0931f7ccb3fc41e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39d75f2b4c4c21fa0931f7ccb3fc41e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMeanGradient, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_gradient_op.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true, true &gt;)</td></tr>
<tr class="separator:a39d75f2b4c4c21fa0931f7ccb3fc41e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe10cbb7b5f5e42e3c1e1497bdfe0f34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe10cbb7b5f5e42e3c1e1497bdfe0f34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontMean, <a class="el" href="classcaffe2_1_1_get_reduce_front_mean_gradient.html">GetReduceFrontMeanGradient</a>)</td></tr>
<tr class="separator:abe10cbb7b5f5e42e3c1e1497bdfe0f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab469953ffa522a35c91406c17d8adf44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab469953ffa522a35c91406c17d8adf44"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the first dimension of the input
tensor by applying 'Mean'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:ab469953ffa522a35c91406c17d8adf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf80f72400b359c840622a040f36d68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf80f72400b359c840622a040f36d68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontMeanGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a8cf80f72400b359c840622a040f36d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac80a72437b9367a546c067b14280097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac80a72437b9367a546c067b14280097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMean, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_op.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false, true &gt;)</td></tr>
<tr class="separator:aac80a72437b9367a546c067b14280097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f526ab11c67af5b26d99074b3cd1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451f526ab11c67af5b26d99074b3cd1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMeanGradient, <a class="el" href="classcaffe2_1_1_sum_reduce_dims_gradient_op.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false, true &gt;)</td></tr>
<tr class="separator:a451f526ab11c67af5b26d99074b3cd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114f3254d4db8752ebef20359b59ad4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8114f3254d4db8752ebef20359b59ad4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackMean, <a class="el" href="classcaffe2_1_1_get_reduce_back_mean_gradient.html">GetReduceBackMeanGradient</a>)</td></tr>
<tr class="separator:a8114f3254d4db8752ebef20359b59ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffc115a7f920c23f3dfd18913188174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ffc115a7f920c23f3dfd18913188174"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the last dimension of the
input tensor by applying 'Mean'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a6ffc115a7f920c23f3dfd18913188174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb70f9d66a3e7d7fb90db5f903d2982b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb70f9d66a3e7d7fb90db5f903d2982b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMeanGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:afb70f9d66a3e7d7fb90db5f903d2982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed56e9829c1e22e77294b665ebbf64a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afed56e9829c1e22e77294b665ebbf64a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMax, <a class="el" href="classcaffe2_1_1_max_reduce_dims_op.html">MaxReduceDimsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:afed56e9829c1e22e77294b665ebbf64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6f0b1d121e5ac581fb97c4e4777883"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd6f0b1d121e5ac581fb97c4e4777883"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMaxGradient, <a class="el" href="classcaffe2_1_1_max_reduce_dims_gradient_op.html">MaxReduceDimsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:abd6f0b1d121e5ac581fb97c4e4777883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b28b92857aaa543768789079152c90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9b28b92857aaa543768789079152c90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMax, <a class="el" href="classcaffe2_1_1_max_reduce_dims_op.html">MaxReduceDimsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:ab9b28b92857aaa543768789079152c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af911cd29d47410ecfef1b45357f510b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af911cd29d47410ecfef1b45357f510b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMaxGradient, <a class="el" href="classcaffe2_1_1_max_reduce_dims_gradient_op.html">MaxReduceDimsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:af911cd29d47410ecfef1b45357f510b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04349cba64700b565d65eec0b9305255"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04349cba64700b565d65eec0b9305255"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontMax, <a class="el" href="classcaffe2_1_1_get_reduce_front_max_gradient.html">GetReduceFrontMaxGradient</a>)</td></tr>
<tr class="separator:a04349cba64700b565d65eec0b9305255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf96ee5953a075f8a573fda63fc280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92bf96ee5953a075f8a573fda63fc280"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackMax, <a class="el" href="classcaffe2_1_1_get_reduce_back_max_gradient.html">GetReduceBackMaxGradient</a>)</td></tr>
<tr class="separator:a92bf96ee5953a075f8a573fda63fc280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9960f8b8cdafbc058a99e6fab135b92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9960f8b8cdafbc058a99e6fab135b92"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the first dimension of the input
tensor by applying 'Max'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:ae9960f8b8cdafbc058a99e6fab135b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca78a46214042913c52193473f088dc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca78a46214042913c52193473f088dc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:aca78a46214042913c52193473f088dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52013b117d756434028017dabf14373a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52013b117d756434028017dabf14373a"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reduces the input tensor along the last dimension of the
input tensor by applying 'Max'
)DOC&quot;).TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a52013b117d756434028017dabf14373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84b91040d8030b7c034ad88b5ce1fe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af84b91040d8030b7c034ad88b5ce1fe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af84b91040d8030b7c034ad88b5ce1fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2303e6bcba9a25f5d4e40f0e0d37e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd2303e6bcba9a25f5d4e40f0e0d37e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumElements, <a class="el" href="classcaffe2_1_1_sum_elements_op.html">SumElementsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acd2303e6bcba9a25f5d4e40f0e0d37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3017fdecf785e6677b54593cda09493f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3017fdecf785e6677b54593cda09493f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumSqrElements, <a class="el" href="classcaffe2_1_1_sum_sqr_elements_op.html">SumSqrElementsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3017fdecf785e6677b54593cda09493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac770f9cadd4711ad89994d241513d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afac770f9cadd4711ad89994d241513d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumElementsGradient, <a class="el" href="classcaffe2_1_1_sum_elements_gradient_op.html">SumElementsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afac770f9cadd4711ad89994d241513d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6f98d15795ab4e4cbf06dc49f43b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0a6f98d15795ab4e4cbf06dc49f43b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowwiseMax, <a class="el" href="classcaffe2_1_1_max_reduction_op.html">MaxReductionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:ac0a6f98d15795ab4e4cbf06dc49f43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee608cdef2e782d2f3e15b6113d3460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acee608cdef2e782d2f3e15b6113d3460"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowwiseMaxGradient, <a class="el" href="classcaffe2_1_1_max_reduction_gradient_op.html">MaxReductionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:acee608cdef2e782d2f3e15b6113d3460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4ced6c7fd61912a48b445cdca3eea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f4ced6c7fd61912a48b445cdca3eea4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ColwiseMaxGradient, <a class="el" href="classcaffe2_1_1_max_reduction_gradient_op.html">MaxReductionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:a7f4ced6c7fd61912a48b445cdca3eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e56d0f06246205e192cf67e4eb53a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e56d0f06246205e192cf67e4eb53a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ColwiseMax, <a class="el" href="classcaffe2_1_1_max_reduction_op.html">MaxReductionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:aa9e56d0f06246205e192cf67e4eb53a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100c95cce157d007143a4e4f1c58b155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a100c95cce157d007143a4e4f1c58b155"></a>
NumInputs(1).NumOutputs(1).ScalarType(TensorProto NumInputs(1).NumOutputs(1).ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SumElementsGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a100c95cce157d007143a4e4f1c58b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e074e59057ba20c9305753de6fe1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a710e074e59057ba20c9305753de6fe1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SumElements, <a class="el" href="classcaffe2_1_1_get_sum_elements_gradient.html">GetSumElementsGradient</a>)</td></tr>
<tr class="separator:a710e074e59057ba20c9305753de6fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f7d8e46051e9f3ec641f6e12330bdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3f7d8e46051e9f3ec641f6e12330bdb"></a>
A tenosr of dimensions batch_size x M x N to compute rowwise max&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;batch_size x M rowwise-max results matrix.&quot;)</td></tr>
<tr class="separator:ae3f7d8e46051e9f3ec641f6e12330bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58baaf4bf8729ec47290a5773fc269f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58baaf4bf8729ec47290a5773fc269f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (RowwiseMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a58baaf4bf8729ec47290a5773fc269f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e10141cd65f91df02338c5a2e612a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4e10141cd65f91df02338c5a2e612a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RowwiseMax, <a class="el" href="classcaffe2_1_1_get_rowwise_max_gradient.html">GetRowwiseMaxGradient</a>)</td></tr>
<tr class="separator:ae4e10141cd65f91df02338c5a2e612a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa615559f7cfe8a100f24ec2f5f43a42f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa615559f7cfe8a100f24ec2f5f43a42f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ColwiseMaxGradient)</td></tr>
<tr class="separator:aa615559f7cfe8a100f24ec2f5f43a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c64d4cac39458e6e52fb021363c86e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1c64d4cac39458e6e52fb021363c86e"></a>
A tenosr of dimensions batch_size x M x N to compute colwise max&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;batch_size x N column-max results matrix.&quot;)</td></tr>
<tr class="separator:ab1c64d4cac39458e6e52fb021363c86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc860d6eb5d2649bbe8a4bef24b7da9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc860d6eb5d2649bbe8a4bef24b7da9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ColumnMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a9cc860d6eb5d2649bbe8a4bef24b7da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90076a90342560207e94c80c8efcdf86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90076a90342560207e94c80c8efcdf86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ColwiseMax, <a class="el" href="classcaffe2_1_1_get_colwise_max_gradient.html">GetColwiseMaxGradient</a>)</td></tr>
<tr class="separator:a90076a90342560207e94c80c8efcdf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c9a2f38b64d7e92fd298625111357e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c9a2f38b64d7e92fd298625111357e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Relu, <a class="el" href="classcaffe2_1_1_relu_op.html">ReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad4c9a2f38b64d7e92fd298625111357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e9e65f91c86d22430f7000e5dd6df7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8e9e65f91c86d22430f7000e5dd6df7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReluGradient, <a class="el" href="classcaffe2_1_1_relu_gradient_op.html">ReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa8e9e65f91c86d22430f7000e5dd6df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceadcfaec69d84d7d54a5e65ba97a30e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceadcfaec69d84d7d54a5e65ba97a30e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (CostInferenceForRelu).IdenticalTypeAndShape().SetDoc(R&quot;DOC( Relu takes one input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) and produces one output data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;T&gt;) where the rectified linear function</td></tr>
<tr class="separator:aceadcfaec69d84d7d54a5e65ba97a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39ce3aea64f0df0d6e527af7063ead0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39ce3aea64f0df0d6e527af7063ead0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
ReluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the rectified linear function.
)DOC&quot;)</td></tr>
<tr class="separator:af39ce3aea64f0df0d6e527af7063ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f063fedcfd6720f10b5a7b870c270"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a242f063fedcfd6720f10b5a7b870c270"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Relu, <a class="el" href="classcaffe2_1_1_get_relu_gradient.html">GetReluGradient</a>)</td></tr>
<tr class="separator:a242f063fedcfd6720f10b5a7b870c270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40256412d4129bf3b612a9026020b79b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40256412d4129bf3b612a9026020b79b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReluFp16, <a class="el" href="classcaffe2_1_1_get_relu_gradient.html">GetReluGradient</a>)</td></tr>
<tr class="separator:a40256412d4129bf3b612a9026020b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb77e9bedf197eb81679492e72c7f78d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb77e9bedf197eb81679492e72c7f78d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReplaceNaN, <a class="el" href="classcaffe2_1_1_replace_na_n_op.html">ReplaceNaNOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abb77e9bedf197eb81679492e72c7f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91333c0430d3f7852e1c5494674ed889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91333c0430d3f7852e1c5494674ed889"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ReplaceNaN)</td></tr>
<tr class="separator:a91333c0430d3f7852e1c5494674ed889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9937a9917b9903bbe5e6a2ee616db41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9937a9917b9903bbe5e6a2ee616db41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Reshape, <a class="el" href="classcaffe2_1_1_reshape_op.html">ReshapeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac9937a9917b9903bbe5e6a2ee616db41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca224e4b6d4df756ab84ef0ba0a98504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca224e4b6d4df756ab84ef0ba0a98504"></a>
out[1]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto::INT64)</td></tr>
<tr class="separator:aca224e4b6d4df756ab84ef0ba0a98504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b1b09fdc4a1a9364b9164d209ec0f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4b1b09fdc4a1a9364b9164d209ec0f6"></a>
out[1]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims_size())</td></tr>
<tr class="separator:aa4b1b09fdc4a1a9364b9164d209ec0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b62362e577db6a6d7abd5c282d940"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a182b62362e577db6a6d7abd5c282d940"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!helper.HasArgument(&quot;shape&quot;))</td></tr>
<tr class="separator:a182b62362e577db6a6d7abd5c282d940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e736be17d0c687d49c4406c3cd54659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e736be17d0c687d49c4406c3cd54659"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (in.size(), 1,&quot;New shape must not be specified by the input blob and the &quot;&quot;argument `shape` at the same time.&quot;)</td></tr>
<tr class="separator:a2e736be17d0c687d49c4406c3cd54659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983622a08a3c507b7c23808015f8000e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a983622a08a3c507b7c23808015f8000e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (int i=0;i&lt; actualNewShape.size();++i)</td></tr>
<tr class="separator:a983622a08a3c507b7c23808015f8000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4de0400a8ae0a47d470863e9cacd1c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4de0400a8ae0a47d470863e9cacd1c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (unknownIdx!=-1)</td></tr>
<tr class="separator:ab4de0400a8ae0a47d470863e9cacd1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291d79d41c89176d403f66243ed141ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a291d79d41c89176d403f66243ed141ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (const auto d:actualNewShape)</td></tr>
<tr class="separator:a291d79d41c89176d403f66243ed141ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2542745024ff5a1a8ac9660297eb01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e2542745024ff5a1a8ac9660297eb01"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;shape&quot;,&quot;New shape&quot;).Input(0</td></tr>
<tr class="separator:a1e2542745024ff5a1a8ac9660297eb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba5fb2e38eee1f717ba9fecd734ae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55ba5fb2e38eee1f717ba9fecd734ae6"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC An input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;new_shape&quot;,&quot;New shape.&quot;).Output(0</td></tr>
<tr class="separator:a55ba5fb2e38eee1f717ba9fecd734ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7c06f1bc0cc23f51114ed58b742b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c7c06f1bc0cc23f51114ed58b742b53"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC An input tensor Reshaped data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;old_shape&quot;,&quot;Original shape.&quot;)</td></tr>
<tr class="separator:a4c7c06f1bc0cc23f51114ed58b742b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb82d86019508089c62385447aae9d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcb82d86019508089c62385447aae9d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Reshape, <a class="el" href="classcaffe2_1_1_get_reshape_gradient.html">GetReshapeGradient</a>)</td></tr>
<tr class="separator:afcb82d86019508089c62385447aae9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Reshape, <a class="el" href="classcaffe2_1_1_reshape_op.html">ReshapeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1239df75052146b3c2b8e74e50a962"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd1239df75052146b3c2b8e74e50a962"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resizeNearest2x</b> (int batch_size, int num_channels, int input_height, int input_width, const float *input, float *output)</td></tr>
<tr class="separator:acd1239df75052146b3c2b8e74e50a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade904b440a50a3605f59dabc45b1c6e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade904b440a50a3605f59dabc45b1c6e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeNearest, <a class="el" href="classcaffe2_1_1_resize_nearest_op.html">ResizeNearestOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ade904b440a50a3605f59dabc45b1c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5099b88879f337f70d805e381e75b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c5099b88879f337f70d805e381e75b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeNearestGradient, <a class="el" href="classcaffe2_1_1_resize_nearest_gradient_op.html">ResizeNearestGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9c5099b88879f337f70d805e381e75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cbdf3ca4bd23982e7de2eb0240559a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8cbdf3ca4bd23982e7de2eb0240559a"></a>
Scale along width dimension&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;height_scale&quot;,&quot;Scale along height dimension&quot;).SetDoc(R&quot;DOC( Resizes the spatial dimensions of the input using nearest neighbor interpolation. The `width_scale` and `height_scale` arguments control the size of the output</td></tr>
<tr class="separator:aa8cbdf3ca4bd23982e7de2eb0240559a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac849be392fe2203d416fa480383be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeac849be392fe2203d416fa480383be"></a>
Scale along width dimension which is given Input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;Y&quot;,&quot;Output tensor&quot;)</td></tr>
<tr class="separator:aaeac849be392fe2203d416fa480383be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713cdbe8cf8e7dc849e6279a4e959d57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a713cdbe8cf8e7dc849e6279a4e959d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ResizeNearest, <a class="el" href="classcaffe2_1_1_get_resize_nearest_gradient.html">GetResizeNearestGradient</a>)</td></tr>
<tr class="separator:a713cdbe8cf8e7dc849e6279a4e959d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043d03a0b74434f9e624e9bc23aa7377"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043d03a0b74434f9e624e9bc23aa7377"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReversePackedSegs, <a class="el" href="classcaffe2_1_1_reverse_packed_segs_op.html">ReversePackedSegsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a043d03a0b74434f9e624e9bc23aa7377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1de3afd8d991258dd5bf7232eb467a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1de3afd8d991258dd5bf7232eb467a2"></a>
leaving paddings unchanged This&#160;</td><td class="memItemRight" valign="bottom"><b>operator is used to reverse input of a recurrent neural network to make it a BRNN.) DOC&quot;) .Input</b> (0,&quot;data&quot;,&quot;a 3-D (lengths, segments, embeddings,) tensor.&quot;).Input(1</td></tr>
<tr class="separator:ac1de3afd8d991258dd5bf7232eb467a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392400dce5e7335e846f5c959985307c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a392400dce5e7335e846f5c959985307c"></a>
leaving paddings unchanged This length of each segment&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;reversed data&quot;,&quot;a (lengths, segments, embeddings,) tensor with each segment reversed&quot;&quot;and paddings unchanged.&quot;)</td></tr>
<tr class="separator:a392400dce5e7335e846f5c959985307c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55813f369cb301e8c0051b56b96a318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa55813f369cb301e8c0051b56b96a318"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReversePackedSegs, <a class="el" href="classcaffe2_1_1_get_reverse_packed_segs_gradient.html">GetReversePackedSegsGradient</a>)</td></tr>
<tr class="separator:aa55813f369cb301e8c0051b56b96a318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23bb5b87e8ea0cfb2b5a63695f04d51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae23bb5b87e8ea0cfb2b5a63695f04d51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RMACRegions, <a class="el" href="classcaffe2_1_1_r_m_a_c_regions_op.html">RMACRegionsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae23bb5b87e8ea0cfb2b5a63695f04d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02e3f0cf047e22fde957ff1944a75c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa02e3f0cf047e22fde957ff1944a75c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIAlignGradient, <a class="el" href="classcaffe2_1_1_ro_i_align_gradient_op.html">RoIAlignGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa02e3f0cf047e22fde957ff1944a75c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b61e2e35f1d6ad76c7b11fa81115d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18b61e2e35f1d6ad76c7b11fa81115d1"></a>
See RoIPoolF&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;RoIs&quot;,&quot;See RoIPoolF.&quot;).Input(2</td></tr>
<tr class="separator:a18b61e2e35f1d6ad76c7b11fa81115d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecddef0f549003ae2c2a62941797348"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ecddef0f549003ae2c2a62941797348"></a>
See RoIPoolF Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>output</b> (Y)&quot;) .Output(0</td></tr>
<tr class="separator:a6ecddef0f549003ae2c2a62941797348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9cf8601b57d03a62e24cdeb93c3a96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe9cf8601b57d03a62e24cdeb93c3a96"></a>
See RoIPoolF Gradient of forward Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (X)&quot;)</td></tr>
<tr class="separator:abe9cf8601b57d03a62e24cdeb93c3a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010a8d227eacf6ba571036bde754b67b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a010a8d227eacf6ba571036bde754b67b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RoIAlign, GetRoIAlignGradient)</td></tr>
<tr class="separator:a010a8d227eacf6ba571036bde754b67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffa0928b5c4d64d88722b8a244774c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeffa0928b5c4d64d88722b8a244774c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIAlign, <a class="el" href="classcaffe2_1_1_ro_i_align_op.html">RoIAlignOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aeffa0928b5c4d64d88722b8a244774c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f9159ea374c3300e4f6448da8ed41f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6f9159ea374c3300e4f6448da8ed41f"></a>
Spatial scale of the input feature map X relative to the input image E if X has a stride of w r t the input image&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;pooled_h&quot;,&quot;(int) default 1; Pooled output Y's height.&quot;).Arg(&quot;pooled_w&quot;</td></tr>
<tr class="separator:ac6f9159ea374c3300e4f6448da8ed41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb3cdd581ebd796201ac66bf86353f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb3cdd581ebd796201ac66bf86353f9"></a>
Pooled output Y s width&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;sampling_ratio&quot;,&quot;(int) default -1; number of sampling points in the interpolation grid &quot;&quot;used to compute the output value of each pooled output bin. If &gt; 0, &quot;&quot;then exactly sampling_ratio x sampling_ratio grid points are used. If &quot;&quot;&lt;= 0, then an adaptive number of grid points are used (computed as &quot;&quot;ceil(roi_width / pooled_w), and likewise for height).&quot;).Input(0</td></tr>
<tr class="separator:a7fb3cdd581ebd796201ac66bf86353f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108f8c790dc94d5ad5674b7ef598445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa108f8c790dc94d5ad5674b7ef598445"></a>
Pooled output Y s width feature map input of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N, C, H, W).&quot;) .Input( 1</td></tr>
<tr class="separator:aa108f8c790dc94d5ad5674b7ef598445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c6d36284b653af0276dbee5a02c3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad9c6d36284b653af0276dbee5a02c3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIPool, <a class="el" href="classcaffe2_1_1_ro_i_pool_op.html">RoIPoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aad9c6d36284b653af0276dbee5a02c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913e97c6cbb1f244d7623215027a5011"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a913e97c6cbb1f244d7623215027a5011"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIPoolGradient, <a class="el" href="classcaffe2_1_1_ro_i_pool_gradient_op.html">RoIPoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a913e97c6cbb1f244d7623215027a5011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa54635d974bd63f5f747d294d8fe3b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa54635d974bd63f5f747d294d8fe3b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);const StorageOrder order=StringToStorageOrder(helper.GetSingleArgument&lt; string &gt;(&quot;order&quot;,&quot;NCHW&quot;));const TensorShape &amp;X=in[0];const int num_channels=(order==StorageOrder::NCHW?X.dims(1):X.dims(3));const TensorShape &amp;R=in[1];const int num_rois=R.dims(0);const int pooled_height=helper.GetSingleArgument&lt; int &gt;(&quot;pooled_h&quot;, 1);const int pooled_width=helper.GetSingleArgument&lt; int &gt;(&quot;pooled_w&quot;, 1);TensorShape Y=CreateTensorShape(vector&lt; int &gt;({num_rois, num_channels, pooled_height, pooled_width}), X.data_type());bool is_test=helper.GetSingleArgument&lt; int &gt;(OpSchema::Arg_IsTest, 0);if(!is_test){TensorShape argmaxes=Y;argmaxes.set_data_type(TensorProto_DataType_INT32);return vector&lt; TensorShape &gt;({Y, argmaxes});}else{return vector&lt; TensorShape &gt;({Y});}}).SetDoc(R&quot;DOC( Carries out ROI Pooling for Faster-RCNN. Depending on the mode</td></tr>
<tr class="separator:aaa54635d974bd63f5f747d294d8fe3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecaf93f8f892520e9d73f6a9eb15282a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecaf93f8f892520e9d73f6a9eb15282a"></a>
there are multiple output&#160;</td><td class="memItemRight" valign="bottom"><b>argmaxes</b> (train mode) Output case) DOC&quot;) .Arg( &quot;is_test&quot;</td></tr>
<tr class="separator:aecaf93f8f892520e9d73f6a9eb15282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335b1ba59a0a33962131c798b43ac62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab335b1ba59a0a33962131c798b43ac62"></a>
there are multiple output If run in test mode and skip computation of argmaxes(used for&quot; &quot;gradient computation).Only one output tensor is produced.&quot; &quot;(Default&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (RoIPoolGradient).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:ab335b1ba59a0a33962131c798b43ac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7654c3b702689ba3c1a9728b405e364"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7654c3b702689ba3c1a9728b405e364"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RoIPool, <a class="el" href="classcaffe2_1_1_get_ro_i_pool_gradient.html">GetRoIPoolGradient</a>)</td></tr>
<tr class="separator:ac7654c3b702689ba3c1a9728b405e364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1159a62c926097876cded3160b7afe95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1159a62c926097876cded3160b7afe95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Scale, <a class="el" href="classcaffe2_1_1_scale_op.html">ScaleOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1159a62c926097876cded3160b7afe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02ecb0fbf2afa6ea64145dd15900e96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af02ecb0fbf2afa6ea64145dd15900e96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Scale, <a class="el" href="classcaffe2_1_1_get_scale_gradient.html">GetScaleGradient</a>)</td></tr>
<tr class="separator:af02ecb0fbf2afa6ea64145dd15900e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e060dd9c1c0f4a22082fa13abd792"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa07e060dd9c1c0f4a22082fa13abd792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Scale, <a class="el" href="classcaffe2_1_1_scale_op.html">ScaleOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa07e060dd9c1c0f4a22082fa13abd792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622d8c518157abd3bea547391095532f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a622d8c518157abd3bea547391095532f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientWeightedSumWithMainInputGradient, <a class="el" href="classcaffe2_1_1_abstract_lengths_with_main_input_gradient_op.html">AbstractLengthsWithMainInputGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, WeightedSumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;, true, true &gt;)</td></tr>
<tr class="separator:a622d8c518157abd3bea547391095532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff644a53b8cf580d4b05c161a9053133"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff644a53b8cf580d4b05c161a9053133"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientWeightedSumGradient, <a class="el" href="classcaffe2_1_1_abstract_lengths_gradient_op.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, WeightedSumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:aff644a53b8cf580d4b05c161a9053133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee4fbd38ead2ffa712e22a020094b2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ee4fbd38ead2ffa712e22a020094b2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientSumGradient, <a class="el" href="classcaffe2_1_1_abstract_lengths_gradient_op.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, SumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:a0ee4fbd38ead2ffa712e22a020094b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d6dd1f6e01d4b156c6595613c0f0f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3d6dd1f6e01d4b156c6595613c0f0f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsIndicesInGradientSumGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af3d6dd1f6e01d4b156c6595613c0f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed489fa4cf75c02fa66a66da804522d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed489fa4cf75c02fa66a66da804522d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsIndicesInGradientSumGradient, <a class="el" href="classcaffe2_1_1_abstract_lengths_gradient_op.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, SumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:aed489fa4cf75c02fa66a66da804522d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765ec9d4e39ebf931654f2c753d52065"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765ec9d4e39ebf931654f2c753d52065"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Selu, <a class="el" href="classcaffe2_1_1_selu_op.html">SeluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a765ec9d4e39ebf931654f2c753d52065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016d28f688e82e9b264309c577b389ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a016d28f688e82e9b264309c577b389ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SeluGradient, <a class="el" href="classcaffe2_1_1_selu_gradient_op.html">SeluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a016d28f688e82e9b264309c577b389ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af271e249eafa7deed5274ce37453c0da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af271e249eafa7deed5274ce37453c0da"></a>
is applied to the tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;alpha&quot;,&quot;(float) default to 1.6732~; affects the activation function itself. &quot;&quot;This should go with the weight initialization in the paper. &quot;&quot; See https://arxiv.org/abs/1706.02515 &quot;).Arg(&quot;scale&quot;</td></tr>
<tr class="separator:af271e249eafa7deed5274ce37453c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f33690a488c551682ab413454f9397e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f33690a488c551682ab413454f9397e"></a>
affects the activation function itself&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;input tensor&quot;).Output(0</td></tr>
<tr class="separator:a8f33690a488c551682ab413454f9397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9375ac4fa5ae7953080e1f8835f1f385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9375ac4fa5ae7953080e1f8835f1f385"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SeluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the selu function.
)DOC&quot;).Arg(&quot;alpha&quot;</td></tr>
<tr class="separator:a9375ac4fa5ae7953080e1f8835f1f385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae897ba88d1994d84709fa0d1464f4b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae897ba88d1994d84709fa0d1464f4b6"></a>
affects the activation function itself&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;Y&quot;,&quot;input tensor&quot;).Input(1</td></tr>
<tr class="separator:aae897ba88d1994d84709fa0d1464f4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2b5f398ce932ceda8ea5e6f365b3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaef2b5f398ce932ceda8ea5e6f365b3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Selu, <a class="el" href="classcaffe2_1_1_get_selu_gradient.html">GetSeluGradient</a>)</td></tr>
<tr class="separator:aaef2b5f398ce932ceda8ea5e6f365b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457dd70408b41358d19dc630796e39bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a457dd70408b41358d19dc630796e39bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AddPadding, <a class="el" href="classcaffe2_1_1_add_padding_op.html">AddPaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a457dd70408b41358d19dc630796e39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675075e89d477f05f8d7086eb11f0aab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675075e89d477f05f8d7086eb11f0aab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RemovePadding, <a class="el" href="classcaffe2_1_1_remove_padding_op.html">RemovePaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a675075e89d477f05f8d7086eb11f0aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e17c64c70ff762d285c362af49eb59a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e17c64c70ff762d285c362af49eb59a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GatherPadding, <a class="el" href="classcaffe2_1_1_gather_padding_op.html">GatherPaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e17c64c70ff762d285c362af49eb59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82e1ba385039e99aff711d3b972240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca82e1ba385039e99aff711d3b972240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadEmptySamples, <a class="el" href="classcaffe2_1_1_pad_empty_samples_op.html">PadEmptySamplesOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aca82e1ba385039e99aff711d3b972240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79da49fb460bb50acc1db902386e2e93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79da49fb460bb50acc1db902386e2e93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AddPadding, <a class="el" href="structcaffe2_1_1_get_add_padding_gradient.html">GetAddPaddingGradient</a>)</td></tr>
<tr class="separator:a79da49fb460bb50acc1db902386e2e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6f136ea5a1e636c7b3f222755d20b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a6f136ea5a1e636c7b3f222755d20b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RemovePadding, <a class="el" href="structcaffe2_1_1_get_remove_padding_gradient.html">GetRemovePaddingGradient</a>)</td></tr>
<tr class="separator:a2a6f136ea5a1e636c7b3f222755d20b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c57afc11a78013fb61a72c61b8591e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c57afc11a78013fb61a72c61b8591e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a partitioned tensor T&lt;N, D1..., Dn&gt;, where the partitions are
defined as ranges on its outer-most (slowest varying) dimension N,
with given range lengths, return a tensor T&lt;N + 2*padding_width, D1 ..., Dn&gt;
with paddings added to the start and end of each range.
Optionally, different paddings can be provided for beginning and end. Paddings
provided must be a tensor T&lt;D1..., Dn&gt;.

If no padding is provided, add zero padding.
If no lengths vector is provided, add padding only once,
at the start and end of data.
)DOC&quot;).Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:ae5c57afc11a78013fb61a72c61b8591e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1f15be8218bd2945b479d6144dc5d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1f15be8218bd2945b479d6144dc5d0"></a>
Number of copies of padding to add around each range&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;end_padding_width&quot;,&quot;(Optional) Specifies a different end-padding width.&quot;).Input(0</td></tr>
<tr class="separator:aed1f15be8218bd2945b479d6144dc5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aac7986cd0bf87adbaba788315ba1bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aac7986cd0bf87adbaba788315ba1bf"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;lengths&quot;,&quot;(i64) Num of elements in each range. sum(lengths) = N.&quot;).Input(2</td></tr>
<tr class="separator:a2aac7986cd0bf87adbaba788315ba1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf20a1d88ddc9b1d000ffc1ad5576590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf20a1d88ddc9b1d000ffc1ad5576590"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;end_padding&quot;,&quot;T&lt;D1..., Dn&gt; (optional) Padding for range end. &quot;&quot;If not provided, start_padding is used as end_padding as well.&quot;).Output(0</td></tr>
<tr class="separator:adf20a1d88ddc9b1d000ffc1ad5576590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e4c8190d4943a1d4cfc0aebd5e27c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7e4c8190d4943a1d4cfc0aebd5e27c0"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start T&lt; N+2 *padding_width, D1..., Dn &gt; Padded data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;lengths_out&quot;,&quot;(i64, optional) Lengths for each padded range.&quot;)</td></tr>
<tr class="separator:af7e4c8190d4943a1d4cfc0aebd5e27c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1186f785d2b934a993fcd5349d7ad2e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1186f785d2b934a993fcd5349d7ad2e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Remove padding around the edges of each segment of the input data. This is
the reverse opration of AddPadding, and uses the same arguments and conventions
for input and output data format.
)DOC&quot;).Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:a1186f785d2b934a993fcd5349d7ad2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5506e20c0ee952d06dc73b4ec33cf03c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5506e20c0ee952d06dc73b4ec33cf03c"></a>
Outer size of padding to remove around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;lengths&quot;,&quot;(i64) Num of elements in each range. sum(lengths) = N. &quot;&quot;If not provided, considers all data as a single segment.&quot;).Output(0</td></tr>
<tr class="separator:a5506e20c0ee952d06dc73b4ec33cf03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fefedd69d9aceebe7d8e1e67598de1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91fefedd69d9aceebe7d8e1e67598de1"></a>
Outer size of padding to remove around each range T&lt; N, D1..., Dn &gt; Input data T&lt; N-2 *padding_width, D1..., Dn &gt; Unpadded data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;lengths_out&quot;,&quot;(i64, optional) Lengths for each unpadded range.&quot;)</td></tr>
<tr class="separator:a91fefedd69d9aceebe7d8e1e67598de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f34acd34d51b4f51a1a476e374d356a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f34acd34d51b4f51a1a476e374d356a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Gather the sum of start and end paddings in a padded input sequence. Used in
order to compute the gradients of AddPadding w.r.t the padding tensors.
)DOC&quot;).Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:a8f34acd34d51b4f51a1a476e374d356a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6115935115021115751564d81f3ac33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6115935115021115751564d81f3ac33"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data Sum of all start or of all paddings if end_padding_sum is not provided&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;end_padding_sum&quot;,&quot;T&lt;D1..., Dn&gt; Sum of all end paddings, if provided.&quot;)</td></tr>
<tr class="separator:ae6115935115021115751564d81f3ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83f113ffa9943e7ff8ba7abe29bde50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab83f113ffa9943e7ff8ba7abe29bde50"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Pad empty field given lengths and index features,

Input(0) is a blob pointing to the lengths of samples in one batch,
[Input(1),... Input(num_fields)] a list of tensors containing the data for
each field of the features.

PadEmptySamples is thread safe.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ab83f113ffa9943e7ff8ba7abe29bde50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0ca8450d1746db37b2e14fe187ce0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb0ca8450d1746db37b2e14fe187ce0b"></a>
INT_MAX A blob containing a pointer to the lengths&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;out_lengths&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> containing lengths with empty sample padded.&quot;)</td></tr>
<tr class="separator:adb0ca8450d1746db37b2e14fe187ce0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97663b7dbf517f27fbe11677f5260a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e97663b7dbf517f27fbe11677f5260a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Shape, <a class="el" href="classcaffe2_1_1_shape_op.html">ShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8e97663b7dbf517f27fbe11677f5260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd0dc979669945b10f0d2a689cfa87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fcd0dc979669945b10f0d2a689cfa87"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims().size())</td></tr>
<tr class="separator:a5fcd0dc979669945b10f0d2a689cfa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33764413ff2c19ffea6d329adbf78ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa33764413ff2c19ffea6d329adbf78ad"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto::INT32)</td></tr>
<tr class="separator:aa33764413ff2c19ffea6d329adbf78ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed493261e8efa97e1b71333c4e34d19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ed493261e8efa97e1b71333c4e34d19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Produce a 1D int64 tensor with the shape of the input tensor.&quot;)</td></tr>
<tr class="separator:a6ed493261e8efa97e1b71333c4e34d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250e210ebc7b83eff196adf32c4c5674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250e210ebc7b83eff196adf32c4c5674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Shape)</td></tr>
<tr class="separator:a250e210ebc7b83eff196adf32c4c5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570069e0367edaef71f55323bafa08d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a570069e0367edaef71f55323bafa08d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Shape, <a class="el" href="classcaffe2_1_1_shape_op.html">ShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a570069e0367edaef71f55323bafa08d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55316d45ffcf57d0685f4ce802e808a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55316d45ffcf57d0685f4ce802e808a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sigmoid, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_sigmoid_c_p_u_functor.html">SigmoidCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a55316d45ffcf57d0685f4ce802e808a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebde54190f626dc7b3aad23808229c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07ebde54190f626dc7b3aad23808229c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_sigmoid_gradient_c_p_u_functor.html">SigmoidGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a07ebde54190f626dc7b3aad23808229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e16d0636c3fe6f41ff3c2acf707907a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e16d0636c3fe6f41ff3c2acf707907a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SigmoidGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the sigmoid function.
)DOC&quot;)</td></tr>
<tr class="separator:a6e16d0636c3fe6f41ff3c2acf707907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a39de2621fd3600d6f7b973422bd36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55a39de2621fd3600d6f7b973422bd36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sigmoid, <a class="el" href="classcaffe2_1_1_get_sigmoid_gradient.html">GetSigmoidGradient</a>)</td></tr>
<tr class="separator:a55a39de2621fd3600d6f7b973422bd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd25f86457b1ce019afa23e74ad314"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2dd25f86457b1ce019afa23e74ad314"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sin, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_sin_c_p_u_functor.html">SinCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:ae2dd25f86457b1ce019afa23e74ad314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5568dbbcdb47d0628f236ac0eb8c9bd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5568dbbcdb47d0628f236ac0eb8c9bd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SinGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_sin_gradient_c_p_u_functor.html">SinGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a5568dbbcdb47d0628f236ac0eb8c9bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3174e345cd49490fecdf38615c69da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc3174e345cd49490fecdf38615c69da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SinGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:acc3174e345cd49490fecdf38615c69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e0d94d77754852fc8522925954f6f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77e0d94d77754852fc8522925954f6f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sin, <a class="el" href="classcaffe2_1_1_get_sin_gradient.html">GetSinGradient</a>)</td></tr>
<tr class="separator:a77e0d94d77754852fc8522925954f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4b756535d478a0666d976258040d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87d4b756535d478a0666d976258040d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SinusoidPositionEncoding, <a class="el" href="classcaffe2_1_1_sinusoid_position_encoding_op.html">SinusoidPositionEncodingOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a87d4b756535d478a0666d976258040d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621da74b2679f79390bf95335308c027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a621da74b2679f79390bf95335308c027"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Slice, <a class="el" href="classcaffe2_1_1_slice_op.html">SliceOp</a>&lt; int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a621da74b2679f79390bf95335308c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1edb64f5df0c515bbb6af1d0b80e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f1edb64f5df0c515bbb6af1d0b80e54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SliceGradient, <a class="el" href="classcaffe2_1_1_slice_gradient_op.html">SliceGradientOp</a>&lt; int, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4f1edb64f5df0c515bbb6af1d0b80e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b851dddcaa95504bfe9549a0bf9e14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2b851dddcaa95504bfe9549a0bf9e14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 3).NumOutputs(1).SetDoc(R&quot;DOC( Produces a slice of the input tensor. Currently</td></tr>
<tr class="separator:ac2b851dddcaa95504bfe9549a0bf9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02cb3e67bee38b29103a878b3d710c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad02cb3e67bee38b29103a878b3d710c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softmax, <a class="el" href="classcaffe2_1_1_softmax_op.html">SoftmaxOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad02cb3e67bee38b29103a878b3d710c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1212b684fcf3c2c96e98768ca84b857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1212b684fcf3c2c96e98768ca84b857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxGradient, <a class="el" href="classcaffe2_1_1_softmax_gradient_op.html">SoftmaxGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af1212b684fcf3c2c96e98768ca84b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6871fadac332ae77f8cec346d0194d94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6871fadac332ae77f8cec346d0194d94"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions[a_0 *...*a_{k-1}, a_k *...*a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have or else the&#160;</td><td class="memItemRight" valign="bottom"><b>operator will throw errors.) DOC&quot;) .Arg</b> (&quot;axis&quot;,&quot;(int) default to 1; describes the axis of the inputs when coerced &quot;&quot;to 2D; defaults to one because the 0th axis most likely describes &quot;&quot;the batch_size&quot;).Input(0</td></tr>
<tr class="separator:a6871fadac332ae77f8cec346d0194d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490d4ff8a51cc28bad8740d23ecf3656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a490d4ff8a51cc28bad8740d23ecf3656"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions[a_0 *...*a_{k-1}, a_k *...*a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have or else the The input tensor that s coerced into a matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (NxD)&quot; &quot;as described above.&quot;) .Output(0</td></tr>
<tr class="separator:a490d4ff8a51cc28bad8740d23ecf3656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885bce453a892365513928cb409e7752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a885bce453a892365513928cb409e7752"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SoftmaxGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a885bce453a892365513928cb409e7752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8825981fdefb97fb6366d2f24e68639a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8825981fdefb97fb6366d2f24e68639a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softmax, <a class="el" href="classcaffe2_1_1_get_softmax_gradient.html">GetSoftmaxGradient</a>)</td></tr>
<tr class="separator:a8825981fdefb97fb6366d2f24e68639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3879bb83a156661b7d8c7ec039980121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3879bb83a156661b7d8c7ec039980121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SoftmaxFp16, <a class="el" href="classcaffe2_1_1_get_softmax_gradient.html">GetSoftmaxGradient</a>)</td></tr>
<tr class="separator:a3879bb83a156661b7d8c7ec039980121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330cbed1de990a2c5811866b84ce32f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af330cbed1de990a2c5811866b84ce32f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SoftmaxCPU</b> (<a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &amp;context, const int N, const int D, const float *Xdata, float *Ydata, float *scale, const float *sum_multiplier, bool logarithmic, float *rowmax)</td></tr>
<tr class="separator:af330cbed1de990a2c5811866b84ce32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68815986ef2a1b95f96ffbf3a9bb2bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab68815986ef2a1b95f96ffbf3a9bb2bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxWithLoss, <a class="el" href="classcaffe2_1_1_softmax_with_loss_op.html">SoftmaxWithLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab68815986ef2a1b95f96ffbf3a9bb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b83c6ed7b2c6a7e5828fbd2ceb419b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6b83c6ed7b2c6a7e5828fbd2ceb419b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxWithLossGradient, <a class="el" href="classcaffe2_1_1_softmax_with_loss_gradient_op.html">SoftmaxWithLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae6b83c6ed7b2c6a7e5828fbd2ceb419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6923dd503673e4a99b2d259489172209"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6923dd503673e4a99b2d259489172209"></a>
vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> (2)</td></tr>
<tr class="separator:a6923dd503673e4a99b2d259489172209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6876a6c09b269f742ac40ad44fa22c17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6876a6c09b269f742ac40ad44fa22c17"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (logits.data_type())</td></tr>
<tr class="separator:a6876a6c09b269f742ac40ad44fa22c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b9645e83c41b7e5887bf6ccabe3db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad08b9645e83c41b7e5887bf6ccabe3db"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (batch_size)</td></tr>
<tr class="separator:ad08b9645e83c41b7e5887bf6ccabe3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae843583eef085c95eaaf039302d2becc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae843583eef085c95eaaf039302d2becc"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (num_classes)</td></tr>
<tr class="separator:ae843583eef085c95eaaf039302d2becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235e23a8b33295ef5a91afc3cc162cbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a235e23a8b33295ef5a91afc3cc162cbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Combined Softmax and Cross-Entropy loss operator.
The operator computes the softmax normalized values for each layer in the batch
of the given input, after which cross-entropy loss is computed. This operator is
numerically more stable than separate Softmax and CrossEntropy ops.
The inputs are a 2-D tensor (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) of size
(batch_size x input_feature_dimensions) and tensor of labels (ground truth).
Output is tensor with the probability for each label for each example (N x D)
and averaged loss (scalar).
Use parameter label_prob=1 to enable inputting labels as a probability
distribution.
Optional third input blob can be used to weight the samples for the loss.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a235e23a8b33295ef5a91afc3cc162cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0fa99118192da210b5c7fe8f6a7c99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f0fa99118192da210b5c7fe8f6a7c99"></a>
Unscaled log probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;labels&quot;,&quot;Ground truth&quot;).Input(2</td></tr>
<tr class="separator:a2f0fa99118192da210b5c7fe8f6a7c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aa94028a5011a43bc4388077f64d5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91aa94028a5011a43bc4388077f64d5d"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;softmax&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> with softmax cross entropy loss&quot;).Output(1</td></tr>
<tr class="separator:a91aa94028a5011a43bc4388077f64d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a735204b31b0d014e5562cea64a8198"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a735204b31b0d014e5562cea64a8198"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SoftmaxWithLossGradient).NumOutputs(1)</td></tr>
<tr class="separator:a8a735204b31b0d014e5562cea64a8198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e74c82fca95c4524df696642fe77a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38e74c82fca95c4524df696642fe77a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softplus, <a class="el" href="classcaffe2_1_1_softplus_op.html">SoftplusOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa38e74c82fca95c4524df696642fe77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36000d81d5598901b3ce01b744e7487f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36000d81d5598901b3ce01b744e7487f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftplusGradient, <a class="el" href="classcaffe2_1_1_softplus_gradient_op.html">SoftplusGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a36000d81d5598901b3ce01b744e7487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ecfb1a5c9ef3e173961468e81760d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42ecfb1a5c9ef3e173961468e81760d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softplus, <a class="el" href="classcaffe2_1_1_get_softplus_gradient.html">GetSoftplusGradient</a>)</td></tr>
<tr class="separator:a42ecfb1a5c9ef3e173961468e81760d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7e77c5768d9f1402c417284babd4d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7e77c5768d9f1402c417284babd4d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softsign, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_softsign_c_p_u_functor.html">SoftsignCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:afa7e77c5768d9f1402c417284babd4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583cb57c1df5943595821d0dcb539829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a583cb57c1df5943595821d0dcb539829"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftsignGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_softsign_gradient_c_p_u_functor.html">SoftsignGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a583cb57c1df5943595821d0dcb539829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046ba37c727d1db1121015980689d5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8046ba37c727d1db1121015980689d5e"></a>
by providing the same input and output blobs DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;input&quot;,&quot;1-D input tensor&quot;).Output(0</td></tr>
<tr class="separator:a8046ba37c727d1db1121015980689d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca858518fcde6e6b69ecba322db015a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ca858518fcde6e6b69ecba322db015a"></a>
by providing the same input and output blobs DOC The&#160;</td><td class="memItemRight" valign="bottom"><b>softsign</b> (x/1+|x|) values of the input tensor&quot; &quot;computed element-wise&quot;)</td></tr>
<tr class="separator:a5ca858518fcde6e6b69ecba322db015a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafde3a73a6859f7c257053509c23f17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adafde3a73a6859f7c257053509c23f17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Calculates the softsign gradient (sgn(x)/(1+|x|)^2) of the given input tensor
element-wise.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:adafde3a73a6859f7c257053509c23f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f2772ef3acd9daef530ca364c7e7cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66f2772ef3acd9daef530ca364c7e7cf"></a>
D input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;input&quot;,&quot;1-D input tensor&quot;).Output(0</td></tr>
<tr class="separator:a66f2772ef3acd9daef530ca364c7e7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5147e9c8f7b8a0fbed365ce5ab835f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff5147e9c8f7b8a0fbed365ce5ab835f"></a>
D input tensor The softsign&#160;</td><td class="memItemRight" valign="bottom"><b>gradient</b> (sgn(x)/(1+|x|)^2) values of the input tensor&quot; &quot;computed element-wise&quot;)</td></tr>
<tr class="separator:aff5147e9c8f7b8a0fbed365ce5ab835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9b1a4af9e42555e0b6b2920fdaf0f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a9b1a4af9e42555e0b6b2920fdaf0f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softsign, <a class="el" href="classcaffe2_1_1_get_softsign_gradient.html">GetSoftsignGradient</a>)</td></tr>
<tr class="separator:a9a9b1a4af9e42555e0b6b2920fdaf0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab420c1d380ece4ea2b2ceda61059caa9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab420c1d380ece4ea2b2ceda61059caa9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpaceToBatch, <a class="el" href="classcaffe2_1_1_space_to_batch_op.html">SpaceToBatchOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab420c1d380ece4ea2b2ceda61059caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91276e2e4a1d9d843dcedc1c0815935b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91276e2e4a1d9d843dcedc1c0815935b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SpaceToBatch).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( SpaceToBatch for 4-D tensors of type T. Zero-pads and then rearranges (permutes) blocks of spatial data into batch. More specifically</td></tr>
<tr class="separator:a91276e2e4a1d9d843dcedc1c0815935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4af83599ba3c1b2ba3bf3ce8e3c933"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c4af83599ba3c1b2ba3bf3ce8e3c933"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchToSpace, <a class="el" href="classcaffe2_1_1_batch_to_space_op.html">BatchToSpaceOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6c4af83599ba3c1b2ba3bf3ce8e3c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fcd57a5aed330c94ae56b2d6325ef2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fcd57a5aed330c94ae56b2d6325ef2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (BatchToSpace).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( BatchToSpace for 4-D tensors of type T. Rearranges (permutes) data from batch into blocks of spatial data</td></tr>
<tr class="separator:a40fcd57a5aed330c94ae56b2d6325ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040264084b11f8885462eabf2e448ccf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a040264084b11f8885462eabf2e448ccf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SpaceToBatch, <a class="el" href="classcaffe2_1_1_get_space_to_batch_gradient.html">GetSpaceToBatchGradient</a>)</td></tr>
<tr class="separator:a040264084b11f8885462eabf2e448ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99ac6250b0b0383f1ca68a59d853528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae99ac6250b0b0383f1ca68a59d853528"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BatchToSpace, <a class="el" href="classcaffe2_1_1_get_batch_to_space_gradient.html">GetBatchToSpaceGradient</a>)</td></tr>
<tr class="separator:ae99ac6250b0b0383f1ca68a59d853528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66330ae07e769ba2997e4258bc880f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a66330ae07e769ba2997e4258bc880f"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a9a66330ae07e769ba2997e4258bc880f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spaceToBatch</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;input, int pad_t, int pad_l, int block_size, <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; *output, Context *)</td></tr>
<tr class="separator:a9a66330ae07e769ba2997e4258bc880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1fbe16f3907d5fcaef2a1f394e6d11c"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>batchToSpace</b> (const <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; &amp;input, int pad_t, int pad_l, int block_size, <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; Context &gt; *output, Context *)</td></tr>
<tr class="separator:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad28f101d7677a0b3a740b404e8f713"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ad28f101d7677a0b3a740b404e8f713"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseNormalize, <a class="el" href="classcaffe2_1_1_sparse_normalize_op.html">SparseNormalizeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7ad28f101d7677a0b3a740b404e8f713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11db6b664e5991a32021e3ead53c753"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11db6b664e5991a32021e3ead53c753"></a>
Parameters to be normalized&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;indices&quot;,&quot;Sparse indices&quot;).Input(2</td></tr>
<tr class="separator:af11db6b664e5991a32021e3ead53c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9949e506c97983c304e6def927d310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e9949e506c97983c304e6def927d310"></a>
Parameters to be normalized Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output_param&quot;,&quot;Normalized parameters&quot;).EnforceOneToOneInplace().Arg(&quot;use_max_norm&quot;</td></tr>
<tr class="separator:a3e9949e506c97983c304e6def927d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbc8cc8136b15d45cb1aa3249cff80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70bbc8cc8136b15d45cb1aa3249cff80"></a>
Parameters to be normalized Gradient computed A bool variable to control whether to use max norm or constant norm When constant norm is used so that all the embedding vectors are scaled to have a L2 norm equals to&#160;</td><td class="memItemRight" valign="bottom"><b>A</b> (see blow arugment norm=A).If use_max_norm</td></tr>
<tr class="separator:a70bbc8cc8136b15d45cb1aa3249cff80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30ab7763e1b43ddf59571e3d4273fbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad30ab7763e1b43ddf59571e3d4273fbf"></a>
Parameters to be normalized Gradient computed A bool variable to control whether to use max norm or constant norm When constant norm is used so that all the embedding vectors are scaled to have a L2 norm equals to max norm is used so that embedding is scaled so that its l2 norm is no larger than A If an embedding s norm is less than A the embedding is left unchanged The default is True&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;norm&quot;,&quot;L2 norm of the embedding. The default is 1.0.&quot;).SetDoc(R&quot;DOC( Given a sparse matrix</td></tr>
<tr class="separator:ad30ab7763e1b43ddf59571e3d4273fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c4a2e2bcada3dfabbea97bd7bb56e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac36c4a2e2bcada3dfabbea97bd7bb56e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseNormalize)</td></tr>
<tr class="separator:ac36c4a2e2bcada3dfabbea97bd7bb56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09acb13ce73b40a3605ef0995ed15260"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09acb13ce73b40a3605ef0995ed15260"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseToDense, <a class="el" href="classcaffe2_1_1_sparse_to_dense_op.html">SparseToDenseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a09acb13ce73b40a3605ef0995ed15260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa1d3a7496d212ca81184a586ea21aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aa1d3a7496d212ca81184a586ea21aa"></a>
value represented as indices vector and values tensor into a compacted tensor where the first dimension is determined by the first dimension of the input if it is given or the max index Missing values are filled with zeros The op supports duplicated indices and performs summation over corresponding values This behavior is useful for converting GradientSlices into dense representation After running this&#160;</td><td class="memItemRight" valign="bottom"><b>len</b> (mask)]+shape(default_value)`(if`lengths`is not provided the&quot; &quot;first dimension is omitted)&quot;)</td></tr>
<tr class="separator:a6aa1d3a7496d212ca81184a586ea21aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e07bf5c8fe8cf9b4271e54079dbe7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e07bf5c8fe8cf9b4271e54079dbe7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1_spatial_b_n_gradient_op.html">SpatialBNGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa9e07bf5c8fe8cf9b4271e54079dbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1d13cabc445187bfb179291dc92224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1d13cabc445187bfb179291dc92224"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ({5, 7}).NumOutputs(3).AllowInplace(</td></tr>
<tr class="separator:a0d1d13cabc445187bfb179291dc92224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a270cc689758874f92fe7d28977027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a270cc689758874f92fe7d28977027"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SpatialBN, <a class="el" href="classcaffe2_1_1_get_spatial_b_n_gradient.html">GetSpatialBNGradient</a>)</td></tr>
<tr class="separator:a93a270cc689758874f92fe7d28977027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4982d345187b05f9ad755a509398e7b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4982d345187b05f9ad755a509398e7b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1_spatial_b_n_op.html">SpatialBNOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4982d345187b05f9ad755a509398e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddf133cc0876b86b3e1a2bc4ef328a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ddf133cc0876b86b3e1a2bc4ef328a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_op.html">CudnnSpatialBNOp</a>)</td></tr>
<tr class="separator:a8ddf133cc0876b86b3e1a2bc4ef328a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c04e8b21a43bf7603be15aba8aa6b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33c04e8b21a43bf7603be15aba8aa6b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_gradient_op.html">CudnnSpatialBNGradientOp</a>)</td></tr>
<tr class="separator:a33c04e8b21a43bf7603be15aba8aa6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bf15413f82143a3c040e975cc0f858"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4bf15413f82143a3c040e975cc0f858"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_op.html">CudnnSpatialBNOp</a>)</td></tr>
<tr class="separator:af4bf15413f82143a3c040e975cc0f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b276d423f224f99a6058070a23779b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4b276d423f224f99a6058070a23779b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1_cudnn_spatial_b_n_gradient_op.html">CudnnSpatialBNGradientOp</a>)</td></tr>
<tr class="separator:ad4b276d423f224f99a6058070a23779b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9bcafb209f807b50be88e9a5709613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c9bcafb209f807b50be88e9a5709613"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialSoftmaxWithLoss, <a class="el" href="classcaffe2_1_1_spatial_softmax_with_loss_op.html">SpatialSoftmaxWithLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c9bcafb209f807b50be88e9a5709613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6a5c55dc68fae54d5f4027159314b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6a5c55dc68fae54d5f4027159314b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialSoftmaxWithLossGradient, <a class="el" href="classcaffe2_1_1_spatial_softmax_with_loss_gradient_op.html">SpatialSoftmaxWithLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aed6a5c55dc68fae54d5f4027159314b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7bd8f08453c3359bc855816705d7c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec7bd8f08453c3359bc855816705d7c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (logits.dims_size(), 4)</td></tr>
<tr class="separator:aec7bd8f08453c3359bc855816705d7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1f94dd12c0042a6b995dfaa75a026a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b1f94dd12c0042a6b995dfaa75a026a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (labels.dims_size(), 3)</td></tr>
<tr class="separator:a3b1f94dd12c0042a6b995dfaa75a026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7870c8a832784ef7540004244c254cd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7870c8a832784ef7540004244c254cd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Combined Spatial Softmax and Cross-Entropy loss operator.
Similar to SoftmaxWithLoss, this operator computes the spatial softmax
normalized values for each layer in the batch of the given input, after which
cross-entropy loss is computed. This operator is numerically more stable than
separate Softmax and CrossEntropy ops. The inputs are a 2-D tensor
(<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) of size (batch_size x input_feature_dimensions) and tensor of
labels (ground truth).
Output is tensor with the probability for each label in a pixel for each example
(N x D x W x H) and averaged loss (scalar).
For spatial softmax, weighting is by x,y position of the input.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a7870c8a832784ef7540004244c254cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6460a1858caca6712da0ef4a4b70956"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6460a1858caca6712da0ef4a4b70956"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SpatialSoftmaxWithLossGradient).NumOutputs(1)</td></tr>
<tr class="separator:af6460a1858caca6712da0ef4a4b70956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58f990a494b708f68be3d51b90d89e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac58f990a494b708f68be3d51b90d89e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sqrt, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_sqrt_c_p_u_functor.html">SqrtCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:ac58f990a494b708f68be3d51b90d89e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d892864e1389ad4820d765d8e90b0c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d892864e1389ad4820d765d8e90b0c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sqrt, <a class="el" href="classcaffe2_1_1_get_sqrt_gradient.html">GetSqrtGradient</a>)</td></tr>
<tr class="separator:a9d892864e1389ad4820d765d8e90b0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3b548215e4cec56262725afda6b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0c3b548215e4cec56262725afda6b4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquareRootDivide, <a class="el" href="classcaffe2_1_1_square_root_divide_op.html">SquareRootDivideOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab0c3b548215e4cec56262725afda6b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb72afa45c13fc89d6eaf103b15aa6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb72afa45c13fc89d6eaf103b15aa6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given DATA tensor with first dimension N and SCALE vector of the same size N
produces an output tensor with same dimensions as DATA. Which consists of DATA
slices. i-th slice is divided by sqrt(SCALE[i]) elementwise. If SCALE[i] == 0
output slice is identical to the input one (no scaling)

Example:

  Data = [
    [2.0, 4.0],
    [9.0, 12.0]
  ]

  SCALE = [4, 9]

  OUTPUT = [
    [1.0, 2.0],
    [3.0, 4.0]
  ]

)DOC&quot;)</td></tr>
<tr class="separator:abcb72afa45c13fc89d6eaf103b15aa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e55834dad0dcb118ea8da02d9d5d4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0e55834dad0dcb118ea8da02d9d5d4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SquareRootDivide, <a class="el" href="classcaffe2_1_1_get_square_root_divide_gradient.html">GetSquareRootDivideGradient</a>)</td></tr>
<tr class="separator:af0e55834dad0dcb118ea8da02d9d5d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947b928814ca9f64e4f32f3a7fee42d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a947b928814ca9f64e4f32f3a7fee42d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryCreate, <a class="el" href="classcaffe2_1_1_stat_registry_create_op.html">StatRegistryCreateOp</a>)</td></tr>
<tr class="separator:a947b928814ca9f64e4f32f3a7fee42d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb1ebf8f3c49af26f704b0abcb55a9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bb1ebf8f3c49af26f704b0abcb55a9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryUpdate, <a class="el" href="classcaffe2_1_1_stat_registry_update_op.html">StatRegistryUpdateOp</a>)</td></tr>
<tr class="separator:a9bb1ebf8f3c49af26f704b0abcb55a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcd969fdcee60b30fbc53cacde305ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fcd969fdcee60b30fbc53cacde305ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryExport, <a class="el" href="classcaffe2_1_1_stat_registry_export_op.html">StatRegistryExportOp</a>)</td></tr>
<tr class="separator:a4fcd969fdcee60b30fbc53cacde305ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f762eed64a7875a6caae9f43fbe6b85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f762eed64a7875a6caae9f43fbe6b85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerBegin, <a class="el" href="structcaffe2_1_1_timer_begin_op.html">TimerBeginOp</a>)</td></tr>
<tr class="separator:a6f762eed64a7875a6caae9f43fbe6b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73b9c12c10069e14de4781ef1ea0dae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab73b9c12c10069e14de4781ef1ea0dae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerEnd, <a class="el" href="structcaffe2_1_1_timer_end_op.html">TimerEndOp</a>)</td></tr>
<tr class="separator:ab73b9c12c10069e14de4781ef1ea0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3b697e874e1137d79248796227788"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49b3b697e874e1137d79248796227788"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerGetAndEnd, <a class="el" href="structcaffe2_1_1_timer_get_and_end_op.html">TimerGetAndEndOp</a>)</td></tr>
<tr class="separator:a49b3b697e874e1137d79248796227788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec4b8457442b8958e7b79653dc6f47f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ec4b8457442b8958e7b79653dc6f47f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerGet, <a class="el" href="structcaffe2_1_1_timer_get_op.html">TimerGetOp</a>)</td></tr>
<tr class="separator:a0ec4b8457442b8958e7b79653dc6f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0022af2abe4c0e36bd72218913c49d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb0022af2abe4c0e36bd72218913c49d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CpuUtilizationReport, <a class="el" href="structcaffe2_1_1_cpu_utilization_report_op.html">CpuUtilizationReportOp</a>)</td></tr>
<tr class="separator:afb0022af2abe4c0e36bd72218913c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada795b1960e8d3ffe34b092ac0806418"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada795b1960e8d3ffe34b092ac0806418"></a>
or the global with the values of counters for the given keys DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;keys&quot;,&quot;1D string tensor with the key names to update.&quot;).Input(1</td></tr>
<tr class="separator:ada795b1960e8d3ffe34b092ac0806418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa23b57e12b7dc88039a836441541817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa23b57e12b7dc88039a836441541817"></a>
or the global with the values of counters for the given keys DOC int64 tensor with the values to update&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;handle&quot;,&quot;If provided, update the given StatRegistry. &quot;&quot;Otherwise, update the global singleton.&quot;)</td></tr>
<tr class="separator:afa23b57e12b7dc88039a836441541817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d980522c1c72552127407d3a5a3743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1d980522c1c72552127407d3a5a3743"></a>
If export values from given <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;keys&quot;,&quot;1D string tensor with exported key names&quot;).Output(1</td></tr>
<tr class="separator:ad1d980522c1c72552127407d3a5a3743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1af22e4a93991716a74fcd1196974f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add1af22e4a93991716a74fcd1196974f"></a>
If export values from given <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a> int64 tensor with exported values&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2,&quot;timestamps&quot;,&quot;The unix timestamp at counter retrieval.&quot;).Arg(&quot;reset&quot;</td></tr>
<tr class="separator:add1af22e4a93991716a74fcd1196974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919b0cf1eb33d15ec9271f07532b43e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad919b0cf1eb33d15ec9271f07532b43e"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;counter_name&quot;,&quot;Name of the timer. If not provided, use output name.&quot;).Output(0</td></tr>
<tr class="separator:ad919b0cf1eb33d15ec9271f07532b43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab440f01eea8bcdf39995a38c31228bb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab440f01eea8bcdf39995a38c31228bb0"></a>
publishing a CAFFE_EVENT&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;timer&quot;,&quot;Pointer to timer, obtained from TimerBegin.&quot;)</td></tr>
<tr class="separator:ab440f01eea8bcdf39995a38c31228bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15486037569b473f08c76f28096e1e14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15486037569b473f08c76f28096e1e14"></a>
Pointer to obtained from TimerBegin&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;nanos&quot;,&quot;nanoseconds in int64&quot;)</td></tr>
<tr class="separator:a15486037569b473f08c76f28096e1e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf686e94f9c0ec6d36a573a910bd964f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf686e94f9c0ec6d36a573a910bd964f"></a>
Delta in max CPU utilization in percentage as a float value&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;stats_name&quot;,&quot;String name of the stat entry holding CPU utilization&quot;)</td></tr>
<tr class="separator:aaf686e94f9c0ec6d36a573a910bd964f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af853c31c48049e4fb29e79f4a7dd7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6af853c31c48049e4fb29e79f4a7dd7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1_timer_instance.html">TimerInstance</a> *)</td></tr>
<tr class="separator:a6af853c31c48049e4fb29e79f4a7dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a81ede51ee5a53b2ae755e010c7bbd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a81ede51ee5a53b2ae755e010c7bbd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_stat_registry.html">caffe2::StatRegistry</a> &gt;)</td></tr>
<tr class="separator:a7a81ede51ee5a53b2ae755e010c7bbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9c44b3bbe9a0c7261d2fa150ed44f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c9c44b3bbe9a0c7261d2fa150ed44f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StopGradient, <a class="el" href="classcaffe2_1_1_stop_gradient_op.html">StopGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c9c44b3bbe9a0c7261d2fa150ed44f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70b4f20dad2d5a18250d99f5fc0e240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad70b4f20dad2d5a18250d99f5fc0e240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 1).NumOutputs(1</td></tr>
<tr class="separator:ad70b4f20dad2d5a18250d99f5fc0e240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f3e2378b53644049d680b1e2eacf51"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17f3e2378b53644049d680b1e2eacf51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (StopGradient)</td></tr>
<tr class="separator:a17f3e2378b53644049d680b1e2eacf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43c511fa3130c7afe22940995b8b5f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af43c511fa3130c7afe22940995b8b5f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (StopGradient, <a class="el" href="classcaffe2_1_1_stop_gradient_op.html">StopGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af43c511fa3130c7afe22940995b8b5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be8b7fdf68059a885842174018f40f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79be8b7fdf68059a885842174018f40f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Summarize, <a class="el" href="classcaffe2_1_1_summarize_op.html">SummarizeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a79be8b7fdf68059a885842174018f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7826f587099cb14ddf2e419bdf354548"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7826f587099cb14ddf2e419bdf354548"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Summarize computes four statistics of the input tensor (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;)- min,
max, mean and standard deviation. The output will be written to a 1-D tensor of
size 4 if an output tensor is provided. Else, if the argument 'to_file' is
greater than 0, the values are written to a log file in the root folder.
)DOC&quot;).Arg(&quot;to_file&quot;</td></tr>
<tr class="separator:a7826f587099cb14ddf2e419bdf354548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ede4ca8f090e962a709f19e7877206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03ede4ca8f090e962a709f19e7877206"></a>
default flag to indicate if the summarized statistics have to be written to a log file&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;data&quot;,&quot;The input data as <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;.&quot;).Output(0</td></tr>
<tr class="separator:a03ede4ca8f090e962a709f19e7877206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f680c65f7c60f730e3434de03a9d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557f680c65f7c60f730e3434de03a9d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Summarize)</td></tr>
<tr class="separator:a557f680c65f7c60f730e3434de03a9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec7c0f131c2bf28b3a0630c6760ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aec7c0f131c2bf28b3a0630c6760ac4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Swish, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float, double &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_swish_c_p_u_functor.html">SwishCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a4aec7c0f131c2bf28b3a0630c6760ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973504de09e21e287f4c07e100ebc990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a973504de09e21e287f4c07e100ebc990"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SwishGradient, <a class="el" href="classcaffe2_1_1_swish_gradient_op.html">SwishGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a973504de09e21e287f4c07e100ebc990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f588c2b952bc81bdb006316f4d7445"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74f588c2b952bc81bdb006316f4d7445"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SwishGradient takes X, Y and dY and uses this to update dX according to the
chain rule and derivatives of the swish function.
)DOC&quot;)</td></tr>
<tr class="separator:a74f588c2b952bc81bdb006316f4d7445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef8e2c5ad3aef552dd397e80a117924"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ef8e2c5ad3aef552dd397e80a117924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Swish, <a class="el" href="classcaffe2_1_1_get_swish_gradient.html">GetSwishGradient</a>)</td></tr>
<tr class="separator:a0ef8e2c5ad3aef552dd397e80a117924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bef3f22f81ae817a37dabf500d8f22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7bef3f22f81ae817a37dabf500d8f22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Tanh, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_tanh_c_p_u_functor.html">TanhCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:aa7bef3f22f81ae817a37dabf500d8f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b7293014acde03f55c62415e4fac1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a7b7293014acde03f55c62415e4fac1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TanhGradient, <a class="el" href="classcaffe2_1_1_binary_elementwise_op.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1_tensor_types.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1_without_broadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1_tanh_gradient_c_p_u_functor.html">TanhGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a5a7b7293014acde03f55c62415e4fac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f137244053c2518bf8b36b129a2e9ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f137244053c2518bf8b36b129a2e9ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TanhGradient).NumInputs(2).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:a3f137244053c2518bf8b36b129a2e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee5d1c143195645494061c4633bd99c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acee5d1c143195645494061c4633bd99c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Tanh, <a class="el" href="classcaffe2_1_1_get_tanh_gradient.html">GetTanhGradient</a>)</td></tr>
<tr class="separator:acee5d1c143195645494061c4633bd99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219c46db626227d4ff918d046d71f6de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a219c46db626227d4ff918d046d71f6de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a>, <a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a219c46db626227d4ff918d046d71f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d5eebb6c87e935c3d2a04966ad1b65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93d5eebb6c87e935c3d2a04966ad1b65"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a> is a simple input operator that basically reads things
from a db where each key-value pair stores an index as key, and a TensorProtos
object as value. These TensorProtos objects should have the same size, and they
will be grouped into batches of the given size. The DB Reader is provided as
input to the operator and it returns as many output tensors as the size of the
TensorProtos object. Each output will simply be a tensor containing a batch of
data with size specified by the 'batch_size' argument containing data from the
corresponding index in the TensorProtos objects in the DB.
)DOC&quot;).Arg(&quot;batch_size&quot;</td></tr>
<tr class="separator:a93d5eebb6c87e935c3d2a04966ad1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35c38ea3c93f0262c826ba9e68cc4b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad35c38ea3c93f0262c826ba9e68cc4b8"></a>
INT_MAX default the number of samples in a batch The default value of means that the&#160;</td><td class="memItemRight" valign="bottom"><b>operator will attempt to insert the&quot; &quot;entire data in a single output blob.&quot;) .Input</b> (0,&quot;data&quot;,&quot;A pre-initialized DB reader. Typically, this is obtained &quot;&quot;by calling CreateDB operator with a db_name and a db_type. The &quot;&quot;resulting output blob is a DB Reader tensor&quot;).Output(0</td></tr>
<tr class="separator:ad35c38ea3c93f0262c826ba9e68cc4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7748fe15bc09a061bf89e9a247e047b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7748fe15bc09a061bf89e9a247e047b"></a>
INT_MAX default the number of samples in a batch The default value of means that the The output tensor in which the batches of data are returned The number of output tensors is equal to the size&#160;</td><td class="memItemRight" valign="bottom"><b>of</b> (number of TensorProto's in) the TensorProtos objects stored in the&quot; &quot;DB as values.Each output tensor will be of size specified by the&quot; &quot;'batch_size'argument of the operator&quot;)</td></tr>
<tr class="separator:ad7748fe15bc09a061bf89e9a247e047b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92e600afc08d689214d6599a487711c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92e600afc08d689214d6599a487711c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a>)</td></tr>
<tr class="separator:ae92e600afc08d689214d6599a487711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7232ef46b5b3aec6fc354c6a405a69fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7232ef46b5b3aec6fc354c6a405a69fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a>, <a class="el" href="classcaffe2_1_1_tensor_protos_d_b_input.html">TensorProtosDBInput</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7232ef46b5b3aec6fc354c6a405a69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e805d96f97616cd7c18e7d907e68b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada8e805d96f97616cd7c18e7d907e68b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert</b> (TensorProto_DataType dst_type, const char *src_start, const char *src_end, void *dst)</td></tr>
<tr class="separator:ada8e805d96f97616cd7c18e7d907e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b6d215becf9a310049b4bb853f3a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56b6d215becf9a310049b4bb853f3a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1_text_file_reader_instance.html">TextFileReaderInstance</a> &gt;)</td></tr>
<tr class="separator:ab56b6d215becf9a310049b4bb853f3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9ee50ab7d20684506fa4dcbda07ed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf9ee50ab7d20684506fa4dcbda07ed6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateTextFileReader, <a class="el" href="classcaffe2_1_1_create_text_file_reader_op.html">CreateTextFileReaderOp</a>)</td></tr>
<tr class="separator:adf9ee50ab7d20684506fa4dcbda07ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfbe745c880086940762dea36c1e2a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5cfbe745c880086940762dea36c1e2a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TextFileReaderRead, <a class="el" href="classcaffe2_1_1_text_file_reader_read_op.html">TextFileReaderReadOp</a>)</td></tr>
<tr class="separator:a5cfbe745c880086940762dea36c1e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d6c3d33bdb04eae6c1c6f75b1e86a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d6c3d33bdb04eae6c1c6f75b1e86a9"></a>
Path to the file&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_passes&quot;,&quot;Number of passes over the file.&quot;).Arg(&quot;field_types&quot;</td></tr>
<tr class="separator:af6d6c3d33bdb04eae6c1c6f75b1e86a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d70e0e4f2ec0ab30e9748fa226ee11d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d70e0e4f2ec0ab30e9748fa226ee11d"></a>
Path to the file List with type of each field Type enum is found at core DataType&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;handler&quot;,&quot;Pointer to the created TextFileReaderInstance.&quot;)</td></tr>
<tr class="separator:a5d70e0e4f2ec0ab30e9748fa226ee11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6451fbf98f4e05b993bc4af56aeea1cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6451fbf98f4e05b993bc4af56aeea1cd"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Read a batch of rows from the given text file reader instance. &quot;&quot;Expects the number of fields to be equal to the number of outputs. &quot;&quot;Each output is a 1D tensor containing the values for the given field &quot;&quot;for each row. When end of file is reached, returns empty tensors.&quot;).Input(0</td></tr>
<tr class="separator:a6451fbf98f4e05b993bc4af56aeea1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a136d24eb740516b496943705ac3e5c7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a136d24eb740516b496943705ac3e5c7a"></a>
INT_MAX Pointer to an existing <a class="el" href="structcaffe2_1_1_text_file_reader_instance.html">TextFileReaderInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;batch_size&quot;,&quot;Maximum number of rows to read.&quot;)</td></tr>
<tr class="separator:a136d24eb740516b496943705ac3e5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2b51625c32a85bb9d121d9a2bf0e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a2b51625c32a85bb9d121d9a2bf0e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateTextFileReader)</td></tr>
<tr class="separator:ae2a2b51625c32a85bb9d121d9a2bf0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0caaac7cf5c9d7e053638babf99bdbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0caaac7cf5c9d7e053638babf99bdbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (TextFileReaderRead)</td></tr>
<tr class="separator:ab0caaac7cf5c9d7e053638babf99bdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb6e77295467e6a75b22d917da50f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bb6e77295467e6a75b22d917da50f71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ThresholdedRelu, <a class="el" href="classcaffe2_1_1_thresholded_relu_op.html">ThresholdedReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4bb6e77295467e6a75b22d917da50f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8e69a96cb294a7072d3345b30aa04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c8e69a96cb294a7072d3345b30aa04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ThresholdedReluGradient, <a class="el" href="classcaffe2_1_1_thresholded_relu_gradient_op.html">ThresholdedReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a19c8e69a96cb294a7072d3345b30aa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa5a4d8dd808966d05f02f0dfa93484"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aa5a4d8dd808966d05f02f0dfa93484"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (PointwiseCostInference&lt; 2 &gt;).IdenticalTypeAndShape().SetDoc(R&quot;DOC( ThresholdedRelu takes one input data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>) and produces one output data (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>) where the rectified linear function</td></tr>
<tr class="separator:a3aa5a4d8dd808966d05f02f0dfa93484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5b04811dbf39ebcee085bb455bfd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aced5b04811dbf39ebcee085bb455bfd7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Tile, <a class="el" href="classcaffe2_1_1_tile_op.html">TileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aced5b04811dbf39ebcee085bb455bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c74805ca38dba5dc29a0af8841557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f8c74805ca38dba5dc29a0af8841557"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TileGradient, <a class="el" href="classcaffe2_1_1_tile_gradient_op.html">TileGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0f8c74805ca38dba5dc29a0af8841557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d4a61e2de1126edd7197cf1e12bb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568d4a61e2de1126edd7197cf1e12bb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (in.size() &gt; 1)</td></tr>
<tr class="separator:a568d4a61e2de1126edd7197cf1e12bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a69515e1123cfcce23781a643803a22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a69515e1123cfcce23781a643803a22"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_dims</b> (canonical_axis, out[0].dims().Get(canonical_axis)*tiles)</td></tr>
<tr class="separator:a0a69515e1123cfcce23781a643803a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d5f3a227c2a7f52da688990b87c69b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7d5f3a227c2a7f52da688990b87c69b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Constructs a tensor by tiling a given tensor along a specified axis.

This operation creates a new tensor by replicating the input tensor 'tiles'
times along dimension 'axis'. The output tensor's 'axis'th dimension has
input.dims(axis) * tiles elements, and the values of input are replicated
'tiles' times along the 'axis'th dimension.
For example, tiling [[a b c d]] by tile=2, axis=0 produces
[[a b c d], [a b c d]].
)DOC&quot;).Arg(&quot;tiles&quot;</td></tr>
<tr class="separator:aa7d5f3a227c2a7f52da688990b87c69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd5960c9b40f55304ae96a20c9301fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfd5960c9b40f55304ae96a20c9301fa"></a>
Number of replicas&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis&quot;,&quot;Axis to replicate along&quot;).Input(0</td></tr>
<tr class="separator:acfd5960c9b40f55304ae96a20c9301fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864d32fce1370d24c2c8f827a6c620c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a864d32fce1370d24c2c8f827a6c620c6"></a>
Number of replicas The input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;tiles&quot;,&quot;(optional) Number of replicas (overrides argument)&quot;).Input(2</td></tr>
<tr class="separator:a864d32fce1370d24c2c8f827a6c620c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36426f3160b822cda69b21b2bc4bbff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36426f3160b822cda69b21b2bc4bbff7"></a>
Number of replicas The input tensor optional Axis to replicate&#160;</td><td class="memItemRight" valign="bottom"><b>along</b> (overrides argument)&quot;) .Output( 0</td></tr>
<tr class="separator:a36426f3160b822cda69b21b2bc4bbff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b19f8c7e52f0be20be3e3ac9b79499f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b19f8c7e52f0be20be3e3ac9b79499f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TileGradient).NumInputs(1</td></tr>
<tr class="separator:a0b19f8c7e52f0be20be3e3ac9b79499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75898e19a1c52e1528eb3440a208de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf75898e19a1c52e1528eb3440a208de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Tile, <a class="el" href="classcaffe2_1_1_get_tile_gradient.html">GetTileGradient</a>)</td></tr>
<tr class="separator:adf75898e19a1c52e1528eb3440a208de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b28296fcf9749bca35b17dbfc2a2ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b28296fcf9749bca35b17dbfc2a2ba1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TopK, <a class="el" href="classcaffe2_1_1_top_k_op.html">TopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4b28296fcf9749bca35b17dbfc2a2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b405ba4c8182efbaea6a6905633e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a990b405ba4c8182efbaea6a6905633e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TopKGradient, <a class="el" href="classcaffe2_1_1_top_k_gradient_op.html">TopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a990b405ba4c8182efbaea6a6905633e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdf9c82b71b4c47571973d473f611cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fdf9c82b71b4c47571973d473f611cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){vector&lt; TensorShape &gt; out={in[0], in[0]};<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);auto k=helper.GetSingleArgument(&quot;k&quot;,-1);auto dims_size=in[0].dims_size();out[0].set_dims(dims_size-1, k);out[1].set_dims(dims_size-1, k);out[1].set_data_type(TensorProto_DataType_INT32);if(def.output_size() &gt; 2){TensorShape flatten_indices_shape;flatten_indices_shape.set_data_type(TensorProto_DataType_INT32);flatten_indices_shape.add_dims(std::accumulate(in[0].dims().begin(), in[0].dims().end()-1, 1, std::multiplies&lt; long &gt;())*k);out.push_back(flatten_indices_shape);}return out;}).SetDoc(R&quot;DOC( Retrieve the top-K elements for the last dimension. Given an input tensor of shape [a_1</td></tr>
<tr class="separator:a4fdf9c82b71b4c47571973d473f611cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889fd2d5ca3386068e81ff791d0f6877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889fd2d5ca3386068e81ff791d0f6877"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1_index.html">Index</a> tensor of shape[a_1, a_2,..., a_n, k] which contains the indices of the top k&#160;</td><td class="memItemRight" valign="bottom"><b>elements</b> (original indices from the input tensor).Given two equivalent values</td></tr>
<tr class="separator:a889fd2d5ca3386068e81ff791d0f6877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9defa577ae8b79d96a6e491dd5b2cb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9defa577ae8b79d96a6e491dd5b2cb1"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1_index.html">Index</a> tensor of shape[a_1, a_2,..., a_n, k] which contains the indices of the top k this&#160;</td><td class="memItemRight" valign="bottom"><b>operator uses the indices along the last dim-ension as a tiebreaker.That is, the element with the lower index will appear first.) DOC&quot;) .Input</b> (0,&quot;X&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of shape [a_1, a_2, ..., a_n, r]&quot;).Output(0</td></tr>
<tr class="separator:af9defa577ae8b79d96a6e491dd5b2cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882cd7b44c9ac56f4eb29b9d30636a75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a882cd7b44c9ac56f4eb29b9d30636a75"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1_index.html">Index</a> tensor of shape[a_1, a_2,..., a_n, k] which contains the indices of the top k this <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of shape[a_1, a_2,..., a_n, k] containing top K values from the input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;Indices&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of shape [a_1, a_2, ..., a_n, k] containing&quot;&quot; the corresponding input tensor indices for the top K values.&quot;).Output(2</td></tr>
<tr class="separator:a882cd7b44c9ac56f4eb29b9d30636a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ec32728ca99a91a6008e4ca4e2f5b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3ec32728ca99a91a6008e4ca4e2f5b5"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1_index.html">Index</a> tensor of shape[a_1, a_2,..., a_n, k] which contains the indices of the top k this <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of shape[a_1, a_2,..., a_n, k] containing top K values from the input tensor Flatten <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of shape[a_1 *a_2 *...*a_n *k] containing the indices into the flatten input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;k&quot;,&quot;Number of top elements to retrieve&quot;)</td></tr>
<tr class="separator:aa3ec32728ca99a91a6008e4ca4e2f5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3da3e59a50ff7ae720341129e89b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc3da3e59a50ff7ae720341129e89b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TopKGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:affc3da3e59a50ff7ae720341129e89b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33c32b9ceb4778f282b50465e3687fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af33c32b9ceb4778f282b50465e3687fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (TopK, <a class="el" href="classcaffe2_1_1_get_top_k_gradient.html">GetTopKGradient</a>)</td></tr>
<tr class="separator:af33c32b9ceb4778f282b50465e3687fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0487b1160adba1852af6eef9181d7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf0487b1160adba1852af6eef9181d7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Transpose, <a class="el" href="classcaffe2_1_1_transpose_op.html">TransposeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adf0487b1160adba1852af6eef9181d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f489cfb91e4c05e08ba01fc596af21a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f489cfb91e4c05e08ba01fc596af21a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (axes.empty())</td></tr>
<tr class="separator:a4f489cfb91e4c05e08ba01fc596af21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc48b7eafb065688a641e2fbd13fdc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fc48b7eafb065688a641e2fbd13fdc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (valid_axes,&quot;Axes argument passed in had invalid values&quot;)</td></tr>
<tr class="separator:a8fc48b7eafb065688a641e2fbd13fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af209e13d35f1d704be21702b622f33f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af209e13d35f1d704be21702b622f33f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (axes.size()==tensor_size,&quot;Axes argument passed in had the incorrect size&quot;)</td></tr>
<tr class="separator:af209e13d35f1d704be21702b622f33f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bcaaa8592fc67c999a17c5f39daa3a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bcaaa8592fc67c999a17c5f39daa3a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (auto axis=axes.begin();axis!=axes.end();++axis)</td></tr>
<tr class="separator:a3bcaaa8592fc67c999a17c5f39daa3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64d201f43cf151d465c01c7e1835a21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64d201f43cf151d465c01c7e1835a21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Transpose the input tensor similar to numpy.transpose. For example, when
axes=(1, 0, 2), given an input tensor of shape (1, 2, 3), the output shape
will be (2, 1, 3).
)DOC&quot;).Arg(&quot;axes&quot;</td></tr>
<tr class="separator:ad64d201f43cf151d465c01c7e1835a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8886b5fffc193adc7678c913d0739052"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8886b5fffc193adc7678c913d0739052"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Transpose, <a class="el" href="classcaffe2_1_1_get_transpose_gradient.html">GetTransposeGradient</a>)</td></tr>
<tr class="separator:a8886b5fffc193adc7678c913d0739052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f4078c9362f6abbf685aa1c1b5ca9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10f4078c9362f6abbf685aa1c1b5ca9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Transpose, <a class="el" href="classcaffe2_1_1_cu_d_n_n_transpose_op.html">CuDNNTransposeOp</a>)</td></tr>
<tr class="separator:a10f4078c9362f6abbf685aa1c1b5ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b46540691eb1afcf1547e3a91b57a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b46540691eb1afcf1547e3a91b57a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WallClockTime, <a class="el" href="classcaffe2_1_1_wall_clock_time_op.html">WallClockTimeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae4b46540691eb1afcf1547e3a91b57a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89258398f3cc3618d00035f0230dd47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad89258398f3cc3618d00035f0230dd47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Print, <a class="el" href="classcaffe2_1_1_print_op.html">PrintOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad89258398f3cc3618d00035f0230dd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ac7ca6bb4e5c58248527effc9755c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a520ac7ca6bb4e5c58248527effc9755c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlattenToVec, <a class="el" href="classcaffe2_1_1_flatten_to_vec_op.html">FlattenToVecOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a520ac7ca6bb4e5c58248527effc9755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33a021e8766ed8a069056a5fef6a219"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab33a021e8766ed8a069056a5fef6a219"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Alias, <a class="el" href="classcaffe2_1_1_alias_op.html">AliasOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab33a021e8766ed8a069056a5fef6a219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c902c10fcc4c740225d2e92d23ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99c902c10fcc4c740225d2e92d23ac4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeLike, <a class="el" href="classcaffe2_1_1_resize_like_op.html">ResizeLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac99c902c10fcc4c740225d2e92d23ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c5967b5a9c33819f0d47045f7fed6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1c5967b5a9c33819f0d47045f7fed6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumInt, <a class="el" href="classcaffe2_1_1_sum_op.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad1c5967b5a9c33819f0d47045f7fed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177ef4037d8a1560bd61c47798c4a078"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177ef4037d8a1560bd61c47798c4a078"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSum, <a class="el" href="classcaffe2_1_1_weighted_sum_op.html">WeightedSumOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a177ef4037d8a1560bd61c47798c4a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce6d9f20ad9b777c83ff28add34965"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fce6d9f20ad9b777c83ff28add34965"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSumGradient, <a class="el" href="classcaffe2_1_1_weighted_sum_gradient_op.html">WeightedSumGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4fce6d9f20ad9b777c83ff28add34965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfff336193d2ecb5fa64f5a36cf434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cbfff336193d2ecb5fa64f5a36cf434"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ScatterWeightedSum, <a class="el" href="classcaffe2_1_1_scatter_weighted_sum_op.html">ScatterWeightedSumOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8cbfff336193d2ecb5fa64f5a36cf434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046774787ee2fa03fc8c3285426e2520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a046774787ee2fa03fc8c3285426e2520"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ScatterAssign, <a class="el" href="classcaffe2_1_1_scatter_assign_op.html">ScatterAssignOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a046774787ee2fa03fc8c3285426e2520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb1145c431471e3eef480fc3dedd18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ccb1145c431471e3eef480fc3dedd18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnsureCPUOutput, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6ccb1145c431471e3eef480fc3dedd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f258716b43bd475dc13f904120f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af31f258716b43bd475dc13f904120f9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyFromCPUInput, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af31f258716b43bd475dc13f904120f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d36b3549f883e3cd6e53b36ba1a94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f6d36b3549f883e3cd6e53b36ba1a94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyOnDeviceLike, <a class="el" href="classcaffe2_1_1_copy_on_device_like_op.html">CopyOnDeviceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5f6d36b3549f883e3cd6e53b36ba1a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8819d12f475637364ebbe942e8a3e1bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8819d12f475637364ebbe942e8a3e1bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Copy, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8819d12f475637364ebbe942e8a3e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815977f8c140f506d4fc3792180a1d43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a815977f8c140f506d4fc3792180a1d43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToShape, <a class="el" href="classcaffe2_1_1_lengths_to_shape_op.html">LengthsToShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a815977f8c140f506d4fc3792180a1d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b807d8754dc2e4cb8eb0888b87c21e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b807d8754dc2e4cb8eb0888b87c21e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (HasElements, <a class="el" href="classcaffe2_1_1_has_elements_op.html">HasElementsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a85b807d8754dc2e4cb8eb0888b87c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b03b3eeecbe0cc9e4804846d8a691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c4b03b3eeecbe0cc9e4804846d8a691"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IsEmpty, <a class="el" href="classcaffe2_1_1_is_empty_op.html">IsEmptyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c4b03b3eeecbe0cc9e4804846d8a691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e76112be57bae9b1bd0c999bce8b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e76112be57bae9b1bd0c999bce8b18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Gather, <a class="el" href="classcaffe2_1_1_gather_op.html">GatherOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af3e76112be57bae9b1bd0c999bce8b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77929d08f345c156764caa27cd657179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77929d08f345c156764caa27cd657179"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GatherRanges, <a class="el" href="classcaffe2_1_1_gather_ranges_op.html">GatherRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a77929d08f345c156764caa27cd657179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98b44084f36957d000676d1a9c92a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd98b44084f36957d000676d1a9c92a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsGather, <a class="el" href="classcaffe2_1_1_lengths_gather_op.html">LengthsGatherOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acd98b44084f36957d000676d1a9c92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9625fbfbca8dffa2b0b5523a796a61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc9625fbfbca8dffa2b0b5523a796a61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Unique, <a class="el" href="classcaffe2_1_1_unique_op.html">UniqueOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afc9625fbfbca8dffa2b0b5523a796a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814526a9f15708d215ba04a8a89173f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a814526a9f15708d215ba04a8a89173f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToSegmentIds, <a class="el" href="classcaffe2_1_1_lengths_to_segment_ids_op.html">LengthsToSegmentIdsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a814526a9f15708d215ba04a8a89173f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2775339e1ddc54710638bb4be2307b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2775339e1ddc54710638bb4be2307b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToRanges, <a class="el" href="classcaffe2_1_1_lengths_to_ranges_op.html">LengthsToRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad2775339e1ddc54710638bb4be2307b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64450dcd999e7cd2ca206f6c5c74f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad64450dcd999e7cd2ca206f6c5c74f54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentIdsToLengths, <a class="el" href="classcaffe2_1_1_segment_ids_to_lengths_op.html">SegmentIdsToLengthsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad64450dcd999e7cd2ca206f6c5c74f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48089cf88fff8b981d2a274ca69fb3bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48089cf88fff8b981d2a274ca69fb3bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentIdsToRanges, <a class="el" href="classcaffe2_1_1_segment_ids_to_ranges_op.html">SegmentIdsToRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a48089cf88fff8b981d2a274ca69fb3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d34cf4fe5bc72c7f4ef5b16bfa5ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af56d34cf4fe5bc72c7f4ef5b16bfa5ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToWeights, <a class="el" href="classcaffe2_1_1_lengths_to_weights_op.html">LengthsToWeightsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af56d34cf4fe5bc72c7f4ef5b16bfa5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af8be33595de71a93f223fdf520d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6af8be33595de71a93f223fdf520d82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnsureDense, <a class="el" href="classcaffe2_1_1_ensure_dense_op.html">EnsureDenseOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae6af8be33595de71a93f223fdf520d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77aa2a71bc9ba02ed8e43b70d5dad1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad77aa2a71bc9ba02ed8e43b70d5dad1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AccumulateHistogram, <a class="el" href="classcaffe2_1_1_accumulate_histogram_op.html">AccumulateHistogramOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad77aa2a71bc9ba02ed8e43b70d5dad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d10e655f4b3f8ebfc33fe7cb0cba57"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d10e655f4b3f8ebfc33fe7cb0cba57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UnsafeCoalesce, <a class="el" href="classcaffe2_1_1_unsafe_coalesce_op.html">UnsafeCoalesceOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a63d10e655f4b3f8ebfc33fe7cb0cba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d028e7c5263a8f3794b4f1084f0bd0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d028e7c5263a8f3794b4f1084f0bd0c"></a>
bool saves contents to the root folder of the current appending the tensor contents to a file named after the blob name logs to stderr&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;tensor&quot;,&quot;The tensor to print.&quot;)</td></tr>
<tr class="separator:a3d028e7c5263a8f3794b4f1084f0bd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353a20a1cfc55a53677f008197e8a57c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a353a20a1cfc55a53677f008197e8a57c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsToShape).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:a353a20a1cfc55a53677f008197e8a57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97957c09ab68e82c773d83375dc3bd0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97957c09ab68e82c773d83375dc3bd0a"></a>
out[0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (total)</td></tr>
<tr class="separator:a97957c09ab68e82c773d83375dc3bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37dfc7b79cd53ab3663af4aaf82fd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab37dfc7b79cd53ab3663af4aaf82fd4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Flattens the input tensor into a 1D vector.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:ab37dfc7b79cd53ab3663af4aaf82fd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81287a9a7cfabd88c3be7ed7626eb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d81287a9a7cfabd88c3be7ed7626eb3"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (in[1])</td></tr>
<tr class="separator:a5d81287a9a7cfabd88c3be7ed7626eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8b6fe6bf084372f5a26e08fd6c8af5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a8b6fe6bf084372f5a26e08fd6c8af5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Produces tensor containing data of first input and shape of second input.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a5a8b6fe6bf084372f5a26e08fd6c8af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711e9e63e2f83220dc2a3ebf346e4f7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a711e9e63e2f83220dc2a3ebf346e4f7a"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> whose data will be copied into the output&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;shape_tensor&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> whose shape will be applied to output.&quot;).Output(0</td></tr>
<tr class="separator:a711e9e63e2f83220dc2a3ebf346e4f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0eeea85bbf3f975b6fbac051e499a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e0eeea85bbf3f975b6fbac051e499a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n){return(n &gt; 0 &amp;&amp;n%2==0);}).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:a5e0eeea85bbf3f975b6fbac051e499a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639aee7be00859d8dbc5f64fbe5156ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639aee7be00859d8dbc5f64fbe5156ca"></a>
weight tensor pairs Input should be in the form where X_i all have the same and weight_i are size tensors that specifies the weight of each vector Note that if one wants to do in place it could only be done with X_0 also as the but not other X_i DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;data_0&quot;,&quot;First of the input tensors.&quot;).Input(0</td></tr>
<tr class="separator:a639aee7be00859d8dbc5f64fbe5156ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826378011450737713364a37f4f33f26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826378011450737713364a37f4f33f26"></a>
weight tensor pairs Input should be in the form where X_i all have the same and weight_i are size tensors that specifies the weight of each vector Note that if one wants to do in place it could only be done with X_0 also as the but not other X_i DOC Weight of the first input in the sum&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output&quot;,&quot;Result containing weighted elem-wise sum of inputs.&quot;)</td></tr>
<tr class="separator:a826378011450737713364a37f4f33f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d91a8192b82f9c5be4dd70bbe6b926"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d91a8192b82f9c5be4dd70bbe6b926"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n){return(n &gt; 0 &amp;&amp;n%2==1);}).NumOutputs(1</td></tr>
<tr class="separator:a15d91a8192b82f9c5be4dd70bbe6b926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f44204c3bd9e4b40d0ae331f975998"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f44204c3bd9e4b40d0ae331f975998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n){return(n &gt; 3 &amp;&amp;(n-3)%2==0);}).NumOutputs(1).EnforceInplace(</td></tr>
<tr class="separator:a09f44204c3bd9e4b40d0ae331f975998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7964fdfdf5d72881b28d1dab56ffd37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7964fdfdf5d72881b28d1dab56ffd37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Similar to WeightedSum, computes the weighted sum of several tensors, with
the difference that inputs are sliced tensors. The first tensor has to be
in-place and only slices of it on the first dimension as indexed by INDICES
will be updated.

Note: The op pretty much ignores the exact shapes of the input arguments and
cares only about sizes. It's done for performance consideration to avoid
unnecessary reshapes. Only first dimension of X_0 is important, let's call it
N. If M is the total size of X_0 and K is the size of INDICES then X_i is
assumed to be of shape K x (M / N) regardless of the real shape.

Note: Each update in INDICES is applied independently which means that if
duplicated elements are present in INDICES the corresponding slice of X_0
will be scaled multiple times. Manual collapsing of INDICES is required
beforehand if necessary.

Note: Updates are applied sequentially by inputs which might have undesired
consequences if the input tensor is accessed concurrently by different op
(e.g. when doing Hogwild). Other threads might see intermediate results even
on individual slice level, e.g. X_0 scaled by weight_0 but without any
updates applied.

Currently only works on CPU because of access to INDICES.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:af7964fdfdf5d72881b28d1dab56ffd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa98ccefa11d45024d7b66c6b926a3cd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa98ccefa11d45024d7b66c6b926a3cd2"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;Weight_0&quot;,&quot;Scalar weight for X_0, applied only to slices affected.&quot;).Input(2</td></tr>
<tr class="separator:aa98ccefa11d45024d7b66c6b926a3cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70ef7a82862391022e52e5bf0e5a11e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab70ef7a82862391022e52e5bf0e5a11e"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;X_1&quot;,&quot;Update slices, with shape len(INDICES) + shape(X_0)[1:]&quot;).Input(4</td></tr>
<tr class="separator:ab70ef7a82862391022e52e5bf0e5a11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7806ff46c135d2200c210419ed4072b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7806ff46c135d2200c210419ed4072b2"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated Scalar weight for X_1 update&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;X_0&quot;,&quot;Has to be exactly the same tensor as the input 0&quot;).EnforceInplace(</td></tr>
<tr class="separator:a7806ff46c135d2200c210419ed4072b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7653da6cf4688028240b1b9127ad83aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7653da6cf4688028240b1b9127ad83aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Update slices of the tensor in-place by overriding current value.

Note: The op pretty much ignores the exact shapes of the input arguments and
cares only about sizes. It's done for performance consideration to avoid
unnecessary reshapes. Only first dimension of X_0 is important, let's call it
N. If M is the total size of X_0 and K is the size of INDICES then X_i is
assumed to be of shape K x (M / N) regardless of the real shape.

Note: Each update in INDICES is applied independently which means that if
duplicated elements are present in INDICES arbitrary one will win.

Currently only works on CPU because of access to INDICES.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a7653da6cf4688028240b1b9127ad83aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27d876963ec61d2055b85859306f6f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27d876963ec61d2055b85859306f6f0"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;INDICES&quot;,&quot;1-D list of indices on the first dimension&quot;&quot;of X_0 that need to be updated&quot;).Input(2</td></tr>
<tr class="separator:ac27d876963ec61d2055b85859306f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e34bb7fd859f44abd71fed1f5981b4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e34bb7fd859f44abd71fed1f5981b4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Print, <a class="el" href="classcaffe2_1_1_print_op.html">PrintOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0e34bb7fd859f44abd71fed1f5981b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a437cf85dd21af2b2b6da5149f58da7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a437cf85dd21af2b2b6da5149f58da7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Flatten, <a class="el" href="classcaffe2_1_1_flatten_op.html">FlattenOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a5a437cf85dd21af2b2b6da5149f58da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f32fed087f9dc83b0f6a0e74bd622b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7f32fed087f9dc83b0f6a0e74bd622b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FlattenToVec, <a class="el" href="classcaffe2_1_1_flatten_to_vec_op.html">FlattenToVecOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ab7f32fed087f9dc83b0f6a0e74bd622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b3668843cb4ec89c047ed7677b89ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50b3668843cb4ec89c047ed7677b89ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Alias, <a class="el" href="classcaffe2_1_1_alias_op.html">AliasOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a50b3668843cb4ec89c047ed7677b89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70158fdfb357723e27860b8c3507083"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af70158fdfb357723e27860b8c3507083"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ResizeLike, <a class="el" href="classcaffe2_1_1_resize_like_op.html">ResizeLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af70158fdfb357723e27860b8c3507083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1055817e3eed3d9c60ad2e8730123458"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1055817e3eed3d9c60ad2e8730123458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Sum, <a class="el" href="classcaffe2_1_1_sum_op.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a1055817e3eed3d9c60ad2e8730123458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c937fe941261e4ba28926f3d7457a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c937fe941261e4ba28926f3d7457a23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (WeightedSum, <a class="el" href="classcaffe2_1_1_weighted_sum_op.html">WeightedSumOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6c937fe941261e4ba28926f3d7457a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00eb2d0451f20575c498ee0659a787"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac00eb2d0451f20575c498ee0659a787"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (EnsureCPUOutput, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aac00eb2d0451f20575c498ee0659a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7af60bdd53c299221823ee67c0b0fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7af60bdd53c299221823ee67c0b0fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyFromCPUInput, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5e7af60bdd53c299221823ee67c0b0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c7f776bc8597b6d7d97bf978cdc42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c4c7f776bc8597b6d7d97bf978cdc42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyGPUToCPU, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2c4c7f776bc8597b6d7d97bf978cdc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c78b2ae6f9ce5caa570e569c016073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2c78b2ae6f9ce5caa570e569c016073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyCPUToGPU, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad2c78b2ae6f9ce5caa570e569c016073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a2a2d46d6b7db1bbce4b7f35bb23bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4a2a2d46d6b7db1bbce4b7f35bb23bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Copy, <a class="el" href="classcaffe2_1_1_copy_op.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ac4a2a2d46d6b7db1bbce4b7f35bb23bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876c6e9c8491246510c810133aa0df4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4876c6e9c8491246510c810133aa0df4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyOnDeviceLike, <a class="el" href="classcaffe2_1_1_copy_on_device_like_op.html">CopyOnDeviceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a4876c6e9c8491246510c810133aa0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f45f2abd3fc143dcb7a7ca3b241a4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f45f2abd3fc143dcb7a7ca3b241a4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (UnsafeCoalesce, <a class="el" href="classcaffe2_1_1_unsafe_coalesce_op.html">UnsafeCoalesceOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ac3f45f2abd3fc143dcb7a7ca3b241a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6501a13281b3ddeb0f98f331e6fcb054"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6501a13281b3ddeb0f98f331e6fcb054"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (VariableLengthSequencePadding, <a class="el" href="classcaffe2_1_1_variable_length_sequence_padding_op.html">VariableLengthSequencePaddingOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6501a13281b3ddeb0f98f331e6fcb054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6925ed9748e4f3062b408f893bc0205"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6925ed9748e4f3062b408f893bc0205"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Super special-case operator. Used to pad a tensor to mimic pytorch's
pad_packed_sequence.

Given an input tensor INPUT of size NxBxM and an input tensor LENS
of size B, where

N = maximum sequence length
B = batch size
M = hidden size

set each element of INPUT to zero if it is is past the end of the
corresponding sequence (i.e. if LENS[j] &gt; i for an index (i,j,k)).

)DOC&quot;)</td></tr>
<tr class="separator:aa6925ed9748e4f3062b408f893bc0205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab079c71ac67fe9eb47f08939c74314cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab079c71ac67fe9eb47f08939c74314cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSample, <a class="el" href="classcaffe2_1_1_weighted_sample_op.html">WeightedSampleOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab079c71ac67fe9eb47f08939c74314cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc8abe934719c57991242ee632e2cab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bc8abe934719c57991242ee632e2cab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in){vector&lt; TensorShape &gt; out(2);int batch_size=in[0].dims(0);out[0]=CreateTensorShape(vector&lt; int &gt;{batch_size}, TensorProto::INT32);out[1]=CreateTensorShape(vector&lt; int &gt;{batch_size}, TensorProto::FLOAT);return out;}).SetDoc(R&quot;DOC( The operator performs sampling based on the input sampling weights for each batch. All weights must be non-negative numbers. The input is a 2-D tensor (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt;float&gt;) of size (batch_size x weights_dim). For each batch</td></tr>
<tr class="separator:a1bc8abe934719c57991242ee632e2cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd9b9f239c167c0cef4c250b6b577a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88cd9b9f239c167c0cef4c250b6b577a"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; int &gt;) of size(batch_size x 1) and contains the index(es) of the sampled output.) DOC&quot;) .Input( 0</td></tr>
<tr class="separator:a88cd9b9f239c167c0cef4c250b6b577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e38482da15b79bedd92d89154455d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae0e38482da15b79bedd92d89154455d"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (batch_size x weights_dim).&quot; &quot;All weights must be non-negative numbers.&quot;) .Input( 1</td></tr>
<tr class="separator:aae0e38482da15b79bedd92d89154455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9595ed908897a80976049b68a734b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c9595ed908897a80976049b68a734b1"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> (es) sampled from distribution given&quot; &quot;by the weight vector(s) in the input tensor&quot; &quot;The output is a 1-D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; int &gt; of size(batch_size x 1)&quot;) .Output( 1</td></tr>
<tr class="separator:a1c9595ed908897a80976049b68a734b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8987c943fb4b39ed176c1daf3648fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac8987c943fb4b39ed176c1daf3648fd"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (s) selected by the sampled index(es)&quot; &quot;It is a 1-D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of size(batch_size x 1)&quot;)</td></tr>
<tr class="separator:aac8987c943fb4b39ed176c1daf3648fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c809c643823734ab57c3a85a5e9170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76c809c643823734ab57c3a85a5e9170"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (WeightedSample)</td></tr>
<tr class="separator:a76c809c643823734ab57c3a85a5e9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ffa79682074513d591e377397b042"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a102ffa79682074513d591e377397b042"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (While, <a class="el" href="classcaffe2_1_1_while_op.html">WhileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a102ffa79682074513d591e377397b042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10960ed9ca2cd58c3a11246a399403c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10960ed9ca2cd58c3a11246a399403c3"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'While' control operator, first input is a scalar boolean blob that stores loop's
condition value. Accepts 'loop_net' (required) and 'cond_net' (optional) arguments for
loop's body and condition subnets respectively. If condition subnet is specified,
it is executed before the first and after each iteration. Subnets are executed in
the same workspace as 'While'.
    )DOC&quot;).Arg(&quot;loop_net&quot;</td></tr>
<tr class="separator:a10960ed9ca2cd58c3a11246a399403c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f51b13606550f3cfd379146a552809c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f51b13606550f3cfd379146a552809c"></a>
INT_MAX Net executed on each iteration&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;cond_net&quot;,&quot;Net to (re)compute condition value&quot;).Input(0</td></tr>
<tr class="separator:a5f51b13606550f3cfd379146a552809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21c6c1b8416cc320cd2a77b367d632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f21c6c1b8416cc320cd2a77b367d632"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (While, <a class="el" href="classcaffe2_1_1_while_op.html">WhileOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6f21c6c1b8416cc320cd2a77b367d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f526c762e31c803fbb22e25978d1ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86f526c762e31c803fbb22e25978d1ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ZeroGradient, <a class="el" href="classcaffe2_1_1_zero_gradient_op.html">ZeroGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a86f526c762e31c803fbb22e25978d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada778193a182df6ced292b0e04f500a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada778193a182df6ced292b0e04f500a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ZeroGradient, <a class="el" href="structcaffe2_1_1_get_zero_gradient_op_gradient.html">GetZeroGradientOpGradient</a>)</td></tr>
<tr class="separator:ada778193a182df6ced292b0e04f500a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61627ee70d1645f2d0cd56fb0f46e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa61627ee70d1645f2d0cd56fb0f46e08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ZeroGradient, <a class="el" href="classcaffe2_1_1_zero_gradient_op.html">ZeroGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa61627ee70d1645f2d0cd56fb0f46e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f5d9b0facc3fe62f20059c681557a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90f5d9b0facc3fe62f20059c681557a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, float, float)</td></tr>
<tr class="separator:a90f5d9b0facc3fe62f20059c681557a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fcea1bec7e99f4f453c2721376aded"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54fcea1bec7e99f4f453c2721376aded"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, float, float)</td></tr>
<tr class="separator:a54fcea1bec7e99f4f453c2721376aded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715ff1b09f2313843be9f2f1a389f966"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a715ff1b09f2313843be9f2f1a389f966"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, float16, float)</td></tr>
<tr class="separator:a715ff1b09f2313843be9f2f1a389f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e20503a4304a1b0283fd66ffff8f4a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e20503a4304a1b0283fd66ffff8f4a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, float16, float)</td></tr>
<tr class="separator:a8e20503a4304a1b0283fd66ffff8f4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4180d52576f9f6723e4fe7364af9104e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4180d52576f9f6723e4fe7364af9104e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, uint8_t, float)</td></tr>
<tr class="separator:a4180d52576f9f6723e4fe7364af9104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae567c2ddecf3c2fe288935120e6e03be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae567c2ddecf3c2fe288935120e6e03be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, uint8_t, float)</td></tr>
<tr class="separator:ae567c2ddecf3c2fe288935120e6e03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df473adce0513ec1ed647ed7673fab5"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename InType , typename OutType &gt; </td></tr>
<tr class="memitem:a5df473adce0513ec1ed647ed7673fab5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5df473adce0513ec1ed647ed7673fab5">EmbeddingLookup</a> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const InType *input, const IndexType *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, OutType *out)</td></tr>
<tr class="memdesc:a5df473adce0513ec1ed647ed7673fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embedding lookup with reduction.  <a href="#a5df473adce0513ec1ed647ed7673fab5">More...</a><br /></td></tr>
<tr class="separator:a5df473adce0513ec1ed647ed7673fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e4d37453d19d43640bf45774924ebb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e4d37453d19d43640bf45774924ebb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:af6e4d37453d19d43640bf45774924ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcaa8ed9e20bb1ce71a332c87e89886"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafcaa8ed9e20bb1ce71a332c87e89886"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:aafcaa8ed9e20bb1ce71a332c87e89886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace643f72bac033199df10d71904c9a52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace643f72bac033199df10d71904c9a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:ace643f72bac033199df10d71904c9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d44ef6a1de5e519baf96dd39f8d2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d8d44ef6a1de5e519baf96dd39f8d2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a1d8d44ef6a1de5e519baf96dd39f8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1610953d85200cb50aa5c1bb39fe73b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1610953d85200cb50aa5c1bb39fe73b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:af1610953d85200cb50aa5c1bb39fe73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32570002aa4e0bb8bd603c8295c019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d32570002aa4e0bb8bd603c8295c019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a2d32570002aa4e0bb8bd603c8295c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08516e302cb5ff3c2e67c05e90bc78a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08516e302cb5ff3c2e67c05e90bc78a5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int32_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int32_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a08516e302cb5ff3c2e67c05e90bc78a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8841b881c25ed8e1b2c1ca8b22240eb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8841b881c25ed8e1b2c1ca8b22240eb8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int64_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int64_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a8841b881c25ed8e1b2c1ca8b22240eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01268f9eea6d320bc38226cdddab85d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01268f9eea6d320bc38226cdddab85d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int32_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int32_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:aa01268f9eea6d320bc38226cdddab85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9a69d5205ffce75d14563c8b5d4172"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe9a69d5205ffce75d14563c8b5d4172"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int64_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int64_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:afe9a69d5205ffce75d14563c8b5d4172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aaf86f95f564aa82165772ac0b74395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2aaf86f95f564aa82165772ac0b74395"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int32_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int32_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a2aaf86f95f564aa82165772ac0b74395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690d8f5dd7933f33323ab8fd43a7c0f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a690d8f5dd7933f33323ab8fd43a7c0f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Fused8BitRowwiseEmbeddingLookup_int64_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int64_t *indices, const int *lengths, const float *weights, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a690d8f5dd7933f33323ab8fd43a7c0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b048814093928f6943a18bdcc7423f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b048814093928f6943a18bdcc7423f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FUSED_8BIT_ROWWISE_EMBEDDING_SPECIALIZATION</b> (int32_t, uint8_t, float)</td></tr>
<tr class="separator:a5b048814093928f6943a18bdcc7423f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6e4a0a60fc6b9ab2d496a161a656f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6e4a0a60fc6b9ab2d496a161a656f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FUSED_8BIT_ROWWISE_EMBEDDING_SPECIALIZATION</b> (int64_t, uint8_t, float)</td></tr>
<tr class="separator:a3d6e4a0a60fc6b9ab2d496a161a656f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaf346b2578e6a4300823adc211ca26"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename InType , typename OutType &gt; </td></tr>
<tr class="memitem:a3aaf346b2578e6a4300823adc211ca26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3aaf346b2578e6a4300823adc211ca26">Fused8BitRowwiseEmbeddingLookup</a> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const InType *input, const IndexType *indices, const int *lengths, const float *weights, bool normalize_by_lengths, OutType *out)</td></tr>
<tr class="memdesc:a3aaf346b2578e6a4300823adc211ca26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embedding lookup with reduction.  <a href="#a3aaf346b2578e6a4300823adc211ca26">More...</a><br /></td></tr>
<tr class="separator:a3aaf346b2578e6a4300823adc211ca26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5496fbdc2cb8dde299857e6b90093dfe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; float, float &gt;</b> (int N, const float a, const float *x, float *y)</td></tr>
<tr class="separator:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4835083ea5bfa10c7b3af8e23bfda8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb4835083ea5bfa10c7b3af8e23bfda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__base</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:afb4835083ea5bfa10c7b3af8e23bfda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432a44186d193fffeeb76f623104555"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac432a44186d193fffeeb76f623104555"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac432a44186d193fffeeb76f623104555"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; float16, float &gt;</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:ac432a44186d193fffeeb76f623104555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f03fa74e51e214bde37bea2b5a060ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f03fa74e51e214bde37bea2b5a060ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_uint8_float__base</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a9f03fa74e51e214bde37bea2b5a060ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475524f78a260b2f1c5688254fef332d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a475524f78a260b2f1c5688254fef332d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a475524f78a260b2f1c5688254fef332d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; std::uint8_t, float &gt;</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a475524f78a260b2f1c5688254fef332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31911563cde2f40247726cd126da6c75"><td class="memTemplParams" colspan="2"><a class="anchor" id="a31911563cde2f40247726cd126da6c75"></a>
template&lt;typename IN , typename OUT &gt; </td></tr>
<tr class="memitem:a31911563cde2f40247726cd126da6c75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy</b> (int N, const OUT a, const IN *x, OUT *y)</td></tr>
<tr class="separator:a31911563cde2f40247726cd126da6c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ea5a7d37f764d5402b8bdc0fd09e23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1ea5a7d37f764d5402b8bdc0fd09e23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__avx_f16c</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:ab1ea5a7d37f764d5402b8bdc0fd09e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468511fd72083ef868ea78e5a4abe606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a468511fd72083ef868ea78e5a4abe606"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__avx2_fma</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:a468511fd72083ef868ea78e5a4abe606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0fe630d1fc251b4ccb093469400af1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a0fe630d1fc251b4ccb093469400af1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_uint8_float__avx2_fma</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a2a0fe630d1fc251b4ccb093469400af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050a59050cee23f2396f5e10997050a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a050a59050cee23f2396f5e10997050a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1_blobs_queue.html">BlobsQueue</a> &gt;)</td></tr>
<tr class="separator:a050a59050cee23f2396f5e10997050a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d08fe955467bcab0d55b1da49c78ea3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d08fe955467bcab0d55b1da49c78ea3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateBlobsQueue, <a class="el" href="classcaffe2_1_1_create_blobs_queue_op.html">CreateBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3d08fe955467bcab0d55b1da49c78ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a0730dc2efc0c8bf27ecc274a57c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc3a0730dc2efc0c8bf27ecc274a57c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnqueueBlobs, <a class="el" href="classcaffe2_1_1_enqueue_blobs_op.html">EnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abc3a0730dc2efc0c8bf27ecc274a57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa80a228741c5b32dc50bd12b5ad762"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaa80a228741c5b32dc50bd12b5ad762"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DequeueBlobs, <a class="el" href="classcaffe2_1_1_dequeue_blobs_op.html">DequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afaa80a228741c5b32dc50bd12b5ad762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f157af0b2dbaa599297dcd3479bfda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96f157af0b2dbaa599297dcd3479bfda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CloseBlobsQueue, <a class="el" href="classcaffe2_1_1_close_blobs_queue_op.html">CloseBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96f157af0b2dbaa599297dcd3479bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8bdff09f365a4910b36705480f3ceb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8bdff09f365a4910b36705480f3ceb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SafeEnqueueBlobs, <a class="el" href="classcaffe2_1_1_safe_enqueue_blobs_op.html">SafeEnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adb8bdff09f365a4910b36705480f3ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547c162adbe651e91c8569334110347"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af547c162adbe651e91c8569334110347"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SafeDequeueBlobs, <a class="el" href="classcaffe2_1_1_safe_dequeue_blobs_op.html">SafeDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af547c162adbe651e91c8569334110347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb563fa919e5cfbeabb350f432ea1b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb563fa919e5cfbeabb350f432ea1b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSampleDequeueBlobs, <a class="el" href="classcaffe2_1_1_weighted_sample_dequeue_blobs_op.html">WeightedSampleDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7eb563fa919e5cfbeabb350f432ea1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108c917884eb0e3e25a3e41ca576863"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa108c917884eb0e3e25a3e41ca576863"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateBlobsQueue).NumInputs(0).NumOutputs(1)</td></tr>
<tr class="separator:aa108c917884eb0e3e25a3e41ca576863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541c9026323eb7c2d89d0de356b204db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a541c9026323eb7c2d89d0de356b204db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs){return inputs &gt;=2 &amp;&amp;outputs &gt;=1 &amp;&amp;inputs==outputs+1;}).EnforceInplace([](int input</td></tr>
<tr class="separator:a541c9026323eb7c2d89d0de356b204db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc9a2ccec2537b9e212a95953c3e51d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc9a2ccec2537b9e212a95953c3e51d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs){return inputs==1 &amp;&amp;outputs &gt;=1;}).SetDoc(R&quot;DOC( Dequeue the blobs from queue. )DOC&quot;).Arg(&quot;timeout_secs&quot;</td></tr>
<tr class="separator:aabc9a2ccec2537b9e212a95953c3e51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ed7d8dc60812b812c32973f9138b94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7ed7d8dc60812b812c32973f9138b94"></a>
Timeout in The shared pointer for the <a class="el" href="classcaffe2_1_1_blobs_queue.html">BlobsQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;blob&quot;,&quot;The blob to store the dequeued data&quot;)</td></tr>
<tr class="separator:ad7ed7d8dc60812b812c32973f9138b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56400e7db97acdb8d20260e747876595"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56400e7db97acdb8d20260e747876595"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CloseBlobsQueue).NumInputs(1).NumOutputs(0)</td></tr>
<tr class="separator:a56400e7db97acdb8d20260e747876595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d02811af4b46249942d20e8500a21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f8d02811af4b46249942d20e8500a21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs){return inputs &gt;=2 &amp;&amp;outputs &gt;=2 &amp;&amp;inputs==outputs;}).EnforceInplace([](int input</td></tr>
<tr class="separator:a7f8d02811af4b46249942d20e8500a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073f71c7d6b5545e27616b3287008c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7073f71c7d6b5545e27616b3287008c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Enqueue the blobs into queue. When the queue is closed and full, the output
status will be set to true which can be used as exit criteria for execution
step.
The 1st input is the queue and the last output is the status. The rest are
data blobs.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a7073f71c7d6b5545e27616b3287008c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d766c33dfec707d286f875ddf2bdd30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d766c33dfec707d286f875ddf2bdd30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs){return inputs==1 &amp;&amp;outputs &gt;=2;}).SetDoc(R&quot;DOC( Dequeue the blobs from queue. When the queue is closed and empty</td></tr>
<tr class="separator:a1d766c33dfec707d286f875ddf2bdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e795404dd0bccc4ad8004c1ea0e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38e795404dd0bccc4ad8004c1ea0e87"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_records&quot;,&quot;(default 1) If &gt; 1, multiple records will be dequeued and tensors &quot;&quot;for each column will be concatenated. This requires all tensors in &quot;&quot;the records to be at least 1D, and to have the same inner dimensions.&quot;).Input(0</td></tr>
<tr class="separator:aa38e795404dd0bccc4ad8004c1ea0e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c98bc459911afabe77cabbaa6a9b69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c98bc459911afabe77cabbaa6a9b69"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Dequeue the blobs from multiple queues. When one of queues is closed and empty,
the output status will be set to true which can be used as exit criteria for
execution step.
The 1st input is the queue and the last output is the status. The rest are
data blobs.
)DOC&quot;).Arg(&quot;weights&quot;</td></tr>
<tr class="separator:a13c98bc459911afabe77cabbaa6a9b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476b804725e7b2840d154107684c4cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac476b804725e7b2840d154107684c4cb"></a>
INT_MAX Weights for sampling from multiple queues&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;table_idx_blob&quot;,&quot;The index of the blob (among the output blob list) &quot;&quot;that will be used to store the index of the table chosen to read the &quot;&quot;current batch.&quot;)</td></tr>
<tr class="separator:ac476b804725e7b2840d154107684c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf8929088680b81f5f66c26b4ee20f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bf8929088680b81f5f66c26b4ee20f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateBlobsQueue)</td></tr>
<tr class="separator:a7bf8929088680b81f5f66c26b4ee20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357f4d3f2d14ea7d366be90153e19f53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a357f4d3f2d14ea7d366be90153e19f53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (EnqueueBlobs)</td></tr>
<tr class="separator:a357f4d3f2d14ea7d366be90153e19f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815b5eb1e08d00057593e8f457a22ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3815b5eb1e08d00057593e8f457a22ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (DequeueBlobs)</td></tr>
<tr class="separator:a3815b5eb1e08d00057593e8f457a22ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab827355b441c918e25d4b80a76f900c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab827355b441c918e25d4b80a76f900c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CloseBlobsQueue)</td></tr>
<tr class="separator:ab827355b441c918e25d4b80a76f900c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6fd20c9ee048bb5217bbafc73e5786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a6fd20c9ee048bb5217bbafc73e5786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SafeEnqueueBlobs)</td></tr>
<tr class="separator:a9a6fd20c9ee048bb5217bbafc73e5786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f60df3c55c85a5dc1ad041cec23bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49f60df3c55c85a5dc1ad041cec23bd4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SafeDequeueBlobs)</td></tr>
<tr class="separator:a49f60df3c55c85a5dc1ad041cec23bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb2be4139d4d31669ef96634a01857"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacdb2be4139d4d31669ef96634a01857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (WeightedSampleDequeueBlobs)</td></tr>
<tr class="separator:aacdb2be4139d4d31669ef96634a01857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f33b32b373b18f9fe66143ea3e8dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e4f33b32b373b18f9fe66143ea3e8dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateBlobsQueue, <a class="el" href="classcaffe2_1_1_create_blobs_queue_op.html">CreateBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3e4f33b32b373b18f9fe66143ea3e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b371e732330cdf8b8d0ec93ec5613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c9b371e732330cdf8b8d0ec93ec5613"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (EnqueueBlobs, <a class="el" href="classcaffe2_1_1_enqueue_blobs_op.html">EnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7c9b371e732330cdf8b8d0ec93ec5613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b89cd90a1ce2627bf1e8aff627b8b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55b89cd90a1ce2627bf1e8aff627b8b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DequeueBlobs, <a class="el" href="classcaffe2_1_1_dequeue_blobs_op.html">DequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a55b89cd90a1ce2627bf1e8aff627b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd6df4aaa20225d3118c02e87161df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9cd6df4aaa20225d3118c02e87161df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CloseBlobsQueue, <a class="el" href="classcaffe2_1_1_close_blobs_queue_op.html">CloseBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af9cd6df4aaa20225d3118c02e87161df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5598fe404cb1ec5db79c7c265b7b46c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5598fe404cb1ec5db79c7c265b7b46c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SafeEnqueueBlobs, <a class="el" href="classcaffe2_1_1_safe_enqueue_blobs_op.html">SafeEnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa5598fe404cb1ec5db79c7c265b7b46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ec76fc3e77c96d1c77b8a1066abb62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0ec76fc3e77c96d1c77b8a1066abb62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SafeDequeueBlobs, <a class="el" href="classcaffe2_1_1_safe_dequeue_blobs_op.html">SafeDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae0ec76fc3e77c96d1c77b8a1066abb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097b8dbd7befdac3c5893994197e4e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae097b8dbd7befdac3c5893994197e4e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (RebatchingQueuePtr)</td></tr>
<tr class="separator:ae097b8dbd7befdac3c5893994197e4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7fb160455401466308ec5db0c93f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3b7fb160455401466308ec5db0c93f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Adagrad, <a class="el" href="classcaffe2_1_1_adagrad_op.html">AdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa3b7fb160455401466308ec5db0c93f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0478e39018a24e3568a2ea55067608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a0478e39018a24e3568a2ea55067608"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the AdaGrad update for an input gradient and accumulated
history. Concretely, given inputs (param, grad, moment, learning_rate),
computes

    new_moment = moment + square(grad)
    new_grad = learning_rate * grad / (sqrt(new_moment) + epsilon)
    new_param = param + new_grad
and returns (new_param, new_moment).

)DOC&quot;).Input(0</td></tr>
<tr class="separator:a2a0478e39018a24e3568a2ea55067608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9032080c8b01fea30de226473242c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f9032080c8b01fea30de226473242c0"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;moment&quot;,&quot;Moment history&quot;).Input(2</td></tr>
<tr class="separator:a9f9032080c8b01fea30de226473242c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4ef79783299b9ebbec128c0d596bd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c4ef79783299b9ebbec128c0d596bd2"></a>
Parameters to be updated Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;lr&quot;,&quot;learning rate&quot;).Output(0</td></tr>
<tr class="separator:a7c4ef79783299b9ebbec128c0d596bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0170934c009a25fcac3d303d50e5f23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0170934c009a25fcac3d303d50e5f23"></a>
Parameters to be updated Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;output_moment&quot;,&quot;Updated moment&quot;).Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:ab0170934c009a25fcac3d303d50e5f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4e1e7fe44d885eefab11e617585c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef4e1e7fe44d885eefab11e617585c7f"></a>
Parameters to be updated Gradient computed Updated parameters Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;decay&quot;,&quot;Default 1. If it is in (0, 1), the gradient square sum &quot;&quot;is decayed by this factor.&quot;)</td></tr>
<tr class="separator:aef4e1e7fe44d885eefab11e617585c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8403cbf6feb78929cc3f0734ddf104b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8403cbf6feb78929cc3f0734ddf104b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseAdagrad, <a class="el" href="classcaffe2_1_1_sparse_adagrad_op.html">SparseAdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab8403cbf6feb78929cc3f0734ddf104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec133588cd8ddf84d2e09df4611e78d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec133588cd8ddf84d2e09df4611e78d3"></a>
runs the dense AdaGrad update&#160;</td><td class="memItemRight" valign="bottom"><b>on</b> (param, grad, moment[indices], lr)</td></tr>
<tr class="separator:aec133588cd8ddf84d2e09df4611e78d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee24aa3bec297ef92c6e50bbfa73889"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ee24aa3bec297ef92c6e50bbfa73889"></a>
runs the dense AdaGrad update and&#160;</td><td class="memItemRight" valign="bottom"><b>returns</b> (new_param, new_moment) as in the dense case.) DOC&quot;) .Input(0</td></tr>
<tr class="separator:a8ee24aa3bec297ef92c6e50bbfa73889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3ad2dd2b5d8694f177c23b08eaf54a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b3ad2dd2b5d8694f177c23b08eaf54a"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;grad&quot;,&quot;Gradient computed&quot;).Input(4</td></tr>
<tr class="separator:a4b3ad2dd2b5d8694f177c23b08eaf54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbd988656f2d239355546a82ba52850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bbd988656f2d239355546a82ba52850"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;output_param&quot;,&quot;Updated parameters&quot;).Output(1</td></tr>
<tr class="separator:a4bbd988656f2d239355546a82ba52850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccd9b7ef109bce8b214cf01ae80d5c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ccd9b7ef109bce8b214cf01ae80d5c5"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate Updated moment&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;epsilon&quot;,&quot;Default 1e-5&quot;)</td></tr>
<tr class="separator:a4ccd9b7ef109bce8b214cf01ae80d5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4d1694dde0ae0a9a3426b87044bef4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e4d1694dde0ae0a9a3426b87044bef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowWiseSparseAdagrad, <a class="el" href="classcaffe2_1_1_row_wise_sparse_adagrad_op.html">RowWiseSparseAdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4e4d1694dde0ae0a9a3426b87044bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f5924a76aa2ecb54e94cab5a790cd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f5924a76aa2ecb54e94cab5a790cd7"></a>
runs a modified sparse Adagrad update and&#160;</td><td class="memItemRight" valign="bottom"><b>returns</b> (new_param, new_momwnr)</td></tr>
<tr class="separator:a56f5924a76aa2ecb54e94cab5a790cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31be1011cfb49347b22892dd0d604dc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31be1011cfb49347b22892dd0d604dc8"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;param&quot;,&quot;Parameters to be updated&quot;).Input(1</td></tr>
<tr class="separator:a31be1011cfb49347b22892dd0d604dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7d914d407212e2666c2eda6e167478"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb7d914d407212e2666c2eda6e167478"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;indices&quot;,&quot;Sparse indices&quot;).Input(3</td></tr>
<tr class="separator:abb7d914d407212e2666c2eda6e167478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4842cb1b996daea7dd506b835161284d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4842cb1b996daea7dd506b835161284d"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (4,&quot;lr&quot;,&quot;learning rate&quot;).Output(0</td></tr>
<tr class="separator:a4842cb1b996daea7dd506b835161284d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba7b17d82f0561c1353e3a39795c097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ba7b17d82f0561c1353e3a39795c097"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;output_moment_1&quot;,&quot;Updated moment&quot;).Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:a2ba7b17d82f0561c1353e3a39795c097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4427cfc6d811d547367315564dbf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d4427cfc6d811d547367315564dbf1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Adagrad)</td></tr>
<tr class="separator:a49d4427cfc6d811d547367315564dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c71a348333a99d7adb7597d16d69eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c71a348333a99d7adb7597d16d69eac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseAdagrad)</td></tr>
<tr class="separator:a6c71a348333a99d7adb7597d16d69eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca4d273c28e7a0bc4576d6fb59838f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ca4d273c28e7a0bc4576d6fb59838f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RowWiseSparseAdagrad)</td></tr>
<tr class="separator:a9ca4d273c28e7a0bc4576d6fb59838f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52caf415e26784864b15d1805ff7989a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52caf415e26784864b15d1805ff7989a"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a52caf415e26784864b15d1805ff7989a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adagrad_update</b> (int N, const float *w, const float *g, const float *h, float *nw, float *nh, float epsilon, float decay, const float *lr, Context *)</td></tr>
<tr class="separator:a52caf415e26784864b15d1805ff7989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1267836a46dfedf7588466f02db90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46f1267836a46dfedf7588466f02db90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Adam, <a class="el" href="classcaffe2_1_1_adam_op.html">AdamOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a46f1267836a46dfedf7588466f02db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e267a69a2ddff1759774b5a5b44a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e2e267a69a2ddff1759774b5a5b44a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (6).NumOutputs(3).AllowInplace(</td></tr>
<tr class="separator:a1e2e267a69a2ddff1759774b5a5b44a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8375ec3ac861c1fb24811f996d055977"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8375ec3ac861c1fb24811f996d055977"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the Adam update (https://arxiv.org/abs/1412.6980) for an
input gradient and momentum parameters. Concretely, given inputs
(param, m1, m2, grad, lr, iters),

    t = iters + 1
    corrected_local_rate = lr * sqrt(1 - power(beta2, t)) /
      (1 - power(beta1, t))
    m1_o = (beta1 * m1) + (1 - beta1) * grad
    m2_o = (beta2 * m2) + (1 - beta2) * np.square(grad)
    grad_o = corrected_local_rate * m1_o / \
        (sqrt(m2_o) + epsilon)
    param_o = param + grad_o

and returns (param_o, m1_o, m2_o)

)DOC&quot;).Input(0</td></tr>
<tr class="separator:a8375ec3ac861c1fb24811f996d055977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e6989fd660acab352cbdf16e6b80a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39e6989fd660acab352cbdf16e6b80a7"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;moment_1&quot;,&quot;First moment history&quot;).Input(2</td></tr>
<tr class="separator:a39e6989fd660acab352cbdf16e6b80a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad294da194caaa6e3c1597250c7aaa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaad294da194caaa6e3c1597250c7aaa1"></a>
Parameters to be updated Second moment history learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5,&quot;iter&quot;,&quot;iteration number&quot;).Output(0</td></tr>
<tr class="separator:aaad294da194caaa6e3c1597250c7aaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1752da0ba036ab45c3dcc9b3f9da9d01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1752da0ba036ab45c3dcc9b3f9da9d01"></a>
Parameters to be updated Second moment history learning rate Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;output_moment_1&quot;,&quot;Updated first moment&quot;).Output(2</td></tr>
<tr class="separator:a1752da0ba036ab45c3dcc9b3f9da9d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6cde6d9e76ce35fc5c5306b469ef16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c6cde6d9e76ce35fc5c5306b469ef16"></a>
Parameters to be updated Second moment history learning rate Updated parameters Updated second moment&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;beta1&quot;,&quot;Default 0.9&quot;).Arg(&quot;beta2&quot;</td></tr>
<tr class="separator:a2c6cde6d9e76ce35fc5c5306b469ef16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f6b19d8ef9b88e5951823b273ca77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e9f6b19d8ef9b88e5951823b273ca77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseAdam, <a class="el" href="classcaffe2_1_1_sparse_adam_op.html">SparseAdamOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1e9f6b19d8ef9b88e5951823b273ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5280465d2fc09903beca0e17849ebb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f5280465d2fc09903beca0e17849ebb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the Adam Update for the sparse case.
Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the dense
Adam on (param, moment1[indices], momemnt2[indices], lr, iter) and returns
(new_param, new_moment1, new_moment2) as in dense case

)DOC&quot;).Input(0</td></tr>
<tr class="separator:a3f5280465d2fc09903beca0e17849ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf20c1a4935ba2b5e8a114a5ad9909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81cf20c1a4935ba2b5e8a114a5ad9909"></a>
Parameters to be updated Second moment history&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;indices&quot;,&quot;Sparse indices&quot;).Input(4</td></tr>
<tr class="separator:a81cf20c1a4935ba2b5e8a114a5ad9909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae969a2b0808dec327ec2d05bf3ad29a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae969a2b0808dec327ec2d05bf3ad29a2"></a>
Parameters to be updated Second moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5,&quot;lr&quot;,&quot;learning rate&quot;).Input(6</td></tr>
<tr class="separator:ae969a2b0808dec327ec2d05bf3ad29a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9bb7e4c6aa6e284f3e26bf843924f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f9bb7e4c6aa6e284f3e26bf843924f2"></a>
Parameters to be updated Second moment history Gradient computed iteration number Updated first moment&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2,&quot;output_moment_2&quot;,&quot;Updated second moment&quot;).Arg(&quot;beta1&quot;</td></tr>
<tr class="separator:a6f9bb7e4c6aa6e284f3e26bf843924f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bed1cd2621ab53862394d87a4c8dd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3bed1cd2621ab53862394d87a4c8dd2"></a>
Parameters to be updated Second moment history Gradient computed iteration number Updated first moment Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;beta2&quot;,&quot;Default 0.999&quot;).Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:aa3bed1cd2621ab53862394d87a4c8dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0354020289fcbc627d1dc764eef18b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b0354020289fcbc627d1dc764eef18b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowWiseSparseAdam, <a class="el" href="classcaffe2_1_1_row_wise_sparse_adam_op.html">RowWiseSparseAdamOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1b0354020289fcbc627d1dc764eef18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3afaabcd6603756d98a9a230388a504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3afaabcd6603756d98a9a230388a504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes a modified Adam Update for the sparse case.
Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the
Adam update on (param, moment1[indices], moment2[indices], lr, iter) and returns
(new_param, new_moment1, new_moment2), where moment2 is a 1D tensor
with length equal to the number of rows in param:
shape(moment2) == shape(param)[0]. Each element of  moment2 is
applied to an entire row of param, and the new moment2 values are
calculated by averaging across the row.

)DOC&quot;).Input(0</td></tr>
<tr class="separator:af3afaabcd6603756d98a9a230388a504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4750713478bdc53029a1d45b53e2a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f4750713478bdc53029a1d45b53e2a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Adam)</td></tr>
<tr class="separator:a5f4750713478bdc53029a1d45b53e2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4918dbf8c1590d5dc79bafa7cdf29f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4918dbf8c1590d5dc79bafa7cdf29f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseAdam)</td></tr>
<tr class="separator:aa4918dbf8c1590d5dc79bafa7cdf29f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e8dd590744313c3687101a07143322"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85e8dd590744313c3687101a07143322"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RowWiseSparseAdam)</td></tr>
<tr class="separator:a85e8dd590744313c3687101a07143322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad673b1c06055f145a885459af259d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaad673b1c06055f145a885459af259d9"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:aaad673b1c06055f145a885459af259d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adam_update</b> (int N, const float *g, const float *m, const float *v, float *ng, float *nm, float *nv, float beta1, float beta2, float eps_hat, float correction, const float *lr, Context *)</td></tr>
<tr class="separator:aaad673b1c06055f145a885459af259d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a21d356a425abb26679238d3e423d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13a21d356a425abb26679238d3e423d3"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a13a21d356a425abb26679238d3e423d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adam_compute</b> (int N, const float *w, const float *g, const float *m, const float *v, float *nw, float *nm, float *nv, float beta1, float beta2, float eps_hat, float correction, const float *lr, Context *)</td></tr>
<tr class="separator:a13a21d356a425abb26679238d3e423d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b355dd533c36c687f287ab1211c154"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3b355dd533c36c687f287ab1211c154"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ClipTensorByScaling, <a class="el" href="classcaffe2_1_1_clip_tensor_by_scaling_op.html">ClipTensorByScalingOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af3b355dd533c36c687f287ab1211c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aa8b8843f0956388393b9df504a200"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7aa8b8843f0956388393b9df504a200"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
    Clips the input tensor by scaling based on the input value and the threshold.
    The value is usually the (pre-computed) norm of the tensor. If the value is
    larger than the threshold, scaling would be performed in this way:

          tensor *= (threshold / value).

    This op could be used for gradient clipping.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:af7aa8b8843f0956388393b9df504a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e50d5c049486ecba611e8bd50381a19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e50d5c049486ecba611e8bd50381a19"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of floats to be clipped&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;val&quot;,&quot;Value to be compared against the threshold&quot;).Arg(&quot;threshold&quot;</td></tr>
<tr class="separator:a6e50d5c049486ecba611e8bd50381a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341bc37efeb388a6a70bf48a7cddfc94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341bc37efeb388a6a70bf48a7cddfc94"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of floats to be clipped Threshold to determine whether to scale down the tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;clipped&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of floats, which is the same size as the input tensor, &quot;&quot;representing the clipped tensor.&quot;)</td></tr>
<tr class="separator:a341bc37efeb388a6a70bf48a7cddfc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c9b48563b67fdf64af6fe535c797dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4c9b48563b67fdf64af6fe535c797dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ClipTensorByScaling)</td></tr>
<tr class="separator:ae4c9b48563b67fdf64af6fe535c797dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add629e670381f07181b2d11b67f60159"><td class="memTemplParams" colspan="2"><a class="anchor" id="add629e670381f07181b2d11b67f60159"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:add629e670381f07181b2d11b67f60159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_momentum_sgd_update</b> (int N, const float16 *g, const float16 *m, float16 *ng, float16 *nm, const float *lr, float momentum, bool nesterov, float weight_decay, bool fp32_update, float16 *param, Context *)</td></tr>
<tr class="separator:add629e670381f07181b2d11b67f60159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memTemplParams" colspan="2"><a class="anchor" id="aafc3e89243f7989891f1e3a3f5c36d24"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp32_momentum_sgd_update</b> (int N, const float *g, const float *m, float *ng, float *nm, const float *lr, float momentum, bool nesterov, float weight_decay, float *param, Context *)</td></tr>
<tr class="separator:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5937c8436cf4791e689d943200c7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16a5937c8436cf4791e689d943200c7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16a5937c8436cf4791e689d943200c7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sgn</b> (const T x)</td></tr>
<tr class="separator:a16a5937c8436cf4791e689d943200c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8705b9ad77634eb047afca0b24737e0c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8705b9ad77634eb047afca0b24737e0c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8705b9ad77634eb047afca0b24737e0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ftrl_compute</b> (const T w, const T n, const T z, const T g, T &amp;nw, T &amp;nn, T &amp;nz, const <a class="el" href="structcaffe2_1_1_ftrl_params.html">FtrlParams</a>&lt; T &gt; &amp;params)</td></tr>
<tr class="separator:a8705b9ad77634eb047afca0b24737e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5d83bad64c7bb33db49c289d7b61f78"></a>
template&lt;typename Context , typename T &gt; </td></tr>
<tr class="memitem:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ftrl_update</b> (int N, const T *w, const T *nz, const T *g, T *new_w, T *new_nz, const <a class="el" href="structcaffe2_1_1_ftrl_params.html">FtrlParams</a>&lt; T &gt; &amp;params, Context *)</td></tr>
<tr class="separator:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eb2309a93b3e4e1b0858c6ceeefbd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62eb2309a93b3e4e1b0858c6ceeefbd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Iter, <a class="el" href="classcaffe2_1_1_iter_op.html">IterOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a62eb2309a93b3e4e1b0858c6ceeefbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d2904a82671957e8cb3d50705d05f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d2904a82671957e8cb3d50705d05f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AtomicIter, <a class="el" href="classcaffe2_1_1_atomic_iter_op.html">AtomicIterOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab8d2904a82671957e8cb3d50705d05f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b4bd2ed2e46b5c17a1400c46aeb75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac90b4bd2ed2e46b5c17a1400c46aeb75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_SERIALIZER</b> ((<a class="el" href="classcaffe2_1_1_type_meta.html#a832b40f4bf4158dd3f1cc0b7d51858db">TypeMeta::Id</a>&lt; std::unique_ptr&lt; std::mutex &gt;&gt;()), <a class="el" href="classcaffe2_1_1_mutex_serializer.html">MutexSerializer</a>)</td></tr>
<tr class="separator:ac90b4bd2ed2e46b5c17a1400c46aeb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ee30697814ee55ca6b7c2401cf927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa76ee30697814ee55ca6b7c2401cf927"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_DESERIALIZER</b> (std::unique_ptr&lt; std::mutex &gt;, <a class="el" href="classcaffe2_1_1_mutex_deserializer.html">MutexDeserializer</a>)</td></tr>
<tr class="separator:aa76ee30697814ee55ca6b7c2401cf927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f038928b82ec9c9b9521bc80ffc83a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f038928b82ec9c9b9521bc80ffc83a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Stores a singe integer, that gets incremented on each call to Run().
Useful for tracking the iteration count during SGD, for example.
)DOC&quot;)</td></tr>
<tr class="separator:a5f038928b82ec9c9b9521bc80ffc83a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f98e51a81de34a8a53053daa2934705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f98e51a81de34a8a53053daa2934705"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Similar to Iter, but takes a mutex as the first input to make sure that
updates are carried out atomically. This can be used in e.g. Hogwild sgd
algorithms.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:a5f98e51a81de34a8a53053daa2934705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca541221bb9f3e08690ed028a8253833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca541221bb9f3e08690ed028a8253833"></a>
The mutex used to do atomic increment&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;iter&quot;,&quot;The iter counter as an int64_t TensorCPU.&quot;)</td></tr>
<tr class="separator:aca541221bb9f3e08690ed028a8253833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac719df125c37019704abe5c7f53ea318"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac719df125c37019704abe5c7f53ea318"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Iter)</td></tr>
<tr class="separator:ac719df125c37019704abe5c7f53ea318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca995e1c8a5d198e1ce9945d43079b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca995e1c8a5d198e1ce9945d43079b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (AtomicIter)</td></tr>
<tr class="separator:a4ca995e1c8a5d198e1ce9945d43079b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153f3c396bac274030d0fb5fe7421585"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a153f3c396bac274030d0fb5fe7421585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IncrementIter</b> (<a class="el" href="classcaffe2_1_1_tensor.html">TensorCPU</a> *output)</td></tr>
<tr class="separator:a153f3c396bac274030d0fb5fe7421585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257144a05c7bc7118a38c1682b3f2d7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a257144a05c7bc7118a38c1682b3f2d7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Iter, <a class="el" href="classcaffe2_1_1_iter_op.html">IterOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a257144a05c7bc7118a38c1682b3f2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccb1da1f9193dd20fadb69e7588b852"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adccb1da1f9193dd20fadb69e7588b852"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (AtomicIter, <a class="el" href="classcaffe2_1_1_atomic_iter_op.html">AtomicIterOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adccb1da1f9193dd20fadb69e7588b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c25209811cb75148c0220861bf79155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c25209811cb75148c0220861bf79155"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Lars, <a class="el" href="classcaffe2_1_1_lars_op.html">LarsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2c25209811cb75148c0220861bf79155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe1cda68cef6846906968b891c98b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ebe1cda68cef6846906968b891c98b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LearningRate, <a class="el" href="classcaffe2_1_1_learning_rate_op.html">LearningRateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8ebe1cda68cef6846906968b891c98b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f81397a4037790bd3c31b33e1372b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7f81397a4037790bd3c31b33e1372b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LearningRate, <a class="el" href="classcaffe2_1_1_learning_rate_op.html">LearningRateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa7f81397a4037790bd3c31b33e1372b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06058e388890cc66dcfe34c26887b400"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06058e388890cc66dcfe34c26887b400"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MomentumSGD, <a class="el" href="classcaffe2_1_1_momentum_s_g_d_op.html">MomentumSGDOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a06058e388890cc66dcfe34c26887b400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b4a7143feff24e281018ff96fca2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a363b4a7143feff24e281018ff96fca2c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;in){vector&lt; TensorShape &gt; out(2);out[0]=in[0];out[1]=in[1];return out;}).SetDoc(R&quot;DOC( Computes a momentum SGD update for an input gradient and momentum parameters. Concretely</td></tr>
<tr class="separator:a363b4a7143feff24e281018ff96fca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02bdb33af75f50e798248acb9b04f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d02bdb33af75f50e798248acb9b04f1"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b> (grad, m, lr) and parameters(momentum</td></tr>
<tr class="separator:a0d02bdb33af75f50e798248acb9b04f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be29eecd8f5475a405b86e6ea2cd828"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6be29eecd8f5475a405b86e6ea2cd828"></a>
given adjusted_gradient m_new Output&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (grad, momentum) Note the difference to MomemtumSGDUpdate</td></tr>
<tr class="separator:a6be29eecd8f5475a405b86e6ea2cd828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aff43e7aa0ccff31188a67b364eeb76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6aff43e7aa0ccff31188a67b364eeb76"></a>
given adjusted_gradient m_new Output which actually performs the parameter&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> (and is thus faster).) DOC&quot;)</td></tr>
<tr class="separator:a6aff43e7aa0ccff31188a67b364eeb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888fa7c9e77dc141bbdded7fa03766d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a888fa7c9e77dc141bbdded7fa03766d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MomentumSGD)</td></tr>
<tr class="separator:a888fa7c9e77dc141bbdded7fa03766d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f8dc6505fb594b1ea42226095c7df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02f8dc6505fb594b1ea42226095c7df3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MomentumSGDUpdate, <a class="el" href="classcaffe2_1_1_momentum_s_g_d_update_op.html">MomentumSGDUpdateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a02f8dc6505fb594b1ea42226095c7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17865fdf00c4c036edc36bb86fd7e02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae17865fdf00c4c036edc36bb86fd7e02"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;in){vector&lt; TensorShape &gt; out(3);out[0]=in[0];out[1]=in[1];out[2]=in[3];return out;}).SetDoc(R&quot;DOC( Performs a momentum SGD update for an input gradient and momentum parameters. Concretely</td></tr>
<tr class="separator:ae17865fdf00c4c036edc36bb86fd7e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d337e8e55be7b94f9687b45e9c22b72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d337e8e55be7b94f9687b45e9c22b72"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b> (grad, m, lr, param) and arguments(momentum</td></tr>
<tr class="separator:a5d337e8e55be7b94f9687b45e9c22b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fb9d12d5d00d54747873d788b5859c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73fb9d12d5d00d54747873d788b5859c"></a>
given param&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> ((1+momentum)*m_new-momentum *m, m_new, param) Output is(grad</td></tr>
<tr class="separator:a73fb9d12d5d00d54747873d788b5859c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2fc43856b6b48cefada73f27cb3618"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e2fc43856b6b48cefada73f27cb3618"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MomentumSGDUpdate)</td></tr>
<tr class="separator:a1e2fc43856b6b48cefada73f27cb3618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29067a3f5dbbdcb2140b3ee9bc7a0644"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29067a3f5dbbdcb2140b3ee9bc7a0644"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseMomentumSGDUpdate, <a class="el" href="classcaffe2_1_1_sparse_momentum_s_g_d_update_op.html">SparseMomentumSGDUpdateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a29067a3f5dbbdcb2140b3ee9bc7a0644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273efb9a376640fb9e08ef84fb9c4b68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273efb9a376640fb9e08ef84fb9c4b68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{1, 1},{3, 2}}).TensorInferenceFunction([](const OperatorDef &amp;</td></tr>
<tr class="separator:a273efb9a376640fb9e08ef84fb9c4b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac052eb9d58a07a56eaaf70956debd924"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac052eb9d58a07a56eaaf70956debd924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Performs a momentum SGD update analogous to MomentumSGDUpdate, but using a
GradientSlice and indices into the full param and momentum tables. Both param
and momentum should be in-place (corresponding inputs and outputs should be the
same blobs).



)DOC&quot;).Input(0</td></tr>
<tr class="separator:ac052eb9d58a07a56eaaf70956debd924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576102af3c5284d48ebe9b85f060bfac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a576102af3c5284d48ebe9b85f060bfac"></a>
GradientSlice with gradients for updated indices&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;moment&quot;,&quot;Momentum blob, same shape as param.&quot;).Input(2</td></tr>
<tr class="separator:a576102af3c5284d48ebe9b85f060bfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97174aec4705e2654ac0369b82671d5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97174aec4705e2654ac0369b82671d5f"></a>
GradientSlice with gradients for updated indices Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;param&quot;,&quot;Full parameter blob.&quot;).Input(4</td></tr>
<tr class="separator:a97174aec4705e2654ac0369b82671d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df01e983d4971cc151e5245a0e6023e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9df01e983d4971cc151e5245a0e6023e"></a>
GradientSlice with gradients for updated indices Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Indices</b> (in first dimension of param) where updates are performed.&quot;) .Output(0</td></tr>
<tr class="separator:a9df01e983d4971cc151e5245a0e6023e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90e51b8ce609f0e353e994d0e7df7cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af90e51b8ce609f0e353e994d0e7df7cd"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;output_moment&quot;,&quot;Updated momentum.&quot;).Output(2</td></tr>
<tr class="separator:af90e51b8ce609f0e353e994d0e7df7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a34f5d286bc76ea194fdb24c791a38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a34f5d286bc76ea194fdb24c791a38"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient Updated parameter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;momentum&quot;,&quot;Momentum hyperparameter.&quot;).Arg(&quot;nesterov&quot;</td></tr>
<tr class="separator:af5a34f5d286bc76ea194fdb24c791a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde0286b179d85bed73ee10dcc51b68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadde0286b179d85bed73ee10dcc51b68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseMomentumSGDUpdate)</td></tr>
<tr class="separator:aadde0286b179d85bed73ee10dcc51b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c6ad2b102c2dbbb3ee0e6008974d60d"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>momentum_sgd_update</b> (const int N, const float *g, const float *m, float *ng, float *nm, const float *lr, const float momentum, const bool nesterov, float *param, Context *)</td></tr>
<tr class="separator:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3024274d23e0aa690e9ede7b3e79ecb2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rmsprop_update&lt; CPUContext &gt;</b> (int N, const float *g, const float *ms, const float *mom, float *ng, float *nms, float *nmom, float decay, float momentum, float epsilon, const float *lr, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> *)</td></tr>
<tr class="separator:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b90ea97be1a556b20e63346816d4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97b90ea97be1a556b20e63346816d4f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RmsProp, <a class="el" href="classcaffe2_1_1_rms_prop_op.html">RmsPropOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a97b90ea97be1a556b20e63346816d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e95977c65ff678c1161df753483829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e95977c65ff678c1161df753483829"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Computes the RMSProp update
(http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf).
Concretely, given inputs (grad, mean_squares, mom, lr), computes:

    mean_squares_o = mean_squares + (1 - decay) * (square(grad) - mean_squares)
    mom_o = momentum * mom + lr * grad / sqrt(epsilon + mean_squares_o)
    grad_o = mom_o

Returns (grad_o, mean_squares_o, mom_o).
)DOC&quot;)</td></tr>
<tr class="separator:a89e95977c65ff678c1161df753483829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7a8e73e8793ec9ee086c500e62e2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8e7a8e73e8793ec9ee086c500e62e2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RmsProp)</td></tr>
<tr class="separator:ab8e7a8e73e8793ec9ee086c500e62e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c1cbdf70bb22108c3b37d00943ca4b3"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rmsprop_update</b> (int N, const float *g, const float *ms, const float *mom, float *ng, float *nms, float *nmom, float decay, float momentum, float epsilon, const float *lr, Context *context)</td></tr>
<tr class="separator:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6241feb2dd8e48a9a813cc86874c140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6241feb2dd8e48a9a813cc86874c140"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (YellowFin, <a class="el" href="classcaffe2_1_1_yellow_fin_op.html">YellowFinOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad6241feb2dd8e48a9a813cc86874c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8f78d7267835a0bba59ca78b4c1fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b8f78d7267835a0bba59ca78b4c1fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (10).NumOutputs(8).AllowInplace(</td></tr>
<tr class="separator:ab2b8f78d7267835a0bba59ca78b4c1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a864c62617d26b6fef41551736eed77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a864c62617d26b6fef41551736eed77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the YellowFin update (https://arxiv.org/abs/1706.03471) and performs
momentum SGD optimization step. lr and mu are not being shared between
parameters. curv_win, g_avg, g2_avg and scalars_memory are just auxiliary
memory for computing moving averages (see the publication). Takes arguments
beta: coefficient for moving averages,
curv_win_width: timeframe when average squared gradient is being stored,
epsilon: for numerical purposes,
nesterov and zero_debias for debias of moving average.

)DOC&quot;).Input(0</td></tr>
<tr class="separator:a9a864c62617d26b6fef41551736eed77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fe7d7e65bdf6635caf0ea43db13c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67fe7d7e65bdf6635caf0ea43db13c94"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;moment&quot;,&quot;Momentum&quot;).Input(2</td></tr>
<tr class="separator:a67fe7d7e65bdf6635caf0ea43db13c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1142745b278aa45fd37fa0f2fddb15fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1142745b278aa45fd37fa0f2fddb15fa"></a>
Parameters to be updated Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;mu&quot;,&quot;Momentum coefficient&quot;).Input(4</td></tr>
<tr class="separator:a1142745b278aa45fd37fa0f2fddb15fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aab5b1c3627c8c2a29e7fe7e62ea26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84aab5b1c3627c8c2a29e7fe7e62ea26"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5,&quot;g_avg&quot;,&quot;Moving average of gradient&quot;).Input(6</td></tr>
<tr class="separator:a84aab5b1c3627c8c2a29e7fe7e62ea26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e949f20096c2dbea98f93119d89900"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04e949f20096c2dbea98f93119d89900"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (7,&quot;scalars_memory&quot;,&quot;Memory for stateful scalars&quot;).Input(8</td></tr>
<tr class="separator:a04e949f20096c2dbea98f93119d89900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9c2d63ae50964044021320dd5d6357"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff9c2d63ae50964044021320dd5d6357"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (9,&quot;iter&quot;,&quot;Iteration number&quot;).Output(0</td></tr>
<tr class="separator:aff9c2d63ae50964044021320dd5d6357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a76c6d0a15511bc059a2878e09a4ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a76c6d0a15511bc059a2878e09a4ec"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;output_moment&quot;,&quot;Momentum&quot;).Output(2</td></tr>
<tr class="separator:ae0a76c6d0a15511bc059a2878e09a4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d08fe45e97859bcfda68625e51eb94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d08fe45e97859bcfda68625e51eb94"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (3,&quot;output_mu&quot;,&quot;Output momentum coefficient&quot;).Output(4</td></tr>
<tr class="separator:ab0d08fe45e97859bcfda68625e51eb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859265056a54d031b1d3c807f8d42c92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859265056a54d031b1d3c807f8d42c92"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (5,&quot;output_g_avg&quot;,&quot;Output moving average of gradient&quot;).Output(6</td></tr>
<tr class="separator:a859265056a54d031b1d3c807f8d42c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721f76e4820af51fa471eb1404c717e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a721f76e4820af51fa471eb1404c717e5"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (7,&quot;output_scalars_memory&quot;,&quot;Output memory for stateful scalars&quot;).Arg(&quot;beta&quot;</td></tr>
<tr class="separator:a721f76e4820af51fa471eb1404c717e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87fb870be0ce47472f63d0002110d08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab87fb870be0ce47472f63d0002110d08"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;curv_win_width&quot;,&quot;Default 20&quot;).Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:ab87fb870be0ce47472f63d0002110d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e24f3a19fb3af59eb992852a1f7b04a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e24f3a19fb3af59eb992852a1f7b04a"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient Default Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;nesterov&quot;,&quot;Default false&quot;).Arg(&quot;zero_debias&quot;</td></tr>
<tr class="separator:a8e24f3a19fb3af59eb992852a1f7b04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614581fe220bb4852ba056a8ef579a29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a614581fe220bb4852ba056a8ef579a29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (YellowFin)</td></tr>
<tr class="separator:a614581fe220bb4852ba056a8ef579a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138bc472309a6859cd5a50fb4dc64ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad138bc472309a6859cd5a50fb4dc64ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initNNPACK</b> ()</td></tr>
<tr class="separator:ad138bc472309a6859cd5a50fb4dc64ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79995aa56787333ca75efbbb79c8bc61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79995aa56787333ca75efbbb79c8bc61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv, NNPACK, <a class="el" href="classcaffe2_1_1_n_n_p_a_c_k_conv_op.html">NNPACKConvOp</a>)</td></tr>
<tr class="separator:a79995aa56787333ca75efbbb79c8bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac251f4b88db090cb5d63c9e0cc783f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac251f4b88db090cb5d63c9e0cc783f91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecompZstd, <a class="el" href="classcaffe2_1_1_quant_decomp_zstd_op.html">QuantDecompZstdOp</a>)</td></tr>
<tr class="separator:ac251f4b88db090cb5d63c9e0cc783f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c2b50421e5129e4ad89d1250e1f66d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52c2b50421e5129e4ad89d1250e1f66d"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
 Decompress a set of tensors that are compressed using zstd.
 The data can be compressed using mutils.compress_data_list(), see
 quant_decomp_op_test.py for an example.
 The number of outputs depended on the input.
 )DOC&quot;).Input(0</td></tr>
<tr class="separator:a52c2b50421e5129e4ad89d1250e1f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"></a>
INT_MAX Compressed data in&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (uint8_t)</td></tr>
<tr class="separator:a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f092565e57a6cc19c9457cee62adc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0f092565e57a6cc19c9457cee62adc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (QuantDecompZstd)</td></tr>
<tr class="separator:ab0f092565e57a6cc19c9457cee62adc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a308109b3449984670fb7857df21939"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a308109b3449984670fb7857df21939"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>are_nodes_common</b> (const Graph &amp;g, int model_idx, int candidate_idx)</td></tr>
<tr class="separator:a2a308109b3449984670fb7857df21939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e71d23701ed932b2aa1aeecfb50418"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2e71d23701ed932b2aa1aeecfb50418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_TRANSFORM</b> (CommonSubexpressionElimination, <a class="el" href="classcaffe2_1_1_common_subexpression_elimination_transform.html">CommonSubexpressionEliminationTransform</a>)</td></tr>
<tr class="separator:ad2e71d23701ed932b2aa1aeecfb50418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514f554606ce65accb85d0fe3d8de86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8514f554606ce65accb85d0fe3d8de86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_TRANSFORM</b> (ConvToNNPack, <a class="el" href="classcaffe2_1_1_conv_to_n_n_pack_transform.html">ConvToNNPackTransform</a>)</td></tr>
<tr class="separator:a8514f554606ce65accb85d0fe3d8de86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4de906b41a8aabb7bdddcf918de41a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4de906b41a8aabb7bdddcf918de41a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compare_ops</b> (const OperatorDef &amp;p_op, const OperatorDef &amp;g_op, bool arg_match)</td></tr>
<tr class="separator:ac4de906b41a8aabb7bdddcf918de41a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415daf787ec8776bdb27e21a9f4864cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a415daf787ec8776bdb27e21a9f4864cf"></a>
const <a class="el" href="classcaffe2_1_1_cpu_id.html">CpuId</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetCpuId</b> ()</td></tr>
<tr class="separator:a415daf787ec8776bdb27e21a9f4864cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a141c2c5e0b2a5195f016cb34f35f8cd6"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_mult</b> (T data1, T2 data2)</td></tr>
<tr class="separator:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1f1108b7f0508e53032fbc8ef9956cb"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_add</b> (T data1, T2 data2)</td></tr>
<tr class="separator:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c105f14153aaca6e1cce8fb308941"><td class="memTemplParams" colspan="2"><a class="anchor" id="a801c105f14153aaca6e1cce8fb308941"></a>
template&lt;typename TIN , typename TOUT &gt; </td></tr>
<tr class="memitem:a801c105f14153aaca6e1cce8fb308941"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_store</b> (TIN *data_in, TOUT *data_out)</td></tr>
<tr class="separator:a801c105f14153aaca6e1cce8fb308941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aeaa52b1b197a9ab0e10a5b74b09aeac4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_store</b> (T *data_in, T *data_out)</td></tr>
<tr class="separator:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da9c276eaa60e471e5782245870b763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3da9c276eaa60e471e5782245870b763"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x86_32</b> (const void *key, int len, uint32_t seed, void *out)</td></tr>
<tr class="separator:a3da9c276eaa60e471e5782245870b763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be24256e9245ccd71c0b012ad4f45b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7be24256e9245ccd71c0b012ad4f45b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x86_128</b> (const void *key, const int len, uint32_t seed, void *out)</td></tr>
<tr class="separator:a7be24256e9245ccd71c0b012ad4f45b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c9229fa909eeb94b774d82630ffc98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5c9229fa909eeb94b774d82630ffc98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x64_128</b> (const void *key, const int len, const uint32_t seed, void *out)</td></tr>
<tr class="separator:ab5c9229fa909eeb94b774d82630ffc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c8114ce19cbe8d7aba391cc00a04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a220c8114ce19cbe8d7aba391cc00a04b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceTypeName</b> (const int32_t &amp;d)</td></tr>
<tr class="separator:a220c8114ce19cbe8d7aba391cc00a04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4a606edca5a14e8a672dd07e784e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a4a606edca5a14e8a672dd07e784e75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSameDevice</b> (const DeviceOption &amp;lhs, const DeviceOption &amp;rhs)</td></tr>
<tr class="separator:a6a4a606edca5a14e8a672dd07e784e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2859f4f68d05334e5e8d65e389e59ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2859f4f68d05334e5e8d65e389e59ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadStringFromFile</b> (const char *filename, string *str)</td></tr>
<tr class="separator:ae2859f4f68d05334e5e8d65e389e59ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a6dab5657f189505350a0ea0f0253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c5a6dab5657f189505350a0ea0f0253"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WriteStringToFile</b> (const string &amp;str, const char *filename)</td></tr>
<tr class="separator:a1c5a6dab5657f189505350a0ea0f0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9886fa046ce8a853ac6d8a8d1a77d2cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9886fa046ce8a853ac6d8a8d1a77d2cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromTextFile</b> (const char *filename, Message *proto)</td></tr>
<tr class="separator:a9886fa046ce8a853ac6d8a8d1a77d2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7681e2ec093b7ae7f746a3739b343fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7681e2ec093b7ae7f746a3739b343fc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToTextFile</b> (const Message &amp;proto, const char *filename)</td></tr>
<tr class="separator:a7681e2ec093b7ae7f746a3739b343fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9029f1ac1b6ecd1551e69778ea262c9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9029f1ac1b6ecd1551e69778ea262c9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromBinaryFile</b> (const char *filename, MessageLite *proto)</td></tr>
<tr class="separator:a9029f1ac1b6ecd1551e69778ea262c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da65e9dd896203cb899ac8096772836"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1da65e9dd896203cb899ac8096772836"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToBinaryFile</b> (const MessageLite &amp;proto, const char *filename)</td></tr>
<tr class="separator:a1da65e9dd896203cb899ac8096772836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02de292b6d9d8eec4669f4a41237d5d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02de292b6d9d8eec4669f4a41237d5d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const NetDef &amp;l, const NetDef &amp;r)</td></tr>
<tr class="separator:a02de292b6d9d8eec4669f4a41237d5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f6ec4b6a64af60b595c14df4ca9d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9f6ec4b6a64af60b595c14df4ca9d04"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;output, const NetDef &amp;n)</td></tr>
<tr class="separator:ac9f6ec4b6a64af60b595c14df4ca9d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7ce208db0da25e3447036b3f4f47d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66c7ce208db0da25e3447036b3f4f47d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a66c7ce208db0da25e3447036b3f4f47d"><td class="memTemplItemLeft" align="right" valign="top">Argument&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeArgument</b> (const string &amp;name, const MessageLite &amp;value)</td></tr>
<tr class="separator:a66c7ce208db0da25e3447036b3f4f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24dde499614e22286208ca6c59a6f4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae24dde499614e22286208ca6c59a6f4b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasOutput</b> (const OperatorDef &amp;op, const std::string &amp;output)</td></tr>
<tr class="separator:ae24dde499614e22286208ca6c59a6f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7e657102f426c70d571f595236bd1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addd7e657102f426c70d571f595236bd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasInput</b> (const OperatorDef &amp;op, const std::string &amp;input)</td></tr>
<tr class="separator:addd7e657102f426c70d571f595236bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ec6e8afda8c8b6231ac63126f624ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ec6e8afda8c8b6231ac63126f624ca"></a>
const Argument &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetArgument</b> (const OperatorDef &amp;def, const string &amp;name)</td></tr>
<tr class="separator:a51ec6e8afda8c8b6231ac63126f624ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78921a720415b2c70de29f6a94a83ab9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78921a720415b2c70de29f6a94a83ab9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlagArgument</b> (const OperatorDef &amp;def, const string &amp;name, bool def_value)</td></tr>
<tr class="separator:a78921a720415b2c70de29f6a94a83ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a326d0d8aad5e0fc1ac98616e36705"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3a326d0d8aad5e0fc1ac98616e36705"></a>
Argument *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMutableArgument</b> (const string &amp;name, const bool create_if_missing, OperatorDef *def)</td></tr>
<tr class="separator:ac3a326d0d8aad5e0fc1ac98616e36705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7014e29ce11c4df85ee7f178e57b0b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7014e29ce11c4df85ee7f178e57b0b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromBinaryFile</b> (const string filename, MessageLite *proto)</td></tr>
<tr class="separator:ad7014e29ce11c4df85ee7f178e57b0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e48bc7da22ad09a9e6c53c029fc166"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7e48bc7da22ad09a9e6c53c029fc166"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToBinaryFile</b> (const MessageLite &amp;proto, const string &amp;filename)</td></tr>
<tr class="separator:aa7e48bc7da22ad09a9e6c53c029fc166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06aa493c35c111e34f3664e2154118"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab06aa493c35c111e34f3664e2154118"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>ProtoDebugString</b> (const Message &amp;proto)</td></tr>
<tr class="separator:aab06aa493c35c111e34f3664e2154118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4d270640fe3295f155f0a325451f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e4d270640fe3295f155f0a325451f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromTextFile</b> (const string filename, Message *proto)</td></tr>
<tr class="separator:aa2e4d270640fe3295f155f0a325451f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9842cb97b5568c533b21f5e0d34694"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c9842cb97b5568c533b21f5e0d34694"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToTextFile</b> (const Message &amp;proto, const string &amp;filename)</td></tr>
<tr class="separator:a2c9842cb97b5568c533b21f5e0d34694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4c76aea16a60bb6194c5235a2b5b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cd4c76aea16a60bb6194c5235a2b5b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromFile</b> (const char *filename, Message *proto)</td></tr>
<tr class="separator:a4cd4c76aea16a60bb6194c5235a2b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c104b71dcb8d6689e47c8eb1c9edd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6c104b71dcb8d6689e47c8eb1c9edd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromFile</b> (const string &amp;filename, Message *proto)</td></tr>
<tr class="separator:aed6c104b71dcb8d6689e47c8eb1c9edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf56a50048541aae3fc997a79e2315"><td class="memTemplParams" colspan="2"><a class="anchor" id="aebbf56a50048541aae3fc997a79e2315"></a>
template&lt;class IterableInputs  = std::initializer_list&lt;string&gt;, class IterableOutputs  = std::initializer_list&lt;string&gt;, class IterableArgs  = std::initializer_list&lt;Argument&gt;&gt; </td></tr>
<tr class="memitem:aebbf56a50048541aae3fc997a79e2315"><td class="memTemplItemLeft" align="right" valign="top">OperatorDef&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateOperatorDef</b> (const string &amp;type, const string &amp;name, const IterableInputs &amp;inputs, const IterableOutputs &amp;outputs, const IterableArgs &amp;args, const DeviceOption &amp;device_option=DeviceOption(), const string &amp;engine=&quot;&quot;)</td></tr>
<tr class="separator:aebbf56a50048541aae3fc997a79e2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29e74962bf44701fd387c5f129b68c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1b29e74962bf44701fd387c5f129b68c"></a>
template&lt;class IterableInputs  = std::initializer_list&lt;string&gt;, class IterableOutputs  = std::initializer_list&lt;string&gt;&gt; </td></tr>
<tr class="memitem:a1b29e74962bf44701fd387c5f129b68c"><td class="memTemplItemLeft" align="right" valign="top">OperatorDef&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateOperatorDef</b> (const string &amp;type, const string &amp;name, const IterableInputs &amp;inputs, const IterableOutputs &amp;outputs, const DeviceOption &amp;device_option=DeviceOption(), const string &amp;engine=&quot;&quot;)</td></tr>
<tr class="separator:a1b29e74962bf44701fd387c5f129b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0c30960ea7ea3b02e461b902196a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="acec0c30960ea7ea3b02e461b902196a4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acec0c30960ea7ea3b02e461b902196a4"><td class="memTemplItemLeft" align="right" valign="top">Argument&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeArgument</b> (const string &amp;name, const T &amp;value)</td></tr>
<tr class="separator:acec0c30960ea7ea3b02e461b902196a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fe7c3dabef65d5aee07f54aa8a85e8e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddArgument</b> (const string &amp;name, const T &amp;value, OperatorDef *def)</td></tr>
<tr class="separator:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81b709fceb86f663d11ab502b1d1ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea81b709fceb86f663d11ab502b1d1ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const DeviceOption &amp;dl, const DeviceOption &amp;dr)</td></tr>
<tr class="separator:aea81b709fceb86f663d11ab502b1d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681d9c5cbe25a7e3ac4b7a32f80391b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9681d9c5cbe25a7e3ac4b7a32f80391b"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (char separator, const std::string &amp;string)</td></tr>
<tr class="separator:a9681d9c5cbe25a7e3ac4b7a32f80391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f4c349da35ab5c551a3dd29c61f732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2f4c349da35ab5c551a3dd29c61f732"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>editDistance</b> (const std::string &amp;s1, const std::string &amp;s2, size_t max_distance)</td></tr>
<tr class="separator:aa2f4c349da35ab5c551a3dd29c61f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61001fa69bf0c7b2c13495d0af76d763"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61001fa69bf0c7b2c13495d0af76d763"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>editDistanceHelper</b> (const char *s1, size_t s1_len, const char *s2, size_t s2_len, std::vector&lt; size_t &gt; &amp;current, std::vector&lt; size_t &gt; &amp;previous, std::vector&lt; size_t &gt; &amp;previous1, size_t max_distance)</td></tr>
<tr class="separator:a61001fa69bf0c7b2c13495d0af76d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39806ba605fafaac38f9e9c539706f4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39806ba605fafaac38f9e9c539706f4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Do256NOPs</b> ()</td></tr>
<tr class="separator:a39806ba605fafaac38f9e9c539706f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2c95d7b8489a4665a6fd90de8e93df0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WaitForVariableChange</b> (std::atomic&lt; T &gt; *var, T initial_value, std::condition_variable *cond, std::mutex *mutex)</td></tr>
<tr class="separator:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06975f79f2761859f54567b4c0ab1f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad06975f79f2761859f54567b4c0ab1f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>OpticalFlowExtractor</b> (const cv::Mat &amp;prev_gray, const cv::Mat &amp;curr_gray, const int flow_alg_type, cv::Mat &amp;flow)</td></tr>
<tr class="separator:ad06975f79f2761859f54567b4c0ab1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac508d77cbce42907eb769c3af6a33d71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac508d77cbce42907eb769c3af6a33d71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MergeOpticalFlow</b> (cv::Mat &amp;prev_flow, const cv::Mat &amp;curr_flow)</td></tr>
<tr class="separator:ac508d77cbce42907eb769c3af6a33d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241d9ae73921604aaf500633d2c96e3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a241d9ae73921604aaf500633d2c96e3a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MultiFrameOpticalFlowExtractor</b> (const std::vector&lt; cv::Mat &gt; &amp;grays, const int optical_flow_alg_type, cv::Mat &amp;flow)</td></tr>
<tr class="separator:a241d9ae73921604aaf500633d2c96e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ac2eb7e450d80ba2700e9d49bb7803"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47ac2eb7e450d80ba2700e9d49bb7803"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (VideoInput, <a class="el" href="classcaffe2_1_1_video_input_op.html">VideoInputOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a47ac2eb7e450d80ba2700e9d49bb7803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7866928eb54d9801cb869da86329975d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7866928eb54d9801cb869da86329975d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;){<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a> helper(def);int batch_size=helper.GetSingleArgument&lt; int &gt;(&quot;batch_size&quot;, 0);int clip_per_video=helper.GetSingleArgument&lt; int &gt;(&quot;clip_per_video&quot;, 1);int crop_height=helper.GetSingleArgument&lt; int &gt;(&quot;crop_height&quot;, helper.GetSingleArgument&lt; int &gt;(&quot;crop_size&quot;, 0));int crop_width=helper.GetSingleArgument&lt; int &gt;(&quot;crop_width&quot;, helper.GetSingleArgument&lt; int &gt;(&quot;crop_size&quot;, 0));int length_rgb=helper.GetSingleArgument&lt; int &gt;(&quot;length_rgb&quot;, 0);int channels_rgb=helper.GetSingleArgument&lt; int &gt;(&quot;channels_rgb&quot;, 3);int length_of=helper.GetSingleArgument&lt; int &gt;(&quot;length_of&quot;, 0);int channels_of=helper.GetSingleArgument&lt; int &gt;(&quot;channels_of&quot;, 2);bool get_rgb=helper.GetSingleArgument&lt; bool &gt;(&quot;get_rgb&quot;, true);bool get_optical_flow=helper.GetSingleArgument&lt; bool &gt;(&quot;get_optical_flow&quot;, false);bool do_multi_label=helper.GetSingleArgument&lt; bool &gt;(&quot;do_multi_label&quot;, false);bool get_video_id=helper.GetSingleArgument&lt; bool &gt;(&quot;get_video_id&quot;, false);int output_size=1;if(get_rgb){output_size++;}if(get_optical_flow){output_size++;}if(get_video_id){output_size++;}int index=0;vector&lt; TensorShape &gt; out(output_size);CHECK_GT(crop_height, 0);CHECK_GT(crop_width, 0);batch_size *=clip_per_video;if(get_rgb){out[index++]=CreateTensorShape(vector&lt; int &gt;{batch_size, channels_rgb, length_rgb, crop_height, crop_width}, TensorProto::FLOAT);}if(get_optical_flow){out[index++]=CreateTensorShape(vector&lt; int &gt;{batch_size, channels_of, length_of, crop_height, crop_width}, TensorProto::FLOAT);}if(!do_multi_label){out[index++]=CreateTensorShape(vector&lt; int &gt;{1, batch_size}, TensorProto::INT32);}else{int num_of_class=helper.GetSingleArgument&lt; int &gt;(&quot;num_of_class&quot;, 0);out[index++]=CreateTensorShape(vector&lt; int &gt;{batch_size, num_of_class}, TensorProto::INT32);}if(get_video_id){out[index]=CreateTensorShape(vector&lt; int &gt;{1, batch_size}, TensorProto::INT32);}return out;})</td></tr>
<tr class="separator:a7866928eb54d9801cb869da86329975d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08128f09da097f94938d256fe2ca0db7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08128f09da097f94938d256fe2ca0db7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (VideoInput)</td></tr>
<tr class="separator:a08128f09da097f94938d256fe2ca0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a1119be7ed5fbbe15f12e9e6f908ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8a1119be7ed5fbbe15f12e9e6f908ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (VideoInput, <a class="el" href="classcaffe2_1_1_video_input_op.html">VideoInputOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_u_d_a_context.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae8a1119be7ed5fbbe15f12e9e6f908ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fa77afbe3272c8aee7667bd504175a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62fa77afbe3272c8aee7667bd504175a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Saturation</b> (float *clip, const int length, const int crop_height, const int crop_width, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:a62fa77afbe3272c8aee7667bd504175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a906d5d8188b122429b1a7cbb4bedd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63a906d5d8188b122429b1a7cbb4bedd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Brightness</b> (float *clip, const int length, const int crop_height, const int crop_width, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:a63a906d5d8188b122429b1a7cbb4bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cae843791901a20f962d51ba26488f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1cae843791901a20f962d51ba26488f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Contrast</b> (float *clip, const int length, const int crop_height, const int crop_width, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:ad1cae843791901a20f962d51ba26488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282bff30c49c6c699ed9eb2687cf74dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a282bff30c49c6c699ed9eb2687cf74dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ColorJitter</b> (float *clip, const int length, const int crop_height, const int crop_width, const float saturation, const float brightness, const float contrast, std::mt19937 *randgen)</td></tr>
<tr class="separator:a282bff30c49c6c699ed9eb2687cf74dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acc5e6c3040a1986c8e8736d01e8ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7acc5e6c3040a1986c8e8736d01e8ec5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ColorLighting</b> (float *clip, const int length, const int crop_height, const int crop_width, const float alpha_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;eigvecs, const std::vector&lt; float &gt; &amp;eigvals, std::mt19937 *randgen)</td></tr>
<tr class="separator:a7acc5e6c3040a1986c8e8736d01e8ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70033d27ddd9ea416d746eeb332fec3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70033d27ddd9ea416d746eeb332fec3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ColorNormalization</b> (float *clip, const int length, const int crop_height, const int crop_width, const int channels, const std::vector&lt; float &gt; &amp;mean, const std::vector&lt; float &gt; &amp;inv_std)</td></tr>
<tr class="separator:a70033d27ddd9ea416d746eeb332fec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d771211931586cf35b45a79ebf57ead"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d771211931586cf35b45a79ebf57ead"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClipTransformRGB</b> (const unsigned char *buffer_rgb, const int multi_crop_count, const int crop_height, const int crop_width, const int length_rgb, const int channels_rgb, const int sampling_rate_rgb, const int height, const int width, const int h_off, const int w_off, const int *multi_crop_h_off, const int *multi_crop_w_off, const bool mirror_me, const bool color_jitter, const float saturation, const float brightness, const float contrast, const bool color_lighting, const float color_lighting_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;color_lighting_eigvecs, const std::vector&lt; float &gt; &amp;color_lighting_eigvals, const std::vector&lt; float &gt; &amp;mean_rgb, const std::vector&lt; float &gt; &amp;inv_std_rgb, std::mt19937 *randgen, float *transformed_clip)</td></tr>
<tr class="separator:a4d771211931586cf35b45a79ebf57ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49a222056a7c5998b1d6d9b0a0adf85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad49a222056a7c5998b1d6d9b0a0adf85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClipTransformOpticalFlow</b> (const unsigned char *buffer_rgb, const int crop_height, const int crop_width, const int length_of, const int channels_of, const int sampling_rate_of, const int height, const int width, const cv::Rect &amp;rect, const int channels_rgb, const bool mirror_me, const int flow_alg_type, const int flow_data_type, const int frame_gap_of, const bool do_flow_aggregation, const std::vector&lt; float &gt; &amp;mean_of, const std::vector&lt; float &gt; &amp;inv_std_of, float *transformed_clip)</td></tr>
<tr class="separator:ad49a222056a7c5998b1d6d9b0a0adf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897e93cb492525b56d8a21df34c19105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a897e93cb492525b56d8a21df34c19105"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FreeDecodedData</b> (std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_decoded_frame.html">DecodedFrame</a> &gt;&gt; &amp;sampledFrames)</td></tr>
<tr class="separator:a897e93cb492525b56d8a21df34c19105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543286a5ce8dca7d5932f50c98922a20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a543286a5ce8dca7d5932f50c98922a20"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DecodeMultipleClipsFromVideo</b> (const char *video_buffer, const std::string &amp;video_filename, const int encoded_size, const <a class="el" href="classcaffe2_1_1_params.html">Params</a> &amp;params, const int start_frm, const int clip_per_video, const bool use_local_file, int &amp;height, int &amp;width, std::vector&lt; unsigned char * &gt; &amp;buffer_rgb)</td></tr>
<tr class="separator:a543286a5ce8dca7d5932f50c98922a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacced94806e0e3664e212f3c1dd6e724"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacced94806e0e3664e212f3c1dd6e724"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AffineChannel, <a class="el" href="classcaffe2_1_1_affine_channel_op.html">AffineChannelOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aacced94806e0e3664e212f3c1dd6e724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138880046ad58ebf127db5b4f2ef6a20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a138880046ad58ebf127db5b4f2ef6a20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AffineChannelGradient, <a class="el" href="classcaffe2_1_1_affine_channel_gradient_op.html">AffineChannelGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a138880046ad58ebf127db5b4f2ef6a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79c3a20b5a8076243207b216776525"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa79c3a20b5a8076243207b216776525"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Applies a separate affine transformation to each channel of the input. Useful
for replacing spatial batch norm with its equivalent fixed transformation.
)DOC&quot;).Input(0</td></tr>
<tr class="separator:afa79c3a20b5a8076243207b216776525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecc9f7161974e24c3e13b413b3ee7b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ecc9f7161974e24c3e13b413b3ee7b0"></a>
feature map input of input of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (C)</td></tr>
<tr class="separator:a7ecc9f7161974e24c3e13b413b3ee7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4b7f5974bbed0a67a980bfaae0f140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e4b7f5974bbed0a67a980bfaae0f140"></a>
the c th element is the scale factor of the affine transformation for the c th channel of the input&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;bias&quot;,&quot;1D input of shape (C); the c-th element is the bias of the affine &quot;&quot;transformation for the c-th channel of the input.&quot;).Output(0</td></tr>
<tr class="separator:a8e4b7f5974bbed0a67a980bfaae0f140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e0cca54317791227ed4d2901dd03bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3e0cca54317791227ed4d2901dd03bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;scale&quot;,&quot;See AffineChannel.&quot;).Input(1</td></tr>
<tr class="separator:ad3e0cca54317791227ed4d2901dd03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389e705d13db7335cfa69a8a7e106720"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a389e705d13db7335cfa69a8a7e106720"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AffineChannel, <a class="el" href="classcaffe2_1_1_get_affine_channel_gradient.html">GetAffineChannelGradient</a>)</td></tr>
<tr class="separator:a389e705d13db7335cfa69a8a7e106720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f082d8c4f145d5f51c67aa508efbb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38f082d8c4f145d5f51c67aa508efbb6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchPermutation, <a class="el" href="classcaffe2_1_1_batch_permutation_op.html">BatchPermutationOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38f082d8c4f145d5f51c67aa508efbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9cfb9d3abf26a0c05194a325492a2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a9cfb9d3abf26a0c05194a325492a2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchPermutationGradient, <a class="el" href="classcaffe2_1_1_batch_permutation_gradient_op.html">BatchPermutationGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3a9cfb9d3abf26a0c05194a325492a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c17b91a2241ea55b117106f987b66fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c17b91a2241ea55b117106f987b66fe"></a>
NumInputs(2).NumOutputs(1).SetDoc(R&quot;DOC( Permute the batch elements of the input tensor X according to the permutation specified in the input indices. Warning gradient comptuation is only correct if indices is a permutation DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of at least 1D shape (N, D0, D1, ...).&quot;).Input(1</td></tr>
<tr class="separator:a9c17b91a2241ea55b117106f987b66fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8844154623370dfe13de610ddeaefd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8844154623370dfe13de610ddeaefd3"></a>
NumInputs(2).NumOutputs(1).SetDoc(R&quot;DOC( Permute the batch elements of the input tensor X according to the permutation specified in the input indices. Warning gradient comptuation is only correct if indices is a permutation DOC tensor of type int with&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N,) specifying a valid permutation&quot; &quot;of the indices in[0</td></tr>
<tr class="separator:ad8844154623370dfe13de610ddeaefd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7283537f107df33c628746c81afc5fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7283537f107df33c628746c81afc5fc"></a>
NumInputs(2).NumOutputs(1).SetDoc(R&quot;DOC( Permute the batch elements of the input tensor X according to the permutation specified in the input indices. Warning gradient comptuation is only correct if indices is a permutation DOC tensor of type int with&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> (inclusive).&quot;) .Output( 0</td></tr>
<tr class="separator:ac7283537f107df33c628746c81afc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15915f53dc52c111731276f12346174"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae15915f53dc52c111731276f12346174"></a>
NumInputs(2).NumOutputs(1).SetDoc(R&quot;DOC( Permute the batch elements of the input tensor X according to the permutation specified in the input indices. Warning gradient comptuation is only correct if indices is a permutation DOC tensor of type int with <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> with the same shape as X where&#160;</td><td class="memItemRight" valign="bottom"><b>the</b> (D0, D1,...) dimensional&quot; &quot;batch elements of X are permuted according to the input indices.&quot;)</td></tr>
<tr class="separator:ae15915f53dc52c111731276f12346174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcccc36ca7e0e492f0021431546103fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcccc36ca7e0e492f0021431546103fb"></a>
See BatchPermutation&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;dY&quot;,&quot;Gradient of forward output 0 (Y).&quot;).Output(0</td></tr>
<tr class="separator:abcccc36ca7e0e492f0021431546103fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9eb2851d78b0867e7d887c8293f2e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa9eb2851d78b0867e7d887c8293f2e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BatchPermutation, <a class="el" href="classcaffe2_1_1_get_batch_permutation_gradient.html">GetBatchPermutationGradient</a>)</td></tr>
<tr class="separator:afa9eb2851d78b0867e7d887c8293f2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c97146bde25c2f926851ff74243a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c97146bde25c2f926851ff74243a98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GroupSpatialSoftmax, <a class="el" href="classcaffe2_1_1_group_spatial_softmax_op.html">GroupSpatialSoftmaxOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a90c97146bde25c2f926851ff74243a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815415bc1ff4a49974a3544ed65eb86c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a815415bc1ff4a49974a3544ed65eb86c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GroupSpatialSoftmaxGradient, <a class="el" href="classcaffe2_1_1_group_spatial_softmax_gradient_op.html">GroupSpatialSoftmaxGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a815415bc1ff4a49974a3544ed65eb86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1973896ad27b9662177a275c47de3370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1973896ad27b9662177a275c47de3370"></a>
number of classes in each softmax group&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;scores&quot;,&quot;4D tensor of softmax inputs (called 'scores' or 'logits') with shape &quot;&quot;(N, C, H, W), where C = num_anchors * num_classes defines num_anchors &quot;&quot;groups of contiguous num_classes softmax inputs.&quot;).Output(0</td></tr>
<tr class="separator:a1973896ad27b9662177a275c47de3370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace36496eb7f47d0796d35f6301da28f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace36496eb7f47d0796d35f6301da28f8"></a>
See GroupSpatialSoftmax&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;d_probabilities&quot;,&quot;Gradient of forward output 0 (probabilities).&quot;).Output(0</td></tr>
<tr class="separator:ace36496eb7f47d0796d35f6301da28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b90052b204ce8384b1ac45307e5bcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0b90052b204ce8384b1ac45307e5bcd"></a>
See GroupSpatialSoftmax Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (scores).&quot;)</td></tr>
<tr class="separator:aa0b90052b204ce8384b1ac45307e5bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224ffd10bbfd86472315b4ad1d01a130"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a224ffd10bbfd86472315b4ad1d01a130"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (GroupSpatialSoftmax, <a class="el" href="classcaffe2_1_1_get_group_spatial_softmax_gradient.html">GetGroupSpatialSoftmaxGradient</a>)</td></tr>
<tr class="separator:a224ffd10bbfd86472315b4ad1d01a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788ed0673e098a2b8af50ac7e3493363"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788ed0673e098a2b8af50ac7e3493363"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PSRoIPool, <a class="el" href="classcaffe2_1_1_p_s_ro_i_pool_op.html">PSRoIPoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a788ed0673e098a2b8af50ac7e3493363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daa6b7d123ec6bd8ce2cd31436a5584"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2daa6b7d123ec6bd8ce2cd31436a5584"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PSRoIPoolGradient, <a class="el" href="classcaffe2_1_1_p_s_ro_i_pool_gradient_op.html">PSRoIPoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2daa6b7d123ec6bd8ce2cd31436a5584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c9465f9ddd2a5ca2b45eaae97b15eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c9465f9ddd2a5ca2b45eaae97b15eb"></a>
Spatial scale of the input feature map X relative to the input image E if X has a stride of w r t the input image&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;group_size&quot;,&quot;(int) default 1; pooled_h = pooled_w = group_size where pooled_{h,w} &quot;&quot;is the pooled output Y's height and width, respectively.&quot;).Arg(&quot;output_dim&quot;</td></tr>
<tr class="separator:a85c9465f9ddd2a5ca2b45eaae97b15eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72114556592a2a580890dfb40ccb7275"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72114556592a2a580890dfb40ccb7275"></a>
number of channels in the pooled which might be the number of classes is used for classification or if used for class agnostic bounding box regression&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;4D position sensitive feature map input of shape (N, C, H, W), where &quot;&quot;C = group_size**2 * output_dim.&quot;).Input(1</td></tr>
<tr class="separator:a72114556592a2a580890dfb40ccb7275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fba055e322a02f230ec321c9b25ecc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68fba055e322a02f230ec321c9b25ecc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIPoolF, <a class="el" href="classcaffe2_1_1_ro_i_pool_f_op.html">RoIPoolFOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a68fba055e322a02f230ec321c9b25ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41073fb5661c63562cf557d908e0608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac41073fb5661c63562cf557d908e0608"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RoIPoolFGradient, <a class="el" href="classcaffe2_1_1_ro_i_pool_f_gradient_op.html">RoIPoolFGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac41073fb5661c63562cf557d908e0608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90302b0b1952dc77d5083e214293f2ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90302b0b1952dc77d5083e214293f2ba"></a>
Pooled output Y s width&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0,&quot;X&quot;,&quot;4D feature map input of shape (N, C, H, W).&quot;).Input(1</td></tr>
<tr class="separator:a90302b0b1952dc77d5083e214293f2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3f33f630d6cdd61839f03971f0e93d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3f33f630d6cdd61839f03971f0e93d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SampleAs, <a class="el" href="classcaffe2_1_1_sample_as_op.html">SampleAsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aaf3f33f630d6cdd61839f03971f0e93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0e8b0c7c1029585126c5b630a9269"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7a0e8b0c7c1029585126c5b630a9269"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SampleAsGradient, <a class="el" href="classcaffe2_1_1_sample_as_gradient_op.html">SampleAsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac7a0e8b0c7c1029585126c5b630a9269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a7ab07bfd416c848e69dbe62c76b98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82a7ab07bfd416c848e69dbe62c76b98"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of at least&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N,...).&quot;) .Input( 1</td></tr>
<tr class="separator:a82a7ab07bfd416c848e69dbe62c76b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3843b22da2f0eab2d648ded3eeedfa4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3843b22da2f0eab2d648ded3eeedfa4c"></a>
See SampleAs&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;labels&quot;,&quot;See SampleAs.&quot;).Input(2</td></tr>
<tr class="separator:a3843b22da2f0eab2d648ded3eeedfa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c45f32d1588a2fc3ad183a61d050af1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c45f32d1588a2fc3ad183a61d050af1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SampleAs, <a class="el" href="classcaffe2_1_1_get_sample_as_gradient.html">GetSampleAsGradient</a>)</td></tr>
<tr class="separator:a1c45f32d1588a2fc3ad183a61d050af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711ebcb62a132724de7ad4ace8f82c24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a711ebcb62a132724de7ad4ace8f82c24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SelectSmoothL1Loss, <a class="el" href="classcaffe2_1_1_select_smooth_l1_loss_op.html">SelectSmoothL1LossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a711ebcb62a132724de7ad4ace8f82c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb34c0080fee79e0c74b2ac7e1f7f3ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb34c0080fee79e0c74b2ac7e1f7f3ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SelectSmoothL1LossGradient, <a class="el" href="classcaffe2_1_1_select_smooth_l1_loss_gradient_op.html">SelectSmoothL1LossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aeb34c0080fee79e0c74b2ac7e1f7f3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec16d812ba602247ac91bf9bb5d0d196"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec16d812ba602247ac91bf9bb5d0d196"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;scale&quot;,&quot;(float) default 1.0; multiply the loss by this scale factor.&quot;).Input(0</td></tr>
<tr class="separator:aec16d812ba602247ac91bf9bb5d0d196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac40c0116bfdc0b0c53d94f2e4909fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeac40c0116bfdc0b0c53d94f2e4909fc"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a> tensor of bounding box regression predictions with&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N, 4 *num_bbox_classes *num_anchors, H, W).&quot;) .Input( 1</td></tr>
<tr class="separator:aeac40c0116bfdc0b0c53d94f2e4909fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5948b578ab7b8b92e21d813eaabed7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5948b578ab7b8b92e21d813eaabed7b"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a> tensor of bounding box regression predictions with tensor of labels&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (M, 4) for 4 contiguous channels starting&quot; &quot;at each of the M locations selected by the locations input.&quot;) .Input( 2</td></tr>
<tr class="separator:af5948b578ab7b8b92e21d813eaabed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e248f8de75b327ca1516eadc44bb561"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e248f8de75b327ca1516eadc44bb561"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a> tensor of bounding box regression predictions with tensor of labels tensor of shape(M, 4) that identifies M 'select'locations&quot; &quot;encoded by the four colums the loss is divided by&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> (1, normalizer).&quot;) .Output( 0</td></tr>
<tr class="separator:a7e248f8de75b327ca1516eadc44bb561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd30ff796d30d266fbba7e252712f350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd30ff796d30d266fbba7e252712f350"></a>
See SelectSmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;Y&quot;,&quot;See SelectSmoothL1Loss.&quot;).Input(2</td></tr>
<tr class="separator:abd30ff796d30d266fbba7e252712f350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949959c95c643b3431a497834689e471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a949959c95c643b3431a497834689e471"></a>
See SelectSmoothL1Loss See SelectSmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;normalizer&quot;,&quot;See SelectSmoothL1Loss.&quot;).Input(4</td></tr>
<tr class="separator:a949959c95c643b3431a497834689e471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877ef62eb82a29223ff013a9264bebba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a877ef62eb82a29223ff013a9264bebba"></a>
See SelectSmoothL1Loss See SelectSmoothL1Loss Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>output</b> (loss).&quot;) .Output( 0</td></tr>
<tr class="separator:a877ef62eb82a29223ff013a9264bebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8415f2e392acc597d4ed63553dc37a31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8415f2e392acc597d4ed63553dc37a31"></a>
See SelectSmoothL1Loss See SelectSmoothL1Loss Gradient of forward Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (Y_hat).&quot;)</td></tr>
<tr class="separator:a8415f2e392acc597d4ed63553dc37a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0ceca2cf0296fcf89ec7c4cf872390"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade0ceca2cf0296fcf89ec7c4cf872390"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SelectSmoothL1Loss, <a class="el" href="classcaffe2_1_1_get_select_smooth_l1_loss_gradient.html">GetSelectSmoothL1LossGradient</a>)</td></tr>
<tr class="separator:ade0ceca2cf0296fcf89ec7c4cf872390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e9367429f62e5cd61f5d7ee9975211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e9367429f62e5cd61f5d7ee9975211"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyLoss, <a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_loss_op.html">SigmoidCrossEntropyLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a86e9367429f62e5cd61f5d7ee9975211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17e12cfbd16282bd46aae67a9f0cb86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac17e12cfbd16282bd46aae67a9f0cb86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyLossGradient, <a class="el" href="classcaffe2_1_1_sigmoid_cross_entropy_loss_gradient_op.html">SigmoidCrossEntropyLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac17e12cfbd16282bd46aae67a9f0cb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb678dbb5eeafb7649de7851ca1aaa38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb678dbb5eeafb7649de7851ca1aaa38"></a>
multiply the loss by this scale factor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;normalize&quot;,&quot;(int) default 1; if true, divide the loss by the number of targets &gt; &quot;&quot;-1.&quot;).Input(0</td></tr>
<tr class="separator:acb678dbb5eeafb7649de7851ca1aaa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768a6a8cc259b72f6a8eb79150c22920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a768a6a8cc259b72f6a8eb79150c22920"></a>
multiply the loss by this scale factor <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of predicted&#160;</td><td class="memItemRight" valign="bottom"><b>logits</b> (shape must be at least 1D).&quot;) .Input( 1</td></tr>
<tr class="separator:a768a6a8cc259b72f6a8eb79150c22920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9053a992d9f256cb63a3daa367f39160"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9053a992d9f256cb63a3daa367f39160"></a>
multiply the loss by this scale factor <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of predicted <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of targets of type int and same shape as logits X&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0,&quot;loss&quot;,&quot;Scalar loss.&quot;)</td></tr>
<tr class="separator:a9053a992d9f256cb63a3daa367f39160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccfca8a826fad70e49764edce235da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ccfca8a826fad70e49764edce235da1"></a>
See SigmoidCrossEntropyLoss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;targets&quot;,&quot;See SigmoidCrossEntropyLoss.&quot;).Input(2</td></tr>
<tr class="separator:a5ccfca8a826fad70e49764edce235da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea66cee584c22eb4732a5b9701118674"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea66cee584c22eb4732a5b9701118674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SigmoidCrossEntropyLoss, <a class="el" href="classcaffe2_1_1_get_sigmoid_cross_entropy_loss_gradient.html">GetSigmoidCrossEntropyLossGradient</a>)</td></tr>
<tr class="separator:aea66cee584c22eb4732a5b9701118674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35cc48380697571474ff70dcef71550"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae35cc48380697571474ff70dcef71550"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidFocalLoss, <a class="el" href="classcaffe2_1_1_sigmoid_focal_loss_op.html">SigmoidFocalLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae35cc48380697571474ff70dcef71550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96bcc23e944812089c7335781eb7f0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa96bcc23e944812089c7335781eb7f0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidFocalLossGradient, <a class="el" href="classcaffe2_1_1_sigmoid_focal_loss_gradient_op.html">SigmoidFocalLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa96bcc23e944812089c7335781eb7f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf47dfea18c3b1ba665d8159a5bd3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37cf47dfea18c3b1ba665d8159a5bd3e"></a>
where N is the number of elements in the H and W are the height and and each of length num_classes For the binary form of Focal num_classes does not include the background category(So, for COCO, num_classes=80, not 81.) The binary form of focal loss is multiply the loss by this scale factor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;alpha&quot;,&quot;(float) default 0.25; Focal Loss's alpha hyper-parameter.&quot;).Arg(&quot;gamma&quot;</td></tr>
<tr class="separator:a37cf47dfea18c3b1ba665d8159a5bd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72f655a6e52ae3c448efbb00c8318ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72f655a6e52ae3c448efbb00c8318ad"></a>
Focal Loss s gamma hyper parameter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_classes&quot;,&quot;(int) default 80; number of classes (excluding background).&quot;).Input(0</td></tr>
<tr class="separator:aa72f655a6e52ae3c448efbb00c8318ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5258173f1875bbf78401f3545513a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0f5258173f1875bbf78401f3545513a"></a>
Focal Loss s gamma hyper parameter tensor of sigmoid&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b> (called 'scores'or 'logits') with shape&quot; &quot;(N</td></tr>
<tr class="separator:ac0f5258173f1875bbf78401f3545513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8405c53fe63a80b778c99883ae8a2a37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8405c53fe63a80b778c99883ae8a2a37"></a>
See SigmoidFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;labels&quot;,&quot;See SigmoidFocalLoss.&quot;).Input(2</td></tr>
<tr class="separator:a8405c53fe63a80b778c99883ae8a2a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f54cd71752cad0abea5ed0528232075"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f54cd71752cad0abea5ed0528232075"></a>
See SigmoidFocalLoss See SigmoidFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;d_loss&quot;,&quot;Gradient of forward output 0 (loss)&quot;).Output(0</td></tr>
<tr class="separator:a8f54cd71752cad0abea5ed0528232075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d45aee18386cbb2cc33a5f9a595d48f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d45aee18386cbb2cc33a5f9a595d48f"></a>
See SigmoidFocalLoss See SigmoidFocalLoss Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (logits)&quot;)</td></tr>
<tr class="separator:a1d45aee18386cbb2cc33a5f9a595d48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add77fe9d2b75981ce67de50f4ef17612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add77fe9d2b75981ce67de50f4ef17612"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SigmoidFocalLoss, <a class="el" href="classcaffe2_1_1_get_sigmoid_focal_loss_gradient.html">GetSigmoidFocalLossGradient</a>)</td></tr>
<tr class="separator:add77fe9d2b75981ce67de50f4ef17612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202fee4948fc05b25a551c4c5ca1684e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a202fee4948fc05b25a551c4c5ca1684e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SmoothL1Loss, <a class="el" href="classcaffe2_1_1_smooth_l1_loss_op.html">SmoothL1LossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a202fee4948fc05b25a551c4c5ca1684e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5dae30627e5ff1b253660c91f1c23b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada5dae30627e5ff1b253660c91f1c23b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SmoothL1LossGradient, <a class="el" href="classcaffe2_1_1_smooth_l1_loss_gradient_op.html">SmoothL1LossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ada5dae30627e5ff1b253660c91f1c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b07f215c1c93b38220ecd2cf5a3dc08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b07f215c1c93b38220ecd2cf5a3dc08"></a>
NumInputs(4).NumOutputs(1).SetDoc(R&quot;DOC( Smooth L1 Loss is a minor variation of Huber loss in which the <a class="el" href="structpoint.html">point</a> of transition between L2 loss and L1 loss is adjustable by a hyper-parameter beta L2 to L1 transition <a class="el" href="structpoint.html">point</a> <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of&#160;</td><td class="memItemRight" valign="bottom"><b>predictions</b> (at least 1D).&quot;) .Input( 1</td></tr>
<tr class="separator:a1b07f215c1c93b38220ecd2cf5a3dc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdd7dd674979b3b15852928bf4455a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bdd7dd674979b3b15852928bf4455a4"></a>
NumInputs(4).NumOutputs(1).SetDoc(R&quot;DOC( Smooth L1 Loss is a minor variation of Huber loss in which the <a class="el" href="structpoint.html">point</a> of transition between L2 loss and L1 loss is adjustable by a hyper-parameter beta L2 to L1 transition <a class="el" href="structpoint.html">point</a> <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of labels with the same shape as Y_hat&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2,&quot;alpha_in&quot;,&quot;<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of inside weights with the same shape as Y.&quot;).Input(3</td></tr>
<tr class="separator:a4bdd7dd674979b3b15852928bf4455a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0c7fe16d0f4660f0b89b0c9a3a1c82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b0c7fe16d0f4660f0b89b0c9a3a1c82"></a>
See SmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;Y&quot;,&quot;See SmoothL1Loss.&quot;).Input(2</td></tr>
<tr class="separator:a6b0c7fe16d0f4660f0b89b0c9a3a1c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76b8d308b1909504e25ae001acda79f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab76b8d308b1909504e25ae001acda79f"></a>
See SmoothL1Loss See SmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;alpha_out&quot;,&quot;See SmoothL1Loss.&quot;).Input(4</td></tr>
<tr class="separator:ab76b8d308b1909504e25ae001acda79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8e265edc8afdfd87ada051b95f3d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c8e265edc8afdfd87ada051b95f3d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SmoothL1Loss, <a class="el" href="classcaffe2_1_1_get_smooth_l1_loss_gradient.html">GetSmoothL1LossGradient</a>)</td></tr>
<tr class="separator:a96c8e265edc8afdfd87ada051b95f3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8209dbeb5bd8494ad5fc7bc77d1d6fa4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8209dbeb5bd8494ad5fc7bc77d1d6fa4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxFocalLoss, <a class="el" href="classcaffe2_1_1_softmax_focal_loss_op.html">SoftmaxFocalLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8209dbeb5bd8494ad5fc7bc77d1d6fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae7b9026c4e5f057324915f289f74ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ae7b9026c4e5f057324915f289f74ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxFocalLossGradient, <a class="el" href="classcaffe2_1_1_softmax_focal_loss_gradient_op.html">SoftmaxFocalLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4ae7b9026c4e5f057324915f289f74ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06416b98e998410ae88b3e58e15da987"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06416b98e998410ae88b3e58e15da987"></a>
where N is the number of elements in the H and W are the height and and where t is the&#160;</td><td class="memItemRight" valign="bottom"><b>target</b> (ground truth) class</td></tr>
<tr class="separator:a06416b98e998410ae88b3e58e15da987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f42bd20cf2f0601d922d6b6c27df93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5f42bd20cf2f0601d922d6b6c27df93"></a>
Focal Loss s gamma hyper parameter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_classes&quot;,&quot;(int) default 81; number of classes in each softmax group.&quot;).Input(0</td></tr>
<tr class="separator:ab5f42bd20cf2f0601d922d6b6c27df93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d32188bccdca5375000ac51a5ea590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d32188bccdca5375000ac51a5ea590"></a>
the loss is normalized by Scalar loss&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1,&quot;probabilities&quot;,&quot;4D tensor of softmax probabilities with shape (N, C, H, W), where &quot;&quot;C = num_anchors * num_classes, and softmax was applied to each of the &quot;&quot;num_anchors groups; within a group the num_classes values sum to 1.&quot;)</td></tr>
<tr class="separator:a56d32188bccdca5375000ac51a5ea590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1068532430dac02f7bf4ee392e2a97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c1068532430dac02f7bf4ee392e2a97"></a>
See SoftmaxFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;labels&quot;,&quot;See SoftmaxFocalLoss.&quot;).Input(2</td></tr>
<tr class="separator:a9c1068532430dac02f7bf4ee392e2a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48bbee1f4ef86a1a191137b2edb886f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af48bbee1f4ef86a1a191137b2edb886f"></a>
See SoftmaxFocalLoss See SoftmaxFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3,&quot;probabilities&quot;,&quot;Output 1 from SoftmaxFocalLoss; See SoftmaxFocalLoss.&quot;).Input(4</td></tr>
<tr class="separator:af48bbee1f4ef86a1a191137b2edb886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa556516d4f1ec44adf674465da942e39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa556516d4f1ec44adf674465da942e39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SoftmaxFocalLoss, <a class="el" href="classcaffe2_1_1_get_softmax_focal_loss_gradient.html">GetSoftmaxFocalLossGradient</a>)</td></tr>
<tr class="separator:aa556516d4f1ec44adf674465da942e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02525550680bda57f43686ffac7bb5fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02525550680bda57f43686ffac7bb5fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialNarrowAs, <a class="el" href="classcaffe2_1_1_spatial_narrow_as_op.html">SpatialNarrowAsOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a02525550680bda57f43686ffac7bb5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25cffca303af8aa788207effb65f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f25cffca303af8aa788207effb65f65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1_spatial_narrow_as_gradient.html">SpatialNarrowAsGradient</a>, <a class="el" href="classcaffe2_1_1_spatial_narrow_as_gradient_op.html">SpatialNarrowAsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1f25cffca303af8aa788207effb65f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a875b024a56c9029c750115ab7e63cc47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a875b024a56c9029c750115ab7e63cc47"></a>
or input of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N, H0, W0) or(N</td></tr>
<tr class="separator:a875b024a56c9029c750115ab7e63cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0561e19bf037dba5b0dd602b6147e614"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0561e19bf037dba5b0dd602b6147e614"></a>
or input of W0&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;B&quot;,&quot;3D or 4D input of shape (N, H1, W1) or (N, C, H1, W1), where H1 &lt;= H0 &quot;&quot;and W1 &lt;= W0.&quot;).Output(0</td></tr>
<tr class="separator:a0561e19bf037dba5b0dd602b6147e614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374f5ff364caef872440ce7b72f45895"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a374f5ff364caef872440ce7b72f45895"></a>
or input of W0 Sub window of A containing&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> (inclusive) and columns&quot; &quot;[0</td></tr>
<tr class="separator:a374f5ff364caef872440ce7b72f45895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4379bb119b45ac564166718748e059"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d4379bb119b45ac564166718748e059"></a>
or input of W0 Sub window of A containing&#160;</td><td class="memItemRight" valign="bottom"><b>W1</b> (inclusive).&quot;)</td></tr>
<tr class="separator:a9d4379bb119b45ac564166718748e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e9af7937fab61148cc79256e74e195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87e9af7937fab61148cc79256e74e195"></a>
See SpatialNarrowAs&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1,&quot;B&quot;,&quot;See SpatialNarrowAs.&quot;).Input(2</td></tr>
<tr class="separator:a87e9af7937fab61148cc79256e74e195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1325d2eecf85bdec3ea2a138e8aa3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc1325d2eecf85bdec3ea2a138e8aa3d"></a>
See SpatialNarrowAs Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>output</b> (C).&quot;) .Output( 0</td></tr>
<tr class="separator:abc1325d2eecf85bdec3ea2a138e8aa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fded5fcd6f114d80a798004c520d69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0fded5fcd6f114d80a798004c520d69"></a>
See SpatialNarrowAs Gradient of forward Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (A)&quot;)</td></tr>
<tr class="separator:af0fded5fcd6f114d80a798004c520d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f07e0e85ac4e367c22655a9692876d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0f07e0e85ac4e367c22655a9692876d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SpatialNarrowAs, <a class="el" href="classcaffe2_1_1_spatial_narrow_as_gradient.html">SpatialNarrowAsGradient</a>)</td></tr>
<tr class="separator:ad0f07e0e85ac4e367c22655a9692876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b1d0492fc29ef12ab7653b21032c7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7b1d0492fc29ef12ab7653b21032c7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UpsampleNearest, <a class="el" href="classcaffe2_1_1_upsample_nearest_op.html">UpsampleNearestOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab7b1d0492fc29ef12ab7653b21032c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ddd08c04881f2ab0e6390d2b3d1915"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ddd08c04881f2ab0e6390d2b3d1915"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UpsampleNearestGradient, <a class="el" href="classcaffe2_1_1_upsample_nearest_gradient_op.html">UpsampleNearestGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae6ddd08c04881f2ab0e6390d2b3d1915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd87a334413c7660b34b49aa3c9dd70f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd87a334413c7660b34b49aa3c9dd70f"></a>
integer upsampling factor feature map of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (N, C, scale *H, scale *W)</td></tr>
<tr class="separator:abd87a334413c7660b34b49aa3c9dd70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd96258d2158fdf204c238356cc0efe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cd96258d2158fdf204c238356cc0efe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (UpsampleNearest, <a class="el" href="classcaffe2_1_1_get_upsample_nearest_gradient.html">GetUpsampleNearestGradient</a>)</td></tr>
<tr class="separator:a9cd96258d2158fdf204c238356cc0efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063a225139b51b5c3201af38cd13227"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8063a225139b51b5c3201af38cd13227"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Caffe2ModuleTestDynamicDummy, <a class="el" href="classcaffe2_1_1_caffe2_module_test_dynamic_dummy_op.html">Caffe2ModuleTestDynamicDummyOp</a>)</td></tr>
<tr class="separator:a8063a225139b51b5c3201af38cd13227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0282f7845ed6da9bc1aa5c7020ec891d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0282f7845ed6da9bc1aa5c7020ec891d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Caffe2ModuleTestDynamicDummy)</td></tr>
<tr class="separator:a0282f7845ed6da9bc1aa5c7020ec891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07c22a1f2bc05bde33f61de608d9797"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad07c22a1f2bc05bde33f61de608d9797"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CAFFE2_EARLY_INIT_FUNCTION</b> (registerGlobalPerfNetObserverReporter,&amp;registerGlobalPerfNetObserverReporter,&quot;Caffe2 print net observer reporter&quot;)</td></tr>
<tr class="separator:ad07c22a1f2bc05bde33f61de608d9797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8393f86fde8654be20e31a8cf1518bc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8393f86fde8654be20e31a8cf1518bc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CAFFE2_EARLY_INIT_FUNCTION</b> (registerGlobalPerfNetObserverCreator,&amp;registerGlobalPerfNetObserverCreator,&quot;Caffe2 net global observer creator&quot;)</td></tr>
<tr class="separator:a8393f86fde8654be20e31a8cf1518bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05774c4bb6d041d0e1239c8ed4ead519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05774c4bb6d041d0e1239c8ed4ead519"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE2_MODULE</b> (caffe2_rocksdb,&quot;RocksDB implementation for caffe2::DB.&quot;)</td></tr>
<tr class="separator:a05774c4bb6d041d0e1239c8ed4ead519"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aada76412edcca7a9bada88b46160ecbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aada76412edcca7a9bada88b46160ecbe"></a>
DoRunWithOtherType2 typedef <a class="el" href="classcaffe2_1_1_registry.html">Registry</a>&lt; std::string, std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1_operator_base.html">OperatorBase</a> &gt;, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorRegistry</b></td></tr>
<tr class="separator:aada76412edcca7a9bada88b46160ecbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0319f6f160afcb5114d1df3a04634c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0319f6f160afcb5114d1df3a04634c3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFARSize</b> = 32</td></tr>
<tr class="separator:ad0319f6f160afcb5114d1df3a04634c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5f94b53611e57244dafb85926cc9c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c5f94b53611e57244dafb85926cc9c2"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFARImageNBytes</b> = kCIFARSize * kCIFARSize * 3</td></tr>
<tr class="separator:a5c5f94b53611e57244dafb85926cc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede5fd30af8dddc4d3f43207260b26ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede5fd30af8dddc4d3f43207260b26ec"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10BatchSize</b> = 10000</td></tr>
<tr class="separator:aede5fd30af8dddc4d3f43207260b26ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05867c998628fbf970478572f32a462"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af05867c998628fbf970478572f32a462"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10TestDataSize</b> = 10000</td></tr>
<tr class="separator:af05867c998628fbf970478572f32a462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb02b581f40e6c2107cff354f93b46d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6eb02b581f40e6c2107cff354f93b46d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10TrainBatches</b> = 5</td></tr>
<tr class="separator:a6eb02b581f40e6c2107cff354f93b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee608401867021e057c71576582c2eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acee608401867021e057c71576582c2eb"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR100TrainDataSize</b> = 50000</td></tr>
<tr class="separator:acee608401867021e057c71576582c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b349deb32a7b5137e31d6297c6f28c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b349deb32a7b5137e31d6297c6f28c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR100TestDataSize</b> = 10000</td></tr>
<tr class="separator:a86b349deb32a7b5137e31d6297c6f28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae4e9ce61bc9036cb9adaf4842095cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae4e9ce61bc9036cb9adaf4842095cc"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>gCaffe2Alignment</b> = 32</td></tr>
<tr class="separator:a7ae4e9ce61bc9036cb9adaf4842095cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17803cefcc839e9256e5bf815f5d71b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17803cefcc839e9256e5bf815f5d71b4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kTensorBlobType</b> = &quot;Tensor&quot;</td></tr>
<tr class="separator:a17803cefcc839e9256e5bf815f5d71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cd3212f419650a9034f155fdea6298"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3cd3212f419650a9034f155fdea6298"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kChunkIdSeparator</b> = &quot;#%&quot;</td></tr>
<tr class="separator:ac3cd3212f419650a9034f155fdea6298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c01cfb9873b89810de07f3d09023c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad56c01cfb9873b89810de07f3d09023c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultChunkSize</b> = -1</td></tr>
<tr class="separator:ad56c01cfb9873b89810de07f3d09023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1900bca08da42b6be306f413ccd2182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1900bca08da42b6be306f413ccd2182"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kNoChunking</b> = 0</td></tr>
<tr class="separator:ad1900bca08da42b6be306f413ccd2182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dd5d4fba7c9642de6fc45c88f84b16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3dd5d4fba7c9642de6fc45c88f84b16"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>g_caffe2_has_cuda_linked</b> {false}</td></tr>
<tr class="separator:ab3dd5d4fba7c9642de6fc45c88f84b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016b982f98fda42e3e49f9553ad75231"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a016b982f98fda42e3e49f9553ad75231"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_CUDA_NUM_THREADS</b> = 512</td></tr>
<tr class="separator:a016b982f98fda42e3e49f9553ad75231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fa97d7f04b319de6c9fe8ef11b8b6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27fa97d7f04b319de6c9fe8ef11b8b6b"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_MAXIMUM_NUM_BLOCKS</b> = 4096</td></tr>
<tr class="separator:a27fa97d7f04b319de6c9fe8ef11b8b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeeef5246d6c9fc520df422e59c93b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdeeef5246d6c9fc520df422e59c93b5"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxDeviceTypes</b> = DeviceType::COMPILE_TIME_MAX_DEVICE_TYPES</td></tr>
<tr class="separator:abdeeef5246d6c9fc520df422e59c93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2169ccbd47ef3a2c06f65f7405e8e0e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2169ccbd47ef3a2c06f65f7405e8e0e6"></a>
std::function&lt; void(const OperatorDef &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOperatorLogger</b> ()</td></tr>
<tr class="separator:a2169ccbd47ef3a2c06f65f7405e8e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f308b1e218da746bab941419af4f6bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f308b1e218da746bab941419af4f6bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DoRunWithType2</b></td></tr>
<tr class="separator:a1f308b1e218da746bab941419af4f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f0010e56a40c6f4c187301bcf8e226"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2f0010e56a40c6f4c187301bcf8e226"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kCannotComputeNumOutputs</b> = -1</td></tr>
<tr class="separator:ae2f0010e56a40c6f4c187301bcf8e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabea76bd2be0a4ea36a880f7c77d5cba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabea76bd2be0a4ea36a880f7c77d5cba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kQTensorBlobQType</b> = &quot;QTensor&quot;</td></tr>
<tr class="separator:aabea76bd2be0a4ea36a880f7c77d5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9be0984306127d39c1a342c501ba83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec9be0984306127d39c1a342c501ba83"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>k_limit_default_</b> = 1000</td></tr>
<tr class="separator:aec9be0984306127d39c1a342c501ba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f24af9685c1a56565b38f11dcf27978"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f24af9685c1a56565b38f11dcf27978"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>float16</b></td></tr>
<tr class="separator:a4f24af9685c1a56565b38f11dcf27978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3127d3b8cfbde2f82b33d431e57c95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac3127d3b8cfbde2f82b33d431e57c95"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kBlobName</b> = &quot;blob_name&quot;</td></tr>
<tr class="separator:aac3127d3b8cfbde2f82b33d431e57c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c220ef38476c32d4208f2f45381313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c220ef38476c32d4208f2f45381313"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kAddValue</b> = &quot;add_value&quot;</td></tr>
<tr class="separator:ae1c220ef38476c32d4208f2f45381313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abe48ef568bf9479aab89ad5f253c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01abe48ef568bf9479aab89ad5f253c3"></a>
alternative key for the&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:a01abe48ef568bf9479aab89ad5f253c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534d618b697f29dbf3d1c2509f5c1309"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a534d618b697f29dbf3d1c2509f5c1309"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b></td></tr>
<tr class="separator:a534d618b697f29dbf3d1c2509f5c1309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569493bf1694a2e38495aac43789e98e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a569493bf1694a2e38495aac43789e98e"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop&#160;</td><td class="memItemRight" valign="bottom"><b>If</b></td></tr>
<tr class="separator:a569493bf1694a2e38495aac43789e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729c70f1add83aa27927992bb56ec1f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a729c70f1add83aa27927992bb56ec1f2"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop both dimensions of the image will be set to minsize or&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b></td></tr>
<tr class="separator:a729c70f1add83aa27927992bb56ec1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54f0e1dbdc5437a9af73ac9c29304bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af54f0e1dbdc5437a9af73ac9c29304bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>otherwise</b></td></tr>
<tr class="separator:af54f0e1dbdc5437a9af73ac9c29304bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8729390024d322768e469410ead75913"><td class="memItemLeft" align="right" valign="top">the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to[-1,-1] or no random resize desired&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a8729390024d322768e469410ead75913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d11ec5d2724f1b8087ed84933b65b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8d11ec5d2724f1b8087ed84933b65b"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to[-1,-1] or no random resize desired <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> containing the images additional&#160;</td><td class="memItemRight" valign="bottom"><b>outputs</b></td></tr>
<tr class="separator:a4b8d11ec5d2724f1b8087ed84933b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e25dec086376cc33e6a0f4199c96d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42e25dec086376cc33e6a0f4199c96d1"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to[-1,-1] or no random resize desired <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> containing the images additional Any outputs after the first will be Tensors read from the input&#160;</td><td class="memItemRight" valign="bottom"><b>TensorProtos</b></td></tr>
<tr class="separator:a42e25dec086376cc33e6a0f4199c96d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9343f2b93099fd08c702c02ca9a67067"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9343f2b93099fd08c702c02ca9a67067"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>snpe_ffi_so</b> = &quot;libsnpe_ffi.so&quot;</td></tr>
<tr class="separator:a9343f2b93099fd08c702c02ca9a67067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f26c8e49cc5d96b7dc00e5389c436f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f26c8e49cc5d96b7dc00e5389c436f0"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>k2b1bXBits</b> = 2</td></tr>
<tr class="separator:a7f26c8e49cc5d96b7dc00e5389c436f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c357882dcf28f5100862bb0c47bb11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c357882dcf28f5100862bb0c47bb11"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kL1CacheSizeBytes</b> = 16 * 1024</td></tr>
<tr class="separator:a95c357882dcf28f5100862bb0c47bb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c192414204207a8fbe65cc25a53bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a675c192414204207a8fbe65cc25a53bb"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMTileSize</b> = 64</td></tr>
<tr class="separator:a675c192414204207a8fbe65cc25a53bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec79aadd2f986b41f0e9e1eaf3c4ec96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec79aadd2f986b41f0e9e1eaf3c4ec96"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMTileDepthBytes</b> = 16</td></tr>
<tr class="separator:aec79aadd2f986b41f0e9e1eaf3c4ec96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874a9ae2d0b766057b51924dd6afc7ad"><td class="memItemLeft" align="right" valign="top">element wise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>output</b></td></tr>
<tr class="separator:a874a9ae2d0b766057b51924dd6afc7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3bc12ac0ef15877db474d92746fcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8cf3bc12ac0ef15877db474d92746fcf"></a>
element wise DOC The absolute value of the input tensor computed element&#160;</td><td class="memItemRight" valign="bottom"><b>wise</b></td></tr>
<tr class="separator:a8cf3bc12ac0ef15877db474d92746fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e5e712c84972a4ee6363f01b4dbd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae33e5e712c84972a4ee6363f01b4dbd8"></a>
we add to&#160;</td><td class="memItemRight" valign="bottom"><b>it</b></td></tr>
<tr class="separator:ae33e5e712c84972a4ee6363f01b4dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bb1ecfdbe7cf126c0dda627e6a64a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa60bb1ecfdbe7cf126c0dda627e6a64a"></a>
we first initialize the output tensor to all&#160;</td><td class="memItemRight" valign="bottom"><b>zeros</b></td></tr>
<tr class="separator:aa60bb1ecfdbe7cf126c0dda627e6a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31b459803870398792f0d1fbcf40451"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa31b459803870398792f0d1fbcf40451"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the&#160;</td><td class="memItemRight" valign="bottom"><b>input</b></td></tr>
<tr class="separator:aa31b459803870398792f0d1fbcf40451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a00fe1ad689b92d705d3c388305c10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6a00fe1ad689b92d705d3c388305c10"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> = 1</td></tr>
<tr class="separator:ae6a00fe1ad689b92d705d3c388305c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba29b97f6823d9ed5883d821873234e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ba29b97f6823d9ed5883d821873234e"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to&#160;</td><td class="memItemRight" valign="bottom"><b>zero</b></td></tr>
<tr class="separator:a5ba29b97f6823d9ed5883d821873234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76ef55e49cc26412c5c8d03a357a38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c76ef55e49cc26412c5c8d03a357a38"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to and only&#160;</td><td class="memItemRight" valign="bottom"><b>then</b></td></tr>
<tr class="separator:a5c76ef55e49cc26412c5c8d03a357a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a323067eaaeed246ded875e236e7044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a323067eaaeed246ded875e236e7044"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ints</b></td></tr>
<tr class="separator:a9a323067eaaeed246ded875e236e7044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d98876427d4557667979998e7df90a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60d98876427d4557667979998e7df90a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>longs</b></td></tr>
<tr class="separator:a60d98876427d4557667979998e7df90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4010e0a5486f263b21fbb30c8d3f14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a4010e0a5486f263b21fbb30c8d3f14"></a>
or long longs and checks if all values are true when coerced into a boolean In other&#160;</td><td class="memItemRight" valign="bottom"><b>words</b></td></tr>
<tr class="separator:a9a4010e0a5486f263b21fbb30c8d3f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20361269928187b6a5625204805051"><td class="memItemLeft" align="right" valign="top">const vector&lt; TensorShape &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:a6e20361269928187b6a5625204805051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361340ae951d832bd229b551db6d686c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a361340ae951d832bd229b551db6d686c"></a>
<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>helper</b> (def)</td></tr>
<tr class="separator:a361340ae951d832bd229b551db6d686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91681eb0a87ce99272cd3d0f1116c19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91681eb0a87ce99272cd3d0f1116c19"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>output_dims</b></td></tr>
<tr class="separator:af91681eb0a87ce99272cd3d0f1116c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba257bf31ceca956d71205df79f53c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33ba257bf31ceca956d71205df79f53c"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data_dims</b> = GetDimsVector(in[0])</td></tr>
<tr class="separator:a33ba257bf31ceca956d71205df79f53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad960afee248a027651483f33a368ec46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad960afee248a027651483f33a368ec46"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>indices_dims</b> = GetDimsVector(in[1])</td></tr>
<tr class="separator:ad960afee248a027651483f33a368ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48262a78819cac51ddd04a6d020a0baa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48262a78819cac51ddd04a6d020a0baa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> [0] = CreateTensorShape(output_dims, TensorProto::FLOAT)</td></tr>
<tr class="separator:a48262a78819cac51ddd04a6d020a0baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f75701e2593a04b1e285366a5965a48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f75701e2593a04b1e285366a5965a48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DATA</b></td></tr>
<tr class="separator:a8f75701e2593a04b1e285366a5965a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04e8baeca5dcb4f675a99f815264363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of rank&#160;</td><td class="memItemRight" valign="bottom"><b>r</b></td></tr>
<tr class="separator:af04e8baeca5dcb4f675a99f815264363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183f77fabf70f4a3888a396b1c722248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a183f77fabf70f4a3888a396b1c722248"></a>
indices&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b></td></tr>
<tr class="separator:a183f77fabf70f4a3888a396b1c722248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d66c92e7159ad7563d50297971887"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac0d66c92e7159ad7563d50297971887"></a>
indices and values vector Each element in lengths indices should not have duplicate number For&#160;</td><td class="memItemRight" valign="bottom"><b>example</b></td></tr>
<tr class="separator:aac0d66c92e7159ad7563d50297971887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659684f47d7140896b4567e6c1527ee2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a659684f47d7140896b4567e6c1527ee2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>The</b></td></tr>
<tr class="separator:a659684f47d7140896b4567e6c1527ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548e3b7972c57f8116fc4e0149b256a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1548e3b7972c57f8116fc4e0149b256a"></a>
original data tensor&#160;</td><td class="memItemRight" valign="bottom"><b>masked_data</b></td></tr>
<tr class="separator:a1548e3b7972c57f8116fc4e0149b256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8c3114e2c624ebe45f009a56af4fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b8c3114e2c624ebe45f009a56af4fc"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC&#160;</td><td class="memItemRight" valign="bottom"><b>mask</b></td></tr>
<tr class="separator:ab2b8c3114e2c624ebe45f009a56af4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af414c251ce4da8ff38f5355a092635e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af414c251ce4da8ff38f5355a092635e1"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>minf</b> = -1.0f * std::numeric_limits&lt;float&gt;::infinity()</td></tr>
<tr class="separator:af414c251ce4da8ff38f5355a092635e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afe873d9d7b23e7c40cf97f1136366b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3afe873d9d7b23e7c40cf97f1136366b"></a>
reconstruct values together according to masks A comprehensive&#160;</td><td class="memItemRight" valign="bottom"><b>False</b></td></tr>
<tr class="separator:a3afe873d9d7b23e7c40cf97f1136366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c1b5f26f85c316d813e2b572f889c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11c1b5f26f85c316d813e2b572f889c1"></a>
reconstruct values together according to masks A comprehensive&#160;</td><td class="memItemRight" valign="bottom"><b>True</b></td></tr>
<tr class="separator:a11c1b5f26f85c316d813e2b572f889c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ebbb5a439f3f1214bdd28a6b1c69c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa68ebbb5a439f3f1214bdd28a6b1c69c"></a>
reconstruct values together according to masks A comprehensive False&#160;</td><td class="memItemRight" valign="bottom"><b>values1</b> = 1.0</td></tr>
<tr class="separator:aa68ebbb5a439f3f1214bdd28a6b1c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce822052940b564fe8a18b36043a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1ce822052940b564fe8a18b36043a46"></a>
reconstruct values together according to masks A comprehensive False&#160;</td><td class="memItemRight" valign="bottom"><b>mask2</b> = False</td></tr>
<tr class="separator:ad1ce822052940b564fe8a18b36043a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6bf36770de6197a0500da244b4d49f"><td class="memItemLeft" align="right" valign="top">reconstruct values together according to masks A comprehensive False False&#160;</td><td class="memItemRight" valign="bottom"><b>values2</b></td></tr>
<tr class="separator:acc6bf36770de6197a0500da244b4d49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8243c546a33a687ac9b0b5065c40b7c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8243c546a33a687ac9b0b5065c40b7c9"></a>
reconstruct values together according to masks A comprehensive False False True&#160;</td><td class="memItemRight" valign="bottom"><b>values3</b> = 4.0</td></tr>
<tr class="separator:a8243c546a33a687ac9b0b5065c40b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f58537928e93ce4dea86b12e17980d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f58537928e93ce4dea86b12e17980d"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct&#160;</td><td class="memItemRight" valign="bottom"><b>by</b></td></tr>
<tr class="separator:ad3f58537928e93ce4dea86b12e17980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518699eb3c6de62fc0804d8bf4d35ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3518699eb3c6de62fc0804d8bf4d35ab"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct&#160;</td><td class="memItemRight" valign="bottom"><b>mask3</b></td></tr>
<tr class="separator:a3518699eb3c6de62fc0804d8bf4d35ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2209e73667e5137d0f648c9284112b80"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2209e73667e5137d0f648c9284112b80"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We&#160;</td><td class="memItemRight" valign="bottom"><b>get</b></td></tr>
<tr class="separator:a2209e73667e5137d0f648c9284112b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87846d407e440c05437cc708f53d3b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87846d407e440c05437cc708f53d3b53"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask&#160;</td><td class="memItemRight" valign="bottom"><b>positions</b></td></tr>
<tr class="separator:a87846d407e440c05437cc708f53d3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0ce75f8c358e9bb0b277d149c530f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2df0ce75f8c358e9bb0b277d149c530f"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True&#160;</td><td class="memItemRight" valign="bottom"><b>s</b></td></tr>
<tr class="separator:a2df0ce75f8c358e9bb0b277d149c530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5205e5927822adb8687a095d5b80dc40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5205e5927822adb8687a095d5b80dc40"></a>
The data type to which the elements of the input tensor are cast Strictly must be one of the types from DataType enum in TensorProto Output tensor with the same shape as input with type specified by the to&#160;</td><td class="memItemRight" valign="bottom"><b>argument</b></td></tr>
<tr class="separator:a5205e5927822adb8687a095d5b80dc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8760abd825f0c98fc16dae30030eb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b8760abd825f0c98fc16dae30030eb3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>X</b> = in[0]</td></tr>
<tr class="separator:a9b8760abd825f0c98fc16dae30030eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc83acec950979e55215b3ead8ff3c93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc83acec950979e55215b3ead8ff3c93"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation&#160;</td><td class="memItemRight" valign="bottom"><b>Typically</b></td></tr>
<tr class="separator:afc83acec950979e55215b3ead8ff3c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7ee5ca45d083c80de818b3b666a25e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa7ee5ca45d083c80de818b3b666a25e"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC&#160;</td><td class="memItemRight" valign="bottom"><b>mean</b></td></tr>
<tr class="separator:afa7ee5ca45d083c80de818b3b666a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f6a72d88af45a62ebade1938f893bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13f6a72d88af45a62ebade1938f893bc"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC The mean saved from the forward pass as a dimensional tensor of size C&#160;</td><td class="memItemRight" valign="bottom"><b>output_grad</b></td></tr>
<tr class="separator:a13f6a72d88af45a62ebade1938f893bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd996a69d304ea7be28941b23e9b9228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd996a69d304ea7be28941b23e9b9228"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC The mean saved from the forward pass as a dimensional tensor of size C Gradient for the output layer of&#160;</td><td class="memItemRight" valign="bottom"><b>SpatialBN</b></td></tr>
<tr class="separator:afd996a69d304ea7be28941b23e9b9228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5b30a4606edd5458f6676a4067b86c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f5b30a4606edd5458f6676a4067b86c"></a>
the gradient for the output of SpatialBN and the per channel mean and inverse std var vectors for the computes the per channel bias and scale gradient to be used during the backward pass for subsequent spatial batch normalization gradient calculation the results of this op are subsequently reduced over multiple devices to obtain statistics over a larger batch size in cases where the batch size for a single model copy is too low to yield the full benefit of batch normalization The resulting bias and scale can then be plugged back into SpatialBNGradient to get results over the larger batch size DOC The mean saved from the forward pass as a dimensional tensor of size C Gradient for the output layer of here used as input because we are on the backward pass&#160;</td><td class="memItemRight" valign="bottom"><b>bias_grad</b></td></tr>
<tr class="separator:a6f5b30a4606edd5458f6676a4067b86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98688e03bca94af1143033ef9a62d245"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98688e03bca94af1143033ef9a62d245"></a>
computes the sum of all elements per channel and the sum of all elements squared per channel These values can be reduced across multiple batches and used to obtain the mean and variance across the full set of batches Using the new mean and variance as input to SpatialBN has the effect of changing the batch size over which SpatialBN is applied DOC&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b></td></tr>
<tr class="separator:a98688e03bca94af1143033ef9a62d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2069850bb2c06fd98dd2142a18e0441"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2069850bb2c06fd98dd2142a18e0441"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kv_handler</b></td></tr>
<tr class="separator:ac2069850bb2c06fd98dd2142a18e0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e00679abaa908d00e7c8fc71e0499cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e00679abaa908d00e7c8fc71e0499cf"></a>
Key value handler for&#160;</td><td class="memItemRight" valign="bottom"><b>comm_world</b></td></tr>
<tr class="separator:a2e00679abaa908d00e7c8fc71e0499cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9c1871d705fa9e8aa558644f102386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae9c1871d705fa9e8aa558644f102386"></a>
Key value handler for A common world for collective operations int rank of this node in the common&#160;</td><td class="memItemRight" valign="bottom"><b>world</b></td></tr>
<tr class="separator:aae9c1871d705fa9e8aa558644f102386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20774c05b863ca8fbda1b27507e18d11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20774c05b863ca8fbda1b27507e18d11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>existing_comm_world</b></td></tr>
<tr class="separator:a20774c05b863ca8fbda1b27507e18d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4131b6de924c49ed98ffacf3f4e387b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4131b6de924c49ed98ffacf3f4e387b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>common_world</b></td></tr>
<tr class="separator:ae4131b6de924c49ed98ffacf3f4e387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95bc248f963a13dfcca20bd71e88995"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95bc248f963a13dfcca20bd71e88995"></a>
The common world to be&#160;</td><td class="memItemRight" valign="bottom"><b>destroyed</b></td></tr>
<tr class="separator:ae95bc248f963a13dfcca20bd71e88995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726982682691269ef900b03784b3431f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a726982682691269ef900b03784b3431f"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b></td></tr>
<tr class="separator:a726982682691269ef900b03784b3431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a34562d580125c148133482def750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af22a34562d580125c148133482def750"></a>
The common world The reduced result on&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:af22a34562d580125c148133482def750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967ffe373d585be2dbbe1d6e64cb60ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a967ffe373d585be2dbbe1d6e64cb60ab"></a>
The common world The allreduced&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b></td></tr>
<tr class="separator:a967ffe373d585be2dbbe1d6e64cb60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977aabc758f9d7a2b65c796fbf433d83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a977aabc758f9d7a2b65c796fbf433d83"></a>
The common world The allreduced same on all&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:a977aabc758f9d7a2b65c796fbf433d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24fa41c4f9a7caf2045720dec1ab894"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad24fa41c4f9a7caf2045720dec1ab894"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>dst</b></td></tr>
<tr class="separator:ad24fa41c4f9a7caf2045720dec1ab894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4100b31fea680091fc72ee3c63a3356"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4100b31fea680091fc72ee3c63a3356"></a>
The common world An int CPUtensor of size specifying the rank If&#160;</td><td class="memItemRight" valign="bottom"><b>given</b></td></tr>
<tr class="separator:aa4100b31fea680091fc72ee3c63a3356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec0c3ada1f730fc97a3fd46174cc53f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ec0c3ada1f730fc97a3fd46174cc53f"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to bool if&#160;</td><td class="memItemRight" valign="bottom"><b>set</b></td></tr>
<tr class="separator:a9ec0c3ada1f730fc97a3fd46174cc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca87e17a9274257b1f0cc98eacdf2a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ca87e17a9274257b1f0cc98eacdf2a0"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to bool if only send the content and assume that the receiver has already known the tensor s shape and&#160;</td><td class="memItemRight" valign="bottom"><b>information</b></td></tr>
<tr class="separator:a6ca87e17a9274257b1f0cc98eacdf2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6d7036f64365eb3a654735bc5f1b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8b6d7036f64365eb3a654735bc5f1b2"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>src</b></td></tr>
<tr class="separator:ad8b6d7036f64365eb3a654735bc5f1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1641229ee1edeff1d9d378be9dceb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d1641229ee1edeff1d9d378be9dceb4"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor&#160;</td><td class="memItemRight" valign="bottom"><b>tag</b></td></tr>
<tr class="separator:a9d1641229ee1edeff1d9d378be9dceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e0de90e4aae812c0feab58d2baad3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89e0de90e4aae812c0feab58d2baad3e"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>split</b></td></tr>
<tr class="separator:a89e0de90e4aae812c0feab58d2baad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ab2114a9dbe0a8349c0149288a14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a538ab2114a9dbe0a8349c0149288a14e"></a>
INT_MAX Optional list of output Which axis to split on Either NHWC or&#160;</td><td class="memItemRight" valign="bottom"><b>NCWH</b></td></tr>
<tr class="separator:a538ab2114a9dbe0a8349c0149288a14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e450c246510c64c62fefbe3af76c7"><td class="memItemLeft" align="right" valign="top">INT_MAX Optional list of output Which axis to split on Either NHWC or will split on C&#160;</td><td class="memItemRight" valign="bottom"><b>axis</b></td></tr>
<tr class="separator:a544e450c246510c64c62fefbe3af76c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c31e73fdb2e293a08bfcc8e29688c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25c31e73fdb2e293a08bfcc8e29688c6"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors&#160;</td><td class="memItemRight" valign="bottom"><b>concat_result</b></td></tr>
<tr class="separator:a25c31e73fdb2e293a08bfcc8e29688c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489286b5b37e795f5465cdf33c71233"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0489286b5b37e795f5465cdf33c71233"></a>
apply conditional&#160;</td><td class="memItemRight" valign="bottom"><b>DataT</b></td></tr>
<tr class="separator:a0489286b5b37e795f5465cdf33c71233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07ea3a223f8cadbeae2e6e1c7bc43d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad07ea3a223f8cadbeae2e6e1c7bc43d7"></a>
apply conditional Data to use when True&#160;</td><td class="memItemRight" valign="bottom"><b>DataO</b></td></tr>
<tr class="separator:ad07ea3a223f8cadbeae2e6e1c7bc43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bd36f7f7391084aa8952ec062fb56c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39bd36f7f7391084aa8952ec062fb56c"></a>
apply conditional Data to use when True Output data after applying&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionalOp</b></td></tr>
<tr class="separator:a39bd36f7f7391084aa8952ec062fb56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c2938a533274cb9b74a72e0428d419"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kConvDoc</b></td></tr>
<tr class="separator:ab5c2938a533274cb9b74a72e0428d419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fabd51d8e2bb1be34162923e8452749"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fabd51d8e2bb1be34162923e8452749"></a>
the filter&#160;</td><td class="memItemRight" valign="bottom"><b>blob</b></td></tr>
<tr class="separator:a7fabd51d8e2bb1be34162923e8452749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039d1b6280ba35e31510fa7343ee2b0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a039d1b6280ba35e31510fa7343ee2b0f"></a>
the filter and the bias and computes the output Note that other&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b></td></tr>
<tr class="separator:a039d1b6280ba35e31510fa7343ee2b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27cf8af7c4d0382ce71520246f4f67d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27cf8af7c4d0382ce71520246f4f67d8"></a>
the filter and the bias and computes the output Note that other such as the stride and kernel or the pads sizes in each direction are not necessary for input because they are provided by the ConvTransposeUnpoolOpBase&#160;</td><td class="memItemRight" valign="bottom"><b>operator.Various dimension checks are done
implicitly, and the sizes are specified in the Input docs for this operator.As is expected, the filter is deconvolved with a subset of the
image and the bias is added</b></td></tr>
<tr class="separator:a27cf8af7c4d0382ce71520246f4f67d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef7c7e01c62304c3bf69c8a3e290385"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afef7c7e01c62304c3bf69c8a3e290385"></a>
this is done throughout the image data and the output is computed As a side note on the implementation&#160;</td><td class="memItemRight" valign="bottom"><b>layout</b></td></tr>
<tr class="separator:afef7c7e01c62304c3bf69c8a3e290385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbb26e87550ec50e4874868f1df0ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adabbb26e87550ec50e4874868f1df0ff"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b></td></tr>
<tr class="separator:adabbb26e87550ec50e4874868f1df0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f42b96e01292b15ad28c02bd1adb4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe1f42b96e01292b15ad28c02bd1adb4"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC The filter blob that will be used in the transposed&#160;</td><td class="memItemRight" valign="bottom"><b>convolution</b></td></tr>
<tr class="separator:abe1f42b96e01292b15ad28c02bd1adb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edac4bc4b850734ee3b31a10344c9b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2edac4bc4b850734ee3b31a10344c9b4"></a>
has where C is the number of&#160;</td><td class="memItemRight" valign="bottom"><b>channels</b></td></tr>
<tr class="separator:a2edac4bc4b850734ee3b31a10344c9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e3171d9002bb911dc07c92fe849f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad88e3171d9002bb911dc07c92fe849f7"></a>
has where C is the number of and kH and kW are the height and width of the kernel Output data blob that contains the result of the transposed convolution The output dimensions are functions of the kernel stride and pad&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b></td></tr>
<tr class="separator:ad88e3171d9002bb911dc07c92fe849f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7026acab05a17cb8d768dae95f0434aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7026acab05a17cb8d768dae95f0434aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>counter</b></td></tr>
<tr class="separator:a7026acab05a17cb8d768dae95f0434aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dc6109c91a09d40376248cf2286018"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0dc6109c91a09d40376248cf2286018"></a>
A blob pointing to an instance of a new counter Resets counter to this&#160;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr class="separator:ae0dc6109c91a09d40376248cf2286018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af100b41879760c73a0a8e5984d2bd253"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af100b41879760c73a0a8e5984d2bd253"></a>
Input blob from the previous&#160;</td><td class="memItemRight" valign="bottom"><b>layer</b></td></tr>
<tr class="separator:af100b41879760c73a0a8e5984d2bd253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e55d9b0e6c5dbac2d4b8001322931ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e55d9b0e6c5dbac2d4b8001322931ab"></a>
Input blob from the previous which is almost always the result of a softmax&#160;</td><td class="memItemRight" valign="bottom"><b>operation</b></td></tr>
<tr class="separator:a1e55d9b0e6c5dbac2d4b8001322931ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd3b602fcb3c68be16ff7ca400d623"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94bd3b602fcb3c68be16ff7ca400d623"></a>
X is a array of size N x&#160;</td><td class="memItemRight" valign="bottom"><b>D</b></td></tr>
<tr class="separator:a94bd3b602fcb3c68be16ff7ca400d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6cb10710fc184e6cc616caf6182d66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a6cb10710fc184e6cc616caf6182d66"></a>
X is a array of size N x where N is the batch size and D is the number of classes Output blob after the cross entropy&#160;</td><td class="memItemRight" valign="bottom"><b>computation</b></td></tr>
<tr class="separator:a8a6cb10710fc184e6cc616caf6182d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125bb08b4fb3ac367f25d56407945e71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a125bb08b4fb3ac367f25d56407945e71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>logits</b> = in[0]</td></tr>
<tr class="separator:a125bb08b4fb3ac367f25d56407945e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fe76d250f625cac01228c609b9754a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65fe76d250f625cac01228c609b9754a"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>xentropy</b></td></tr>
<tr class="separator:a65fe76d250f625cac01228c609b9754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26538ce8b849e2eb1d6f0639c681463c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26538ce8b849e2eb1d6f0639c681463c"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>weights</b></td></tr>
<tr class="separator:a26538ce8b849e2eb1d6f0639c681463c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e84d76cd6fb8c90b44f5fe5913183a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e84d76cd6fb8c90b44f5fe5913183a1"></a>
or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Z</b></td></tr>
<tr class="separator:a4e84d76cd6fb8c90b44f5fe5913183a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670980437aa26d14148d2e1d5aa3be04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a670980437aa26d14148d2e1d5aa3be04"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor whether to replicate the smaller tensor or&#160;</td><td class="memItemRight" valign="bottom"><b>not</b></td></tr>
<tr class="separator:a670980437aa26d14148d2e1d5aa3be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e10186bd5c4b61d0501819044b6119c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e10186bd5c4b61d0501819044b6119c"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace&#160;</td><td class="memItemRight" valign="bottom"><b>blobs</b></td></tr>
<tr class="separator:a0e10186bd5c4b61d0501819044b6119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2a34a424811068acf175bd0272749c"><td class="memItemLeft" align="right" valign="top">INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in&#160;</td><td class="memItemRight" valign="bottom"><b>order</b></td></tr>
<tr class="separator:afb2a34a424811068acf175bd0272749c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54367a931bcd1c6e3218ab2f9ad04d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea54367a931bcd1c6e3218ab2f9ad04d"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in List of blobs from the forward Do int out&#160;</td><td class="memItemRight" valign="bottom"><b>bool</b> { return true</td></tr>
<tr class="separator:aea54367a931bcd1c6e3218ab2f9ad04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65868e3ebf153459a7dc65217a7bad9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa65868e3ebf153459a7dc65217a7bad9"></a>
<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>argsHelper</b> (def)</td></tr>
<tr class="separator:aa65868e3ebf153459a7dc65217a7bad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a1d130dec2d7bc6056118f81cadb7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25a1d130dec2d7bc6056118f81cadb7f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>output_mask</b> = !argsHelper.GetSingleArgument&lt;bool&gt;(&quot;is_test&quot;, 0)</td></tr>
<tr class="separator:a25a1d130dec2d7bc6056118f81cadb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4727de445dabd71bb757e60ad9e2a4dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4727de445dabd71bb757e60ad9e2a4dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>float</b></td></tr>
<tr class="separator:a4727de445dabd71bb757e60ad9e2a4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80bf284e0ee2cc6952f973c6b5bdcdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac80bf284e0ee2cc6952f973c6b5bdcdc"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> The output mask If is_test is&#160;</td><td class="memItemRight" valign="bottom"><b>nonzero</b></td></tr>
<tr class="separator:ac80bf284e0ee2cc6952f973c6b5bdcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad514b4db7086e54d5fc79c7bf31ea19d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad514b4db7086e54d5fc79c7bf31ea19d"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> The output mask If is_test is this output is not&#160;</td><td class="memItemRight" valign="bottom"><b>filled</b></td></tr>
<tr class="separator:ad514b4db7086e54d5fc79c7bf31ea19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efa4ede07f3852f506f974ae6bc276b"><td class="memItemLeft" align="right" valign="top">describes the axis of the&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b></td></tr>
<tr class="separator:a0efa4ede07f3852f506f974ae6bc276b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addad4c4cf84d667f963d2f34365f3fd4"><td class="memItemLeft" align="right" valign="top">defaults to one because the axis most likely describes the&#160;</td><td class="memItemRight" valign="bottom"><b>batch_size</b></td></tr>
<tr class="separator:addad4c4cf84d667f963d2f34365f3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c33ee34c77cd3e3e16734e5991d87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kBroadcastDoc</b></td></tr>
<tr class="separator:a6e0c33ee34c77cd3e3e16734e5991d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e3d9c45a7261ea359c0626b47c447c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86e3d9c45a7261ea359c0626b47c447c"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are&#160;</td><td class="memItemRight" valign="bottom"><b>supported</b></td></tr>
<tr class="separator:a86e3d9c45a7261ea359c0626b47c447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf5560bbe932330ac819bb50ddc719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ccf5560bbe932330ac819bb50ddc719"></a>
element wise This operation can be done in an in place fashion&#160;</td><td class="memItemRight" valign="bottom"><b>too</b></td></tr>
<tr class="separator:a0ccf5560bbe932330ac819bb50ddc719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847845b7bab34c0ac034a003e75de96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3847845b7bab34c0ac034a003e75de96"></a>
the data type of value is used The output tensor shape is specified by the shape argument If the number of input&#160;</td><td class="memItemRight" valign="bottom"><b>is</b></td></tr>
<tr class="separator:a3847845b7bab34c0ac034a003e75de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe227faccd1ee13a1fc73cea53dcb7dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe227faccd1ee13a1fc73cea53dcb7dd"></a>
the data type of value is used The output tensor shape is specified by the shape argument If the number of input the shape will be identical to that of the input at run time with optional additional dimensions appended at the end as specified by extra_shape argument In that case the shape argument should not be set If input_as_shape is set to&#160;</td><td class="memItemRight" valign="bottom"><b>true</b></td></tr>
<tr class="separator:afe227faccd1ee13a1fc73cea53dcb7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb35f7b3bb97822c1fc4a1a54b21e10e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb35f7b3bb97822c1fc4a1a54b21e10e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> = 0</td></tr>
<tr class="separator:adb35f7b3bb97822c1fc4a1a54b21e10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48184f626f27c032d0422bf8cbf662b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48184f626f27c032d0422bf8cbf662b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>query</b></td></tr>
<tr class="separator:a48184f626f27c032d0422bf8cbf662b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766dbf71da6f0018a6008cce7b3a95ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a766dbf71da6f0018a6008cce7b3a95ea"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>outer</b> = 1</td></tr>
<tr class="separator:a766dbf71da6f0018a6008cce7b3a95ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c584df6cbb5d2a753947e77b45720"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae80c584df6cbb5d2a753947e77b45720"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>inner</b> = 1</td></tr>
<tr class="separator:ae80c584df6cbb5d2a753947e77b45720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c2d4fbe3b1b9e1602f2ec24fe135f"><td class="memItemLeft" align="right" valign="top">A tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>rank</b></td></tr>
<tr class="separator:a984c2d4fbe3b1b9e1602f2ec24fe135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac679d35523e8243c517adc2088d99f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac679d35523e8243c517adc2088d99f9f"></a>
and then scaling each element to an bit number between and To later de quantize&#160;</td><td class="memItemRight" valign="bottom"><b>values</b></td></tr>
<tr class="separator:ac679d35523e8243c517adc2088d99f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfddc6c3e9720eb694c857749deb64a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfddc6c3e9720eb694c857749deb64a2"></a>
followed by the bias as a bit float in the next&#160;</td><td class="memItemRight" valign="bottom"><b>bytes</b></td></tr>
<tr class="separator:abfddc6c3e9720eb694c857749deb64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaa1a8b69205d13e0eda1ec90db6569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdaa1a8b69205d13e0eda1ec90db6569"></a>
followed by the bias as a bit float in the next and the quantized values in the preceding bytes of the row The output is a matrix containing only the but de quantized De quantization is performed by multiplying each value by its row s scale and bias parameters The de quantized values will thus not be exactly equal to the&#160;</td><td class="memItemRight" valign="bottom"><b>original</b></td></tr>
<tr class="separator:acdaa1a8b69205d13e0eda1ec90db6569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b07879f028da4a9ae9d43ebe1d343"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb6b07879f028da4a9ae9d43ebe1d343"></a>
followed by the bias as a bit float in the next and the quantized values in the preceding bytes of the row The output is a matrix containing only the but de quantized De quantization is performed by multiplying each value by its row s scale and bias parameters The de quantized values will thus not be exactly equal to the un quantized floating <a class="el" href="structpoint.html">point</a> values DOC&#160;</td><td class="memItemRight" valign="bottom"><b>float_input</b></td></tr>
<tr class="separator:acb6b07879f028da4a9ae9d43ebe1d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d15ce97d784d0f058e0e4e8918a096b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d15ce97d784d0f058e0e4e8918a096b"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor with rank obtained with&#160;</td><td class="memItemRight" valign="bottom"><b>OUTPUT</b></td></tr>
<tr class="separator:a9d15ce97d784d0f058e0e4e8918a096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6983994631763a3136899aae48027a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f6983994631763a3136899aae48027a"></a>
in a sequence length aware fashion&#160;</td><td class="memItemRight" valign="bottom"><b>Concretely</b></td></tr>
<tr class="separator:a0f6983994631763a3136899aae48027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bbf8f3ec52ccd3913154c386b75a9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79bbf8f3ec52ccd3913154c386b75a9e"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU&#160;</td><td class="memItemRight" valign="bottom"><b>activations</b></td></tr>
<tr class="separator:a79bbf8f3ec52ccd3913154c386b75a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd7a0d505d35c0cdeceae6e72bbf668"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5dd7a0d505d35c0cdeceae6e72bbf668"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length&#160;</td><td class="memItemRight" valign="bottom"><b>hidden</b></td></tr>
<tr class="separator:a5dd7a0d505d35c0cdeceae6e72bbf668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c0ceac2d49bca5216c9907ac507867"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5c0ceac2d49bca5216c9907ac507867"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length The new GRU hidden state calculated by this&#160;</td><td class="memItemRight" valign="bottom"><b>op</b></td></tr>
<tr class="separator:aa5c0ceac2d49bca5216c9907ac507867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de84d17dee51f14a129bf538f6e5c95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de84d17dee51f14a129bf538f6e5c95"></a>
When&#160;</td><td class="memItemRight" valign="bottom"><b>false</b></td></tr>
<tr class="separator:a4de84d17dee51f14a129bf538f6e5c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe7a7bcf1a3cee70ba27814d3bd7ed7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfe7a7bcf1a3cee70ba27814d3bd7ed7"></a>
When the sequence lengths input is left and all following inputs are shifted left by&#160;</td><td class="memItemRight" valign="bottom"><b>one</b></td></tr>
<tr class="separator:abfe7a7bcf1a3cee70ba27814d3bd7ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75af76b9adf6d15343f3c87937d96132"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75af76b9adf6d15343f3c87937d96132"></a>
INT_MAX Net executed when condition is true&#160;</td><td class="memItemRight" valign="bottom"><b>condition</b></td></tr>
<tr class="separator:a75af76b9adf6d15343f3c87937d96132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3191fe8913602861ca2e39b0a67ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e3191fe8913602861ca2e39b0a67ed9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>pad</b> = helper.GetSingleArgument&lt;int&gt;(&quot;pad&quot;, 0)</td></tr>
<tr class="separator:a8e3191fe8913602861ca2e39b0a67ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9abe1c69fb306a265046144f3c385"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_h</b></td></tr>
<tr class="separator:ac2b9abe1c69fb306a265046144f3c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed860c253cc3623218f5e049f56807"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_w</b></td></tr>
<tr class="separator:aaaed860c253cc3623218f5e049f56807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813549291034e22b8c23512190e36e1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>dilation_h</b></td></tr>
<tr class="separator:a6813549291034e22b8c23512190e36e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8bd7d72a9b3c36434015674bc13cd7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>dilation_w</b></td></tr>
<tr class="separator:a0a8bd7d72a9b3c36434015674bc13cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433ab69df61deb5e78008f2017514433"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>stride_h</b></td></tr>
<tr class="separator:a433ab69df61deb5e78008f2017514433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f24cb994d9da9475e824cc5715772d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>stride_w</b></td></tr>
<tr class="separator:a28f24cb994d9da9475e824cc5715772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af099ee4ee7c78151eb49c18aa60795b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af099ee4ee7c78151eb49c18aa60795b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> = 0</td></tr>
<tr class="separator:af099ee4ee7c78151eb49c18aa60795b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e26b92169288a3179d57605789ac6c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e26b92169288a3179d57605789ac6c3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>C</b> = 0</td></tr>
<tr class="separator:a0e26b92169288a3179d57605789ac6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a137953ba6204f3e8fd74ec54e2939c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a137953ba6204f3e8fd74ec54e2939c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>H</b> = 0</td></tr>
<tr class="separator:a3a137953ba6204f3e8fd74ec54e2939c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b3cae1f95c037dc6731761f8c960d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18b3cae1f95c037dc6731761f8c960d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>W</b> = 0</td></tr>
<tr class="separator:a18b3cae1f95c037dc6731761f8c960d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967cf82937108e793eb54b0b67f21b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1967cf82937108e793eb54b0b67f21b0"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>dkernel_h</b> = dilation_h * (kernel_h - 1) + 1</td></tr>
<tr class="separator:a1967cf82937108e793eb54b0b67f21b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15994695a9f9cdadf3630c54ad6b80b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15994695a9f9cdadf3630c54ad6b80b"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>dkernel_w</b> = dilation_w * (kernel_w - 1) + 1</td></tr>
<tr class="separator:af15994695a9f9cdadf3630c54ad6b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac949bdc75720d6d87772574ddfa39974"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac949bdc75720d6d87772574ddfa39974"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>out_h</b> = (H + 2 * pad - dkernel_h) / stride_h + 1</td></tr>
<tr class="separator:ac949bdc75720d6d87772574ddfa39974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0262e3344411b113a3733e7bc902e2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0262e3344411b113a3733e7bc902e2e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>out_w</b> = (W + 2 * pad - dkernel_w) / stride_w + 1</td></tr>
<tr class="separator:ae0262e3344411b113a3733e7bc902e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4163bdb6c6ed9c3f5ca8a54ae7af557"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4163bdb6c6ed9c3f5ca8a54ae7af557"></a>
Max number of&#160;</td><td class="memItemRight" valign="bottom"><b>elements</b></td></tr>
<tr class="separator:ac4163bdb6c6ed9c3f5ca8a54ae7af557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a29cc27c9bbf99aa8d8f6676f5879"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0a29cc27c9bbf99aa8d8f6676f5879"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is&#160;</td><td class="memItemRight" valign="bottom"><b>frozen</b></td></tr>
<tr class="separator:a1c0a29cc27c9bbf99aa8d8f6676f5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b458a9c12db9cd3c46e7dc915fa127"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96b458a9c12db9cd3c46e7dc915fa127"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index&#160;</td><td class="memItemRight" valign="bottom"><b>Otherwise</b></td></tr>
<tr class="separator:a96b458a9c12db9cd3c46e7dc915fa127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d2691bcb314721c42ac8efbf00d542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32d2691bcb314721c42ac8efbf00d542"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been&#160;</td><td class="memItemRight" valign="bottom"><b>reached</b></td></tr>
<tr class="separator:a32d2691bcb314721c42ac8efbf00d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add92182063935ff83c56d664bebe6cc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add92182063935ff83c56d664bebe6cc6"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC&#160;</td><td class="memItemRight" valign="bottom"><b>keys</b></td></tr>
<tr class="separator:add92182063935ff83c56d664bebe6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b22611ea21528b9c509b99a53125d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69b22611ea21528b9c509b99a53125d9"></a>
disallowing creation of new index entries Should not be called concurrently with IndexGet DOC&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a69b22611ea21528b9c509b99a53125d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5f74034dd7155bb25a22d33d17f23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bd5f74034dd7155bb25a22d33d17f23"></a>
Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance The input handle If skips the first entry of the tensor This allows to load tensors that are aligned with an&#160;</td><td class="memItemRight" valign="bottom"><b>embedding</b></td></tr>
<tr class="separator:a4bd5f74034dd7155bb25a22d33d17f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f69ab33688c8da3f998b535e8560c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f4f69ab33688c8da3f998b535e8560c"></a>
Pointer to an <a class="el" href="structcaffe2_1_1_index.html">Index</a> instance The input handle If skips the first entry of the tensor This allows to load tensors that are aligned with an where the first entry corresponds to the default index&#160;</td><td class="memItemRight" valign="bottom"><b>entry</b></td></tr>
<tr class="separator:a1f4f69ab33688c8da3f998b535e8560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7960ab3a5bdbf445c0cc1ea8bc90bb6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7960ab3a5bdbf445c0cc1ea8bc90bb6"></a>
the first element of the output tensor will be element of index DOC&#160;</td><td class="memItemRight" valign="bottom"><b>items</b></td></tr>
<tr class="separator:ac7960ab3a5bdbf445c0cc1ea8bc90bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af745269a12adbef5b49b2a3fdb4d8833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af745269a12adbef5b49b2a3fdb4d8833"></a>
array of probabilities for prediction&#160;</td><td class="memItemRight" valign="bottom"><b>L</b></td></tr>
<tr class="separator:af745269a12adbef5b49b2a3fdb4d8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf33db75d197b55ae0da48da1e4cde0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf33db75d197b55ae0da48da1e4cde0"></a>
array of probabilities for prediction array of JSD&#160;</td><td class="memItemRight" valign="bottom"><b>losses</b></td></tr>
<tr class="separator:acaf33db75d197b55ae0da48da1e4cde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c21a1fa027620da6bc066dfabde121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96c21a1fa027620da6bc066dfabde121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>INT_MAX</b></td></tr>
<tr class="separator:a96c21a1fa027620da6bc066dfabde121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6875db97deb54ba11f0eea9b6ef95a84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6875db97deb54ba11f0eea9b6ef95a84"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>input_dims_long</b> = GetDimsVector(in[0])</td></tr>
<tr class="separator:a6875db97deb54ba11f0eea9b6ef95a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833087f682593970e7914e0992e5d3df"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis</b></td></tr>
<tr class="separator:a833087f682593970e7914e0992e5d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4915704cb8323a7767a70a700d183f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc4915704cb8323a7767a70a700d183f"></a>
int default&#160;</td><td class="memItemRight" valign="bottom"><b>to</b></td></tr>
<tr class="separator:adc4915704cb8323a7767a70a700d183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c2439e693d3e6737478637555ac966"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16c2439e693d3e6737478637555ac966"></a>
Coefficient of&#160;</td><td class="memItemRight" valign="bottom"><b>leakage</b></td></tr>
<tr class="separator:a16c2439e693d3e6737478637555ac966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15db7db5c2b5cf0082bdcbeefcc1bad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15db7db5c2b5cf0082bdcbeefcc1bad"></a>
but operating on bit rowwise quantized matrices with fused uint8 tensor obtained with&#160;</td><td class="memItemRight" valign="bottom"><b>LENGTHS</b></td></tr>
<tr class="separator:ad15db7db5c2b5cf0082bdcbeefcc1bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0da689d8212224b47e12a018391ebfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0da689d8212224b47e12a018391ebfa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>m_2</b></td></tr>
<tr class="separator:ae0da689d8212224b47e12a018391ebfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb37478836eb6c97f2c3b98af5b83b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebb37478836eb6c97f2c3b98af5b83b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>m_n</b></td></tr>
<tr class="separator:aebb37478836eb6c97f2c3b98af5b83b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2535a732c1ece7df1aaf184b8c9089de"><td class="memItemLeft" align="right" valign="top">reshape it into matrix of we compute&#160;</td><td class="memItemRight" valign="bottom"><b>scale_i</b></td></tr>
<tr class="separator:a2535a732c1ece7df1aaf184b8c9089de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f344d80280c15df7d0c165e69e12e4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f344d80280c15df7d0c165e69e12e4b"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th&#160;</td><td class="memItemRight" valign="bottom"><b>row</b></td></tr>
<tr class="separator:a3f344d80280c15df7d0c165e69e12e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9b7cc28c1e368ab79d928e9ae438f1"><td class="memItemLeft" align="right" valign="top">reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element&#160;</td><td class="memItemRight" valign="bottom"><b>r_</b></td></tr>
<tr class="separator:afc9b7cc28c1e368ab79d928e9ae438f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba68ae37acc6c8d1c4ef5741d5482c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ba68ae37acc6c8d1c4ef5741d5482c"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element each row r_i of which stores a pair&#160;</td><td class="memItemRight" valign="bottom"><b>s_i</b></td></tr>
<tr class="separator:a80ba68ae37acc6c8d1c4ef5741d5482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03ec9f80df496fa9cc57097a53280c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e03ec9f80df496fa9cc57097a53280c"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element each row r_i of which stores a pair&#160;</td><td class="memItemRight" valign="bottom"><b>b_i</b></td></tr>
<tr class="separator:a6e03ec9f80df496fa9cc57097a53280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a0db4af58de5f768499e496ab7a29c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a0db4af58de5f768499e496ab7a29c"></a>
and LENGTHS tensor of duplicate each entry of the outer most dimension of DATA according to and concatenate them in an output tensor of rank r&#160;</td><td class="memItemRight" valign="bottom"><b>Example</b></td></tr>
<tr class="separator:a41a0db4af58de5f768499e496ab7a29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d01cee0c09a2e0298f716ea9d7d303"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48d01cee0c09a2e0298f716ea9d7d303"></a>
where segments are defined by their and concatenate them in an output tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> =(SIZE(LENGTHs), k). In case there's less than k values in a segment</td></tr>
<tr class="separator:a48d01cee0c09a2e0298f716ea9d7d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87e96d4c7b59961d67e39a6b1c8b84c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af87e96d4c7b59961d67e39a6b1c8b84c"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of int32 lengths of rank&#160;</td><td class="memItemRight" valign="bottom"><b>TopKIndices</b></td></tr>
<tr class="separator:af87e96d4c7b59961d67e39a6b1c8b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae025e8482eec57d2f947daf162265e81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae025e8482eec57d2f947daf162265e81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>exists</b></td></tr>
<tr class="separator:ae025e8482eec57d2f947daf162265e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a539ca45c2e0532614691edbef5115"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26a539ca45c2e0532614691edbef5115"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>int</b></td></tr>
<tr class="separator:a26a539ca45c2e0532614691edbef5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca6d38fee66f487b9d4494ae5358fd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca6d38fee66f487b9d4494ae5358fd7"></a>
INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>string</b></td></tr>
<tr class="separator:a4ca6d38fee66f487b9d4494ae5358fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e9aac7255302feac18b3cd49a3a05e"><td class="memItemLeft" align="right" valign="top">INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>default</b></td></tr>
<tr class="separator:a84e9aac7255302feac18b3cd49a3a05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5fe4728e1b8a42ff90c79dbb7c11a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5f5fe4728e1b8a42ff90c79dbb7c11a"></a>
but allows one to save to db every few&#160;</td><td class="memItemRight" valign="bottom"><b>iterations</b></td></tr>
<tr class="separator:ad5f5fe4728e1b8a42ff90c79dbb7c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd8f8eaacd4ddb2a9217445821478f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dd8f8eaacd4ddb2a9217445821478f7"></a>
stride&#160;</td><td class="memItemRight" valign="bottom"><b>sizes</b></td></tr>
<tr class="separator:a7dd8f8eaacd4ddb2a9217445821478f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5f539715d65f5c68f344c868355d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f5f539715d65f5c68f344c868355d5"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a> Output data tensor from L p pooling across the input tensor Dimensions will vary based on various&#160;</td><td class="memItemRight" valign="bottom"><b>kernel</b></td></tr>
<tr class="separator:aa8f5f539715d65f5c68f344c868355d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedcf06f00cafa9c79c0b1ac1c3f8106"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afedcf06f00cafa9c79c0b1ac1c3f8106"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1_conv_pool_op_base.html">ConvPoolOpBase</a> Output data tensor from L p pooling across the input tensor Dimensions will vary based on various&#160;</td><td class="memItemRight" valign="bottom"><b>stride</b></td></tr>
<tr class="separator:afedcf06f00cafa9c79c0b1ac1c3f8106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27fa78c467fba5c61c550605162022c"><td class="memItemLeft" align="right" valign="top">and label is applied to the tensor elementwise If&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:af27fa78c467fba5c61c550605162022c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a332cb22714eba8bb0fdef14c34030d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a332cb22714eba8bb0fdef14c34030d"></a>
<a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arg_helper</b> (def)</td></tr>
<tr class="separator:a7a332cb22714eba8bb0fdef14c34030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbc7a0971315979347ee50dd9b153b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afdbc7a0971315979347ee50dd9b153b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>axis_a</b> = arg_helper.GetSingleArgument&lt;int&gt;(&quot;axis_a&quot;, 1)</td></tr>
<tr class="separator:afdbc7a0971315979347ee50dd9b153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f589c507849a1391d7dc6d652795d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974f589c507849a1391d7dc6d652795d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>axis_b</b> = arg_helper.GetSingleArgument&lt;int&gt;(&quot;axis_b&quot;, 1)</td></tr>
<tr class="separator:a974f589c507849a1391d7dc6d652795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebecc3bf57cafeb8faa1a924893b6e3e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebecc3bf57cafeb8faa1a924893b6e3e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>trans_a</b> = arg_helper.GetSingleArgument&lt;bool&gt;(&quot;trans_a&quot;, false)</td></tr>
<tr class="separator:aebecc3bf57cafeb8faa1a924893b6e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae62b6a05427609c18f31bde7b452a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cae62b6a05427609c18f31bde7b452a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>trans_b</b> = arg_helper.GetSingleArgument&lt;bool&gt;(&quot;trans_b&quot;, false)</td></tr>
<tr class="separator:a7cae62b6a05427609c18f31bde7b452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a445908fa33836b816544f0bf3c4c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88a445908fa33836b816544f0bf3c4c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_a</b> = canonical_axis_index_(axis_a, in[0].dims().size())</td></tr>
<tr class="separator:a88a445908fa33836b816544f0bf3c4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29606596277dd30518b88d66b63c4979"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29606596277dd30518b88d66b63c4979"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_b</b> = canonical_axis_index_(axis_b, in[0].dims().size())</td></tr>
<tr class="separator:a29606596277dd30518b88d66b63c4979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eda6ae4fc6876444d4e435bc7fc1149"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9eda6ae4fc6876444d4e435bc7fc1149"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M</b> = size_to_dim_(canonical_axis_a, GetDimsVector(in[0]))</td></tr>
<tr class="separator:a9eda6ae4fc6876444d4e435bc7fc1149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37306cd3376aac0448ddc53315551bc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37306cd3376aac0448ddc53315551bc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>A</b></td></tr>
<tr class="separator:a37306cd3376aac0448ddc53315551bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f5228af31085e0986b62a8161fc3eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f5228af31085e0986b62a8161fc3eb"></a>
matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>B</b></td></tr>
<tr class="separator:a40f5228af31085e0986b62a8161fc3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f63133167d59328c15c4ce234b50a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f7f63133167d59328c15c4ce234b50a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data_0</b></td></tr>
<tr class="separator:a4f7f63133167d59328c15c4ce234b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972833e2089ab4cb0b33f5e9d43b7e3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a972833e2089ab4cb0b33f5e9d43b7e3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>prediction</b></td></tr>
<tr class="separator:a972833e2089ab4cb0b33f5e9d43b7e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594cf996b8817ed8d72c760e8e9c804b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594cf996b8817ed8d72c760e8e9c804b"></a>
D float i&#160;</td><td class="memItemRight" valign="bottom"><b>e</b></td></tr>
<tr class="separator:a594cf996b8817ed8d72c760e8e9c804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b699a0901714ff53746bce0243dd643"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b699a0901714ff53746bce0243dd643"></a>
D float i batch size D is number of possible classes labels&#160;</td><td class="memItemRight" valign="bottom"><b>accuracies</b></td></tr>
<tr class="separator:a1b699a0901714ff53746bce0243dd643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcd9c1d66f538e1000206e7b9b26574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bcd9c1d66f538e1000206e7b9b26574"></a>
axis to&#160;</td><td class="memItemRight" valign="bottom"><b>normalize</b></td></tr>
<tr class="separator:a8bcd9c1d66f538e1000206e7b9b26574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c795ac7b5679d106913d1e43f1ede8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6c795ac7b5679d106913d1e43f1ede8"></a>
d int long tensor contains the length in each of the output&#160;</td><td class="memItemRight" valign="bottom"><b>packed_tensor</b></td></tr>
<tr class="separator:af6c795ac7b5679d106913d1e43f1ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d058cb2d3aecab8aa693b25b1e7ab33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d058cb2d3aecab8aa693b25b1e7ab33"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>presence_mask</b></td></tr>
<tr class="separator:a4d058cb2d3aecab8aa693b25b1e7ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582a59c237d9eb43bcbf72d14b26269e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a582a59c237d9eb43bcbf72d14b26269e"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> where dim boolean false where packed_tensor is&#160;</td><td class="memItemRight" valign="bottom"><b>padded</b></td></tr>
<tr class="separator:a582a59c237d9eb43bcbf72d14b26269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a316f28455ca932b1950c268bdd2ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93a316f28455ca932b1950c268bdd2ec"></a>
d int long tensor contains the length in each of the input N dim&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b></td></tr>
<tr class="separator:a93a316f28455ca932b1950c268bdd2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44dcb44f4ea48621f7963d6e79a4e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae44dcb44f4ea48621f7963d6e79a4e86"></a>
CPUContext::PadTensorInference Input data tensor from the previous&#160;</td><td class="memItemRight" valign="bottom"><b>operator</b></td></tr>
<tr class="separator:ae44dcb44f4ea48621f7963d6e79a4e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0a98ae5bc51ac68c5fecf74846a08d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba0a98ae5bc51ac68c5fecf74846a08d"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the&#160;</td><td class="memItemRight" valign="bottom"><b>former</b></td></tr>
<tr class="separator:aba0a98ae5bc51ac68c5fecf74846a08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1f4eca0104e94278a74f4ef8e73e3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa1f4eca0104e94278a74f4ef8e73e3f"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In&#160;</td><td class="memItemRight" valign="bottom"><b>particular</b></td></tr>
<tr class="separator:aaa1f4eca0104e94278a74f4ef8e73e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781301c4e85af233a6284cd73a386a90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a781301c4e85af233a6284cd73a386a90"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this&#160;</td><td class="memItemRight" valign="bottom"><b>value_to_pct</b></td></tr>
<tr class="separator:a781301c4e85af233a6284cd73a386a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000385437867c1c3d0c350bb31799f8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a000385437867c1c3d0c350bb31799f8a"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this Sorted with columns Each element in the first column is a float representing the raw value of a sample Its corresponding element in the next column represents the percentile it maps to&#160;</td><td class="memItemRight" valign="bottom"><b>percentile_values</b></td></tr>
<tr class="separator:a000385437867c1c3d0c350bb31799f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85259127c31499d533b3dfcd7ebf5dcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85259127c31499d533b3dfcd7ebf5dcf"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this Sorted with columns Each element in the first column is a float representing the raw value of a sample Its corresponding element in the next column represents the percentile it maps to tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>floats</b></td></tr>
<tr class="separator:a85259127c31499d533b3dfcd7ebf5dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6e93b181e5889e7dcc8f3c9de22d97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed6e93b181e5889e7dcc8f3c9de22d97"></a>
given a sample set of raw labeled with their corresponding percentiles from the same distribution In this Sorted with columns Each element in the first column is a float representing the raw value of a sample Its corresponding element in the next column represents the percentile it maps to tensor of with the same dimensions as the flattened input tensor Each element of this corresponds to the percentile calculated for&#160;</td><td class="memItemRight" valign="bottom"><b>original_values</b> [i]</td></tr>
<tr class="separator:aed6e93b181e5889e7dcc8f3c9de22d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e77cee7ed8c180ee4ac48a93e6af07"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e77cee7ed8c180ee4ac48a93e6af07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>probabilities</b></td></tr>
<tr class="separator:a06e77cee7ed8c180ee4ac48a93e6af07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb88ea06e7c7786f7fccf89856c939b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaeb88ea06e7c7786f7fccf89856c939b"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x&#160;</td><td class="memItemRight" valign="bottom"><b>prediction_dimensions</b></td></tr>
<tr class="separator:aaeb88ea06e7c7786f7fccf89856c939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0dd04e683afcc83fca64b8cdb7f2d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe0dd04e683afcc83fca64b8cdb7f2d4"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each&#160;</td><td class="memItemRight" valign="bottom"><b>piece</b></td></tr>
<tr class="separator:afe0dd04e683afcc83fca64b8cdb7f2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07067d0cf60007501b36e4723269c04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae07067d0cf60007501b36e4723269c04"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is&#160;</td><td class="memItemRight" valign="bottom"><b>slopes</b></td></tr>
<tr class="separator:ae07067d0cf60007501b36e4723269c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44d0d1acf67e19a840413070a7ff482"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae44d0d1acf67e19a840413070a7ff482"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear&#160;</td><td class="memItemRight" valign="bottom"><b>functions</b></td></tr>
<tr class="separator:ae44d0d1acf67e19a840413070a7ff482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c055b4bef5e52acb925112a7e4bae8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c055b4bef5e52acb925112a7e4bae8d"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b></td></tr>
<tr class="separator:a5c055b4bef5e52acb925112a7e4bae8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa771dd5c684177749fac98017f820793"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kAveragePoolDoc</b></td></tr>
<tr class="separator:aa771dd5c684177749fac98017f820793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a955b975554d5a59f51b580ac5ca05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxPoolDoc</b></td></tr>
<tr class="separator:af8a955b975554d5a59f51b580ac5ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae51abe6d2ce42e6c8dd18d0faaea9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3ae51abe6d2ce42e6c8dd18d0faaea9"></a>
and produces one output is applied to the data tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Slope</b></td></tr>
<tr class="separator:aa3ae51abe6d2ce42e6c8dd18d0faaea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75335d9753ecb69e051ed5d231330b3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75335d9753ecb69e051ed5d231330b3a"></a>
Size of the dimension to prepend&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b></td></tr>
<tr class="separator:a75335d9753ecb69e051ed5d231330b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf414ec5335b860871be92441009791"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabf414ec5335b860871be92441009791"></a>
Prefix string to prepend extracted blobs&#160;</td><td class="memItemRight" valign="bottom"><b>blob_names</b></td></tr>
<tr class="separator:aabf414ec5335b860871be92441009791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6063e6bcaed3c21cfc5ba2a2d4a42db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6063e6bcaed3c21cfc5ba2a2d4a42db"></a>
Prefix string to prepend extracted blobs tensor of strings containing extracted blob&#160;</td><td class="memItemRight" valign="bottom"><b>names</b></td></tr>
<tr class="separator:ad6063e6bcaed3c21cfc5ba2a2d4a42db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc85df67937009da8c9b40f8e200a67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affc85df67937009da8c9b40f8e200a67"></a>
the implementation takes an the hidden state the cell and a weight&#160;</td><td class="memItemRight" valign="bottom"><b>TxNxD</b></td></tr>
<tr class="separator:affc85df67937009da8c9b40f8e200a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc4cd73d7a27e1f7a87b8472166f860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc4cd73d7a27e1f7a87b8472166f860"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>bidirectional</b></td></tr>
<tr class="separator:a3dc4cd73d7a27e1f7a87b8472166f860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265eb912ecfd3e936faaa35ffc48fe5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a265eb912ecfd3e936faaa35ffc48fe5a"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>num_layers</b></td></tr>
<tr class="separator:a265eb912ecfd3e936faaa35ffc48fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a14739188d2f98346f4b2fe102fcf0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1a14739188d2f98346f4b2fe102fcf0"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>rnn_mode</b></td></tr>
<tr class="separator:ab1a14739188d2f98346f4b2fe102fcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0697a8c7a31db09034b492c3926f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addb0697a8c7a31db09034b492c3926f6"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell input_mode are passed directly through to CuDNN&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b></td></tr>
<tr class="separator:addb0697a8c7a31db09034b492c3926f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5b511557f03896c001185e3672999"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb5b511557f03896c001185e3672999"></a>
R recurrent or input R&#160;</td><td class="memItemRight" valign="bottom"><b>all_params</b></td></tr>
<tr class="separator:a4fb5b511557f03896c001185e3672999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed098459630802109ed29afd323aec5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed098459630802109ed29afd323aec5b"></a>
the value to replace&#160;</td><td class="memItemRight" valign="bottom"><b>NaN</b></td></tr>
<tr class="separator:aed098459630802109ed29afd323aec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d61b7001d72065b6aa1e703c9cce5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a873d61b7001d72065b6aa1e703c9cce5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>actualNewShape</b> = helper.GetRepeatedArgument&lt;int64_t&gt;(&quot;shape&quot;)</td></tr>
<tr class="separator:a873d61b7001d72065b6aa1e703c9cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a806608620d39e6b1ecaf34a1b255b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37a806608620d39e6b1ecaf34a1b255b"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>totalSize</b> = 1</td></tr>
<tr class="separator:a37a806608620d39e6b1ecaf34a1b255b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb85f525131e24b7d5b2eb229911f7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eb85f525131e24b7d5b2eb229911f7f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>unknownIdx</b> = -1</td></tr>
<tr class="separator:a8eb85f525131e24b7d5b2eb229911f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc042919e612ec50e763098e9a6a10c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:abc042919e612ec50e763098e9a6a10c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ff1dd7d50d2d4138f13b74a62f161f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99ff1dd7d50d2d4138f13b74a62f161f"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this&#160;</td><td class="memItemRight" valign="bottom"><b>case</b></td></tr>
<tr class="separator:a99ff1dd7d50d2d4138f13b74a62f161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9fe9e9bbdae383308b3b1d80966b74"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd9fe9e9bbdae383308b3b1d80966b74"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also&#160;</td><td class="memItemRight" valign="bottom"><b>be</b></td></tr>
<tr class="separator:afd9fe9e9bbdae383308b3b1d80966b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3398bd4207d1a0cae41a0709ca8bf19a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3398bd4207d1a0cae41a0709ca8bf19a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>segments</b></td></tr>
<tr class="separator:a3398bd4207d1a0cae41a0709ca8bf19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68c67fc2c092431b76e601447c8a10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade68c67fc2c092431b76e601447c8a10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>embeddings</b></td></tr>
<tr class="separator:ade68c67fc2c092431b76e601447c8a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ffdee20b31f06da7a5ad73418913da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ffdee20b31f06da7a5ad73418913da"></a>
See RoIPoolF&#160;</td><td class="memItemRight" valign="bottom"><b>dY</b></td></tr>
<tr class="separator:a73ffdee20b31f06da7a5ad73418913da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa359d2095f6c54a1076ff23f33fedfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa359d2095f6c54a1076ff23f33fedfd"></a>
See RoIPoolF Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>dX</b></td></tr>
<tr class="separator:aaa359d2095f6c54a1076ff23f33fedfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8abb08815ed2b537572b7770bfbef4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8abb08815ed2b537572b7770bfbef4d"></a>
Spatial scale of the input feature map X relative to the input image E&#160;</td><td class="memItemRight" valign="bottom"><b>g</b></td></tr>
<tr class="separator:ae8abb08815ed2b537572b7770bfbef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9115771c8c914cda9be537c1ec39e402"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9115771c8c914cda9be537c1ec39e402"></a>
Pooled output Y s width feature map input of&#160;</td><td class="memItemRight" valign="bottom"><b>RoIs</b></td></tr>
<tr class="separator:a9115771c8c914cda9be537c1ec39e402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f1546edffed1e9aba557b776054b41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92f1546edffed1e9aba557b776054b41"></a>
there are multiple output&#160;</td><td class="memItemRight" valign="bottom"><b>cases</b></td></tr>
<tr class="separator:a92f1546edffed1e9aba557b776054b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894bce6c1cc63d0c81412c6b226c5507"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a894bce6c1cc63d0c81412c6b226c5507"></a>
default the scale to&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b></td></tr>
<tr class="separator:a894bce6c1cc63d0c81412c6b226c5507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dde945e8c293e42578695bb73fa128"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76dde945e8c293e42578695bb73fa128"></a>
affects the activation function itself This should go with the weight initialization in the paper See&#160;</td><td class="memItemRight" valign="bottom"><b>https</b></td></tr>
<tr class="separator:a76dde945e8c293e42578695bb73fa128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e0ab7bd353bf53fdb04b239c3ec035"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64e0ab7bd353bf53fdb04b239c3ec035"></a>
Number of copies of padding to add around each range&#160;</td><td class="memItemRight" valign="bottom"><b>data_in</b></td></tr>
<tr class="separator:a64e0ab7bd353bf53fdb04b239c3ec035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79f074ae71be18c7b8ea3cf43ce9b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a79f074ae71be18c7b8ea3cf43ce9b7"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>start_padding</b></td></tr>
<tr class="separator:a9a79f074ae71be18c7b8ea3cf43ce9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26361d416bfb03f08ffdcd39b05a4450"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26361d416bfb03f08ffdcd39b05a4450"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start&#160;</td><td class="memItemRight" valign="bottom"><b>data_out</b></td></tr>
<tr class="separator:a26361d416bfb03f08ffdcd39b05a4450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c9a0e8cde128f1ec5dc8087e66917"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a074c9a0e8cde128f1ec5dc8087e66917"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data&#160;</td><td class="memItemRight" valign="bottom"><b>padding_sum</b></td></tr>
<tr class="separator:a074c9a0e8cde128f1ec5dc8087e66917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f20693c31916293168aa86432578f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a955f20693c31916293168aa86432578f"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data Sum of all start&#160;</td><td class="memItemRight" valign="bottom"><b>paddings</b></td></tr>
<tr class="separator:a955f20693c31916293168aa86432578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98c7350def0accacb05ea1e3989425"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c98c7350def0accacb05ea1e3989425"></a>
only slicing in a single dimension is supported Slices are passed as vectors or as two keyword argument lists with starting and end indices for each dimension of the input data tensor If a negative value is passed for any of the start or end&#160;</td><td class="memItemRight" valign="bottom"><b>indices</b></td></tr>
<tr class="separator:a8c98c7350def0accacb05ea1e3989425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96894028253b5436881789e477c8a8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af96894028253b5436881789e477c8a8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rather</b></td></tr>
<tr class="separator:af96894028253b5436881789e477c8a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f51cf0e7a7c3688d879508f69477aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26f51cf0e7a7c3688d879508f69477aa"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis&#160;</td><td class="memItemRight" valign="bottom"><b>provided</b></td></tr>
<tr class="separator:a26f51cf0e7a7c3688d879508f69477aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835f67b5642584a8b4042be5a4f77f03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a835f67b5642584a8b4042be5a4f77f03"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions[a_0 *...*a_{k-1}, a_k *...*a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>dimensions</b> [a_0, a_1 *...*a_{n-1}]</td></tr>
<tr class="separator:a835f67b5642584a8b4042be5a4f77f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341e96535f826465053b5a6b94ec55ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341e96535f826465053b5a6b94ec55ed"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions[a_0 *...*a_{k-1}, a_k *...*a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this&#160;</td><td class="memItemRight" valign="bottom"><b>situation</b></td></tr>
<tr class="separator:a341e96535f826465053b5a6b94ec55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34174f2652b1ceed8b21e82dc5401de4"><td class="memItemLeft" align="right" valign="top">it will be coerced into one For an arbitrary n dimensional tensor X in[a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions[a_0 *...*a_{k-1}, a_k *...*a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have&#160;</td><td class="memItemRight" valign="bottom"><b>a_0</b></td></tr>
<tr class="separator:a34174f2652b1ceed8b21e82dc5401de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac905ba11e842b05d79645781591665b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac905ba11e842b05d79645781591665b9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>labels</b> = in[1]</td></tr>
<tr class="separator:ac905ba11e842b05d79645781591665b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ec3d8b4f17b4e26fdfd0f339e64089"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><b>num_classes</b></td></tr>
<tr class="separator:a22ec3d8b4f17b4e26fdfd0f339e64089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469f4d6a64b3c06be07c93816218588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa469f4d6a64b3c06be07c93816218588"></a>
Unscaled log probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>weight_tensor</b></td></tr>
<tr class="separator:aa469f4d6a64b3c06be07c93816218588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767cf78651f26ed6df6a8aeb5f1b5d40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a767cf78651f26ed6df6a8aeb5f1b5d40"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss&#160;</td><td class="memItemRight" valign="bottom"><b>loss</b></td></tr>
<tr class="separator:a767cf78651f26ed6df6a8aeb5f1b5d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f4700a29ab07e83f2da42d5d78ec2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1f4700a29ab07e83f2da42d5d78ec2"></a>
this op outputs a copy of the input tensor where values from the height and width dimensions are moved to the batch dimension After the zero&#160;</td><td class="memItemRight" valign="bottom"><b>padding</b></td></tr>
<tr class="separator:a1f1f4700a29ab07e83f2da42d5d78ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc109e6351665ebf886eff4bff7615ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc109e6351665ebf886eff4bff7615ef"></a>
followed by cropping This is the reverse transformation of SpaceToBatch More&#160;</td><td class="memItemRight" valign="bottom"><b>specifically</b></td></tr>
<tr class="separator:abc109e6351665ebf886eff4bff7615ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa762c75d4e46531704cfa03cdaf723ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa762c75d4e46531704cfa03cdaf723ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>param</b></td></tr>
<tr class="separator:aa762c75d4e46531704cfa03cdaf723ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b2361594237f0e46c48218e03999df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22b2361594237f0e46c48218e03999df"></a>
Parameters to be normalized&#160;</td><td class="memItemRight" valign="bottom"><b>grad</b></td></tr>
<tr class="separator:a22b2361594237f0e46c48218e03999df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2506c69ffc53d2e96b8bdea9b074175c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2506c69ffc53d2e96b8bdea9b074175c"></a>
Parameters to be normalized Gradient computed A bool variable to control whether to use max norm or constant norm When&#160;</td><td class="memItemRight" valign="bottom"><b>use_max_norm</b> = false</td></tr>
<tr class="separator:a2506c69ffc53d2e96b8bdea9b074175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43af402778303cefcff606cf59b2ed3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43af402778303cefcff606cf59b2ed3a"></a>
Parameters to be normalized Gradient computed A bool variable to control whether to use max norm or constant norm When constant norm is used so that all the embedding vectors are scaled to have a L2 norm equals to max norm is used so that embedding is scaled so that its l2 norm is no larger than A If an embedding s norm is less than A&#160;</td><td class="memItemRight" valign="bottom"><b>originally</b></td></tr>
<tr class="separator:a43af402778303cefcff606cf59b2ed3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4b212a0e77899730111b72a268394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8de4b212a0e77899730111b72a268394"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss With spatial weighting is by&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a8de4b212a0e77899730111b72a268394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2db89e5ced97847aea14ff2699ae6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaea2db89e5ced97847aea14ff2699ae6"></a>
A <a class="el" href="classcaffe2_1_1_blob.html">Blob</a> pointing to the newly created&#160;</td><td class="memItemRight" valign="bottom"><b>StatRegistry</b></td></tr>
<tr class="separator:aaea2db89e5ced97847aea14ff2699ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d30c53af125f5297c370ca526670c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d30c53af125f5297c370ca526670c0"></a>
If export values from given <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1_stat_registry.html">StatRegistry</a> int64 tensor with exported values default true Whether to atomically reset the counters&#160;</td><td class="memItemRight" valign="bottom"><b>afterwards</b></td></tr>
<tr class="separator:a12d30c53af125f5297c370ca526670c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de79bd753711e5065b68a1a5c484e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0de79bd753711e5065b68a1a5c484e4"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC&#160;</td><td class="memItemRight" valign="bottom"><b>timer</b></td></tr>
<tr class="separator:ab0de79bd753711e5065b68a1a5c484e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55376edd3fd71ff9886aca6c84958384"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55376edd3fd71ff9886aca6c84958384"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC Pointer to to be passed to&#160;</td><td class="memItemRight" valign="bottom"><b>TimerEnd</b></td></tr>
<tr class="separator:a55376edd3fd71ff9886aca6c84958384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fdfe6cb8c3f03bcfdf46bea8e63d5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83fdfe6cb8c3f03bcfdf46bea8e63d5f"></a>
stops the timer publishing a CAFFE_EVENT DOC&#160;</td><td class="memItemRight" valign="bottom"><b>nanos</b></td></tr>
<tr class="separator:a83fdfe6cb8c3f03bcfdf46bea8e63d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04d7ded24af143786e328cd13aab7c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab04d7ded24af143786e328cd13aab7c8"></a>
stops the timer publishing a CAFFE_EVENT DOC nanoseconds in&#160;</td><td class="memItemRight" valign="bottom"><b>int64</b></td></tr>
<tr class="separator:ab04d7ded24af143786e328cd13aab7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa978788e9d6c9e09eb3acd82761cb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aa978788e9d6c9e09eb3acd82761cb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>utilization</b></td></tr>
<tr class="separator:a0aa978788e9d6c9e09eb3acd82761cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062d7098f120443935eba6e90066ac86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a062d7098f120443935eba6e90066ac86"></a>
Delta in max CPU utilization&#160;</td><td class="memItemRight" valign="bottom"><b>observed</b></td></tr>
<tr class="separator:a062d7098f120443935eba6e90066ac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a63043bc4c891fd5bf4541f9c6059e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46a63043bc4c891fd5bf4541f9c6059e"></a>
default flag to indicate if the summarized statistics have to be written to a log file D&#160;</td><td class="memItemRight" valign="bottom"><b>max</b></td></tr>
<tr class="separator:a46a63043bc4c891fd5bf4541f9c6059e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd265702e7a42e4caf263cf1764ddb1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd265702e7a42e4caf263cf1764ddb1e"></a>
default flag to indicate if the summarized statistics have to be written to a log file D mean and standard&#160;</td><td class="memItemRight" valign="bottom"><b>deviation</b></td></tr>
<tr class="separator:afd265702e7a42e4caf263cf1764ddb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cfbc8efd5c995523881c02ef435780"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95cfbc8efd5c995523881c02ef435780"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kSummaryzeOpExtension</b> [] = &quot;.summary&quot;</td></tr>
<tr class="separator:a95cfbc8efd5c995523881c02ef435780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b725d863847481a51222a0f828682a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95b725d863847481a51222a0f828682a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>tiles</b> = helper.GetSingleArgument&lt;int32_t&gt;(&quot;tiles&quot;, 1)</td></tr>
<tr class="separator:a95b725d863847481a51222a0f828682a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83c94a49114ef26a688f7b93630d8a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa83c94a49114ef26a688f7b93630d8a9"></a>
Number of replicas The input tensor optional Axis to replicate&#160;</td><td class="memItemRight" valign="bottom"><b>tiled_data</b></td></tr>
<tr class="separator:aa83c94a49114ef26a688f7b93630d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417744630a98bb0d68f55d26cc0dc019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a417744630a98bb0d68f55d26cc0dc019"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>a_2</b></td></tr>
<tr class="separator:a417744630a98bb0d68f55d26cc0dc019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27dfcc5dcc47931e1f34d40af2268a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27dfcc5dcc47931e1f34d40af2268a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>a_n</b></td></tr>
<tr class="separator:ac27dfcc5dcc47931e1f34d40af2268a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ddcda9f75a80dfa630faafc917c81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e8ddcda9f75a80dfa630faafc917c81"></a>
r and integer argument&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:a6e8ddcda9f75a80dfa630faafc917c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b750e65c5bc2bf187321b03037677"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d2b750e65c5bc2bf187321b03037677"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1_index.html">Index</a> tensor of shape[a_1, a_2,..., a_n, k] which contains the indices of the top k this&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b></td></tr>
<tr class="separator:a6d2b750e65c5bc2bf187321b03037677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8fcb29d5e9fa7ea899c169b44b5d9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc8fcb29d5e9fa7ea899c169b44b5d9e"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>axes</b> = helper.GetRepeatedArgument&lt;int&gt;(&quot;axes&quot;)</td></tr>
<tr class="separator:acc8fcb29d5e9fa7ea899c169b44b5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b77424afcbc65c3b1971194b6c5e84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>valid_axes</b></td></tr>
<tr class="separator:a45b77424afcbc65c3b1971194b6c5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08b3d1ffa31eb8bf73ec5a7d92a3475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa08b3d1ffa31eb8bf73ec5a7d92a3475"></a>
A list of integers By reverse the otherwise permute the axes according to the values given&#160;</td><td class="memItemRight" valign="bottom"><b>transposed</b></td></tr>
<tr class="separator:aa08b3d1ffa31eb8bf73ec5a7d92a3475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3294f46f45a52ac75939d3e6239c9021"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3294f46f45a52ac75939d3e6239c9021"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>time</b></td></tr>
<tr class="separator:a3294f46f45a52ac75939d3e6239c9021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a9a81af86f2fc412c0a0260bac35f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64a9a81af86f2fc412c0a0260bac35f6"></a>
The time in&#160;</td><td class="memItemRight" valign="bottom"><b>nanoseconds</b></td></tr>
<tr class="separator:a64a9a81af86f2fc412c0a0260bac35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade73067b9ad02d9b13ecacbc0ed4fbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade73067b9ad02d9b13ecacbc0ed4fbb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>if</b></td></tr>
<tr class="separator:aade73067b9ad02d9b13ecacbc0ed4fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff253c52b3d44ad91706a0c24aeea4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93ff253c52b3d44ad91706a0c24aeea4"></a>
bool saves contents to the root folder of the current&#160;</td><td class="memItemRight" valign="bottom"><b>workspace</b></td></tr>
<tr class="separator:a93ff253c52b3d44ad91706a0c24aeea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3b3661ddd176f90ad9b9c5520e893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65a3b3661ddd176f90ad9b9c5520e893"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>total</b> = 1</td></tr>
<tr class="separator:a65a3b3661ddd176f90ad9b9c5520e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa417bd155d6b4319f85a3a78f9d8f2f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa417bd155d6b4319f85a3a78f9d8f2f9"></a>
A tensor of sharing its&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="separator:aa417bd155d6b4319f85a3a78f9d8f2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a684970edd0e97223b523a614393ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a684970edd0e97223b523a614393ed"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>X_0</b></td></tr>
<tr class="separator:a97a684970edd0e97223b523a614393ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c446b785a118216262c002ede1a0a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c446b785a118216262c002ede1a0a4"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>weight_0</b></td></tr>
<tr class="separator:af8c446b785a118216262c002ede1a0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc0b1f14d9920273ebc94fb7610f43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bcc0b1f14d9920273ebc94fb7610f43"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>X_1</b></td></tr>
<tr class="separator:a0bcc0b1f14d9920273ebc94fb7610f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e4d7fb6844992f3ff95a3dbccd1b8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1e4d7fb6844992f3ff95a3dbccd1b8e"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>weight_1</b></td></tr>
<tr class="separator:aa1e4d7fb6844992f3ff95a3dbccd1b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3f980520494eda17e8b5e9dc660c3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d3f980520494eda17e8b5e9dc660c3c"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>INDICES</b></td></tr>
<tr class="separator:a2d3f980520494eda17e8b5e9dc660c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac630098d19dad90cfa1551aa1aa22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63ac630098d19dad90cfa1551aa1aa22"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Weight_1</b></td></tr>
<tr class="separator:a63ac630098d19dad90cfa1551aa1aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2749e9cbc1df89b52d0424767c485f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace2749e9cbc1df89b52d0424767c485f"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>SLICES</b></td></tr>
<tr class="separator:ace2749e9cbc1df89b52d0424767c485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0cba0b7d70951edceded2d42db0d09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e0cba0b7d70951edceded2d42db0d09"></a>
<a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> to be updated Update&#160;</td><td class="memItemRight" valign="bottom"><b>slices</b></td></tr>
<tr class="separator:a6e0cba0b7d70951edceded2d42db0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d06086ac8ff6ede90d0b42dad0812ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d06086ac8ff6ede90d0b42dad0812ce"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>kPrintFileExtension</b> [] = &quot;.log&quot;</td></tr>
<tr class="separator:a4d06086ac8ff6ede90d0b42dad0812ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496eed23a8db93ec6c2fe45c5af8ce33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a496eed23a8db93ec6c2fe45c5af8ce33"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D&#160;</td><td class="memItemRight" valign="bottom"><b>sampling_weights</b></td></tr>
<tr class="separator:a496eed23a8db93ec6c2fe45c5af8ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61df92065656c8bf671cdc692e34942b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a61df92065656c8bf671cdc692e34942b"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>sampling_values</b></td></tr>
<tr class="separator:a61df92065656c8bf671cdc692e34942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1b3412c235ff2351300e03a78bea2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae1b3412c235ff2351300e03a78bea2f"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>sampled_indexes</b></td></tr>
<tr class="separator:aae1b3412c235ff2351300e03a78bea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140300568fdaa9c9051605cf9b123fe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a140300568fdaa9c9051605cf9b123fe2"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>sampled_values</b></td></tr>
<tr class="separator:a140300568fdaa9c9051605cf9b123fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413dcb9a1fabf1a7cec4c9404bd7396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7413dcb9a1fabf1a7cec4c9404bd7396"></a>
Timeout in&#160;</td><td class="memItemRight" valign="bottom"><b>secs</b></td></tr>
<tr class="separator:a7413dcb9a1fabf1a7cec4c9404bd7396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c354f476240f392ab010204294ec95"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c354f476240f392ab010204294ec95"></a>
Timeout in&#160;</td><td class="memItemRight" valign="bottom"><b>queue</b></td></tr>
<tr class="separator:a73c354f476240f392ab010204294ec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edb91da059b55443b1e1da62ede5d8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7edb91da059b55443b1e1da62ede5d8e"></a>
The shared pointer for the&#160;</td><td class="memItemRight" valign="bottom"><b>BlobsQueue</b></td></tr>
<tr class="separator:a7edb91da059b55443b1e1da62ede5d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0e7956b663833f254e29316fd8937"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95d0e7956b663833f254e29316fd8937"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC The shared pointer for the <a class="el" href="classcaffe2_1_1_blobs_queue.html">BlobsQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>status</b></td></tr>
<tr class="separator:a95d0e7956b663833f254e29316fd8937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8a500a75314ea467a2106a53c34cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f8a500a75314ea467a2106a53c34cb"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC The shared pointer for the <a class="el" href="classcaffe2_1_1_blobs_queue.html">BlobsQueue</a> Is set to depending on the success of&#160;</td><td class="memItemRight" valign="bottom"><b>dequeue</b></td></tr>
<tr class="separator:a29f8a500a75314ea467a2106a53c34cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76351eacbd2e27f4c16e4f8c8cc0ad27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76351eacbd2e27f4c16e4f8c8cc0ad27"></a>
Parameters to be updated Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>output_param</b></td></tr>
<tr class="separator:a76351eacbd2e27f4c16e4f8c8cc0ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081ca1b630006767cc0ec781ca78a27d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a081ca1b630006767cc0ec781ca78a27d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>moment</b></td></tr>
<tr class="separator:a081ca1b630006767cc0ec781ca78a27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273ccf387f0345956ca0c2d5f89fe673"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a273ccf387f0345956ca0c2d5f89fe673"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lr</b></td></tr>
<tr class="separator:a273ccf387f0345956ca0c2d5f89fe673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaacd1999594e9f6e2699c09387f4709"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaacd1999594e9f6e2699c09387f4709"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>output_moment_1</b></td></tr>
<tr class="separator:afaacd1999594e9f6e2699c09387f4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251233b68c7c802ac10e823fd131a1d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a251233b68c7c802ac10e823fd131a1d9"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Default</b></td></tr>
<tr class="separator:a251233b68c7c802ac10e823fd131a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dd84a062642ec91cb5e9ead4992387"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03dd84a062642ec91cb5e9ead4992387"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>moment_2</b></td></tr>
<tr class="separator:a03dd84a062642ec91cb5e9ead4992387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfde5e010336b6dfa0c945b58fd9417"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cfde5e010336b6dfa0c945b58fd9417"></a>
Parameters to be updated Second moment history learning rate Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>output_moment_2</b></td></tr>
<tr class="separator:a9cfde5e010336b6dfa0c945b58fd9417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e4129a5ffe6e161591d258fbcac7f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2e4129a5ffe6e161591d258fbcac7f7"></a>
Parameters to be updated Second moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b></td></tr>
<tr class="separator:ac2e4129a5ffe6e161591d258fbcac7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad245dfe6cdb3e86167608f294ea0d02d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad245dfe6cdb3e86167608f294ea0d02d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>input_tensor</b></td></tr>
<tr class="separator:ad245dfe6cdb3e86167608f294ea0d02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eefe979dd1aa0a3bcffe5bae25b2e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32eefe979dd1aa0a3bcffe5bae25b2e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="separator:a32eefe979dd1aa0a3bcffe5bae25b2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5c1997a586b412366282e3d5c36ed8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff5c1997a586b412366282e3d5c36ed8"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>nesterov</b></td></tr>
<tr class="separator:aff5c1997a586b412366282e3d5c36ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d580ff9f43830a1a4910e1374df359e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d580ff9f43830a1a4910e1374df359e"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>computes</b></td></tr>
<tr class="separator:a3d580ff9f43830a1a4910e1374df359e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d84a24ebe7bd6eb94a08f04bc6f5d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d84a24ebe7bd6eb94a08f04bc6f5d5"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>adjusted_gradient</b></td></tr>
<tr class="separator:a83d84a24ebe7bd6eb94a08f04bc6f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983f6c0370710aa3fee309be4042f2de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a983f6c0370710aa3fee309be4042f2de"></a>
given param&#160;</td><td class="memItemRight" valign="bottom"><b>momentum</b></td></tr>
<tr class="separator:a983f6c0370710aa3fee309be4042f2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f18bb49a8ab18db4eb71615e96ce71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f18bb49a8ab18db4eb71615e96ce71"></a>
given param parameter Note the difference to&#160;</td><td class="memItemRight" valign="bottom"><b>MomentumSGD</b></td></tr>
<tr class="separator:ad1f18bb49a8ab18db4eb71615e96ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e753c4409d91d8b8b316a4a3740105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9e753c4409d91d8b8b316a4a3740105"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient Updated parameter boolean Whether to use Nesterov Accelerated&#160;</td><td class="memItemRight" valign="bottom"><b>Gradient</b></td></tr>
<tr class="separator:aa9e753c4409d91d8b8b316a4a3740105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122aa4ca0f9404d6371137d86062608"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7122aa4ca0f9404d6371137d86062608"></a>
Parameters to be updated Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>curv_win</b></td></tr>
<tr class="separator:a7122aa4ca0f9404d6371137d86062608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a9855e8d5726f19a8cb00c750a2785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07a9855e8d5726f19a8cb00c750a2785"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>g2_avg</b></td></tr>
<tr class="separator:a07a9855e8d5726f19a8cb00c750a2785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e124b5cc6833c47766b8591badedcac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e124b5cc6833c47766b8591badedcac"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>output_lr</b></td></tr>
<tr class="separator:a4e124b5cc6833c47766b8591badedcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad634dc96d52b1398e9a9962f54f90999"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad634dc96d52b1398e9a9962f54f90999"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>output_curv_win</b></td></tr>
<tr class="separator:ad634dc96d52b1398e9a9962f54f90999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9a5a40ec5af5f25ebed9ccf8cdab6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26e9a5a40ec5af5f25ebed9ccf8cdab6"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>output_g2_avg</b></td></tr>
<tr class="separator:a26e9a5a40ec5af5f25ebed9ccf8cdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ad980b4534788ecf0b74ccb620cd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad52ad980b4534788ecf0b74ccb620cd9"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>compressed</b></td></tr>
<tr class="separator:ad52ad980b4534788ecf0b74ccb620cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6628a6811afecb701315bbe9f4f69a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6628a6811afecb701315bbe9f4f69a0"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultMinWorkSize</b> = 80</td></tr>
<tr class="separator:ad6628a6811afecb701315bbe9f4f69a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda0a33e913bd4c1b4b8eba8ca6d0c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fda0a33e913bd4c1b4b8eba8ca6d0c8"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kCacheLineSize</b> = 64</td></tr>
<tr class="separator:a2fda0a33e913bd4c1b4b8eba8ca6d0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07a4973050cd3d4b5cc90e0b1c422b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d07a4973050cd3d4b5cc90e0b1c422b"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMLOWPCacheLineSize</b> = 64</td></tr>
<tr class="separator:a4d07a4973050cd3d4b5cc90e0b1c422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01c330ff817b47ce5d3f2af7860c9ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac01c330ff817b47ce5d3f2af7860c9ca"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxBusyWaitNOPs</b> = 32 * 1000 * 1000</td></tr>
<tr class="separator:ac01c330ff817b47ce5d3f2af7860c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed020b5f0b3d2bfb6bfab750924d9dd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed020b5f0b3d2bfb6bfab750924d9dd2"></a>
where N is the number of elements in the&#160;</td><td class="memItemRight" valign="bottom"><b>batch</b></td></tr>
<tr class="separator:aed020b5f0b3d2bfb6bfab750924d9dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaca74207e0950141b4065f4d3edd356"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaca74207e0950141b4065f4d3edd356"></a>
where N is the number of elements in the H and W are the height and&#160;</td><td class="memItemRight" valign="bottom"><b>width</b></td></tr>
<tr class="separator:aeaca74207e0950141b4065f4d3edd356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c10ab5fa385762978454077dea15e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6c10ab5fa385762978454077dea15e3"></a>
where N is the number of elements in the H and W are the height and and each of length num_classes The softmax is applied to each group independently&#160;</td><td class="memItemRight" valign="bottom"><b>See</b></td></tr>
<tr class="separator:af6c10ab5fa385762978454077dea15e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66d51642dae6860e4466d02f638f6f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66d51642dae6860e4466d02f638f6f4"></a>
number of classes in each softmax group tensor of softmax probabilities with where and softmax was applied to each of the num_anchors&#160;</td><td class="memItemRight" valign="bottom"><b>groups</b></td></tr>
<tr class="separator:ae66d51642dae6860e4466d02f638f6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa387555929f783931a3daae73258f6a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa387555929f783931a3daae73258f6a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>scores</b></td></tr>
<tr class="separator:aa387555929f783931a3daae73258f6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dabcd58efcb03a5854ddc2ced520955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dabcd58efcb03a5854ddc2ced520955"></a>
See GroupSpatialSoftmax&#160;</td><td class="memItemRight" valign="bottom"><b>d_scores</b></td></tr>
<tr class="separator:a2dabcd58efcb03a5854ddc2ced520955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa896509ba020db78e177d62b08e853ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa896509ba020db78e177d62b08e853ab"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Y_hat</b></td></tr>
<tr class="separator:aa896509ba020db78e177d62b08e853ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0000b1506a25ba86106e1206b320bd9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0000b1506a25ba86106e1206b320bd9f"></a>
L2 to L1 transition <a class="el" href="structpoint.html">point</a> tensor of bounding box regression predictions with tensor of labels&#160;</td><td class="memItemRight" valign="bottom"><b>locations</b></td></tr>
<tr class="separator:a0000b1506a25ba86106e1206b320bd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9ac9ac239dc6258625e39c593f4017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a9ac9ac239dc6258625e39c593f4017"></a>
See SelectSmoothL1Loss See SelectSmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>d_loss</b></td></tr>
<tr class="separator:a6a9ac9ac239dc6258625e39c593f4017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de71de1541a14734d46a8850369932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2de71de1541a14734d46a8850369932"></a>
See SelectSmoothL1Loss See SelectSmoothL1Loss Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>d_Y_hat</b></td></tr>
<tr class="separator:ac2de71de1541a14734d46a8850369932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b67d7c8ded06316eb76184a46bd2b1"><td class="memItemLeft" align="right" valign="top">where indicates that the corresponding sample should be ignored&#160;</td><td class="memItemRight" valign="bottom"><b>and</b></td></tr>
<tr class="separator:a33b67d7c8ded06316eb76184a46bd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d0ba21848e422be4315ee22951e05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a845d0ba21848e422be4315ee22951e05"></a>
multiply the loss by this scale factor <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of predicted&#160;</td><td class="memItemRight" valign="bottom"><b>targets</b></td></tr>
<tr class="separator:a845d0ba21848e422be4315ee22951e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a0093200964db0cdd407849b3ded00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86a0093200964db0cdd407849b3ded00"></a>
where N is the number of elements in the H and W are the height and and each of length num_classes For the binary form of Focal&#160;</td><td class="memItemRight" valign="bottom"><b>Loss</b></td></tr>
<tr class="separator:a86a0093200964db0cdd407849b3ded00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9050fa7b2067de6640cd2c7582fe9dfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9050fa7b2067de6640cd2c7582fe9dfb"></a>
See SigmoidFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>normalizer</b></td></tr>
<tr class="separator:a9050fa7b2067de6640cd2c7582fe9dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b523ee5c505573455d567eb142dd6ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b523ee5c505573455d567eb142dd6ec"></a>
See SigmoidFocalLoss See SigmoidFocalLoss&#160;</td><td class="memItemRight" valign="bottom"><b>d_logits</b></td></tr>
<tr class="separator:a3b523ee5c505573455d567eb142dd6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f05925c5b640ee38bd2547e89d25b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11f05925c5b640ee38bd2547e89d25b0"></a>
NumInputs(4).NumOutputs(1).SetDoc(R&quot;DOC( Smooth L1 Loss is a minor variation of Huber loss in which the <a class="el" href="structpoint.html">point</a> of transition between L2 loss and L1 loss is adjustable by a hyper-parameter beta L2 to L1 transition <a class="el" href="structpoint.html">point</a> <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of labels with the same shape as Y_hat&#160;</td><td class="memItemRight" valign="bottom"><b>alpha_out</b></td></tr>
<tr class="separator:a11f05925c5b640ee38bd2547e89d25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4da563a35f7a8295c1688b7523d5cd8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4da563a35f7a8295c1688b7523d5cd8"></a>
See SmoothL1Loss&#160;</td><td class="memItemRight" valign="bottom"><b>alpha_in</b></td></tr>
<tr class="separator:ab4da563a35f7a8295c1688b7523d5cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b64378cf5baeca5dbbe14b6551fa04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3b64378cf5baeca5dbbe14b6551fa04"></a>
where N is the number of elements in the H and W are the height and and where&#160;</td><td class="memItemRight" valign="bottom"><b>p_i</b> = exp(s_i) / sum_j exp(s_j)</td></tr>
<tr class="separator:ad3b64378cf5baeca5dbbe14b6551fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df2618bd4ee692a16513ca45ed324d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df2618bd4ee692a16513ca45ed324d2"></a>
or input of&#160;</td><td class="memItemRight" valign="bottom"><b>H0</b></td></tr>
<tr class="separator:a3df2618bd4ee692a16513ca45ed324d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b58c36c510f86dbb5f4b58f3ee2c69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3b58c36c510f86dbb5f4b58f3ee2c69"></a>
See SpatialNarrowAs&#160;</td><td class="memItemRight" valign="bottom"><b>dC</b></td></tr>
<tr class="separator:ae3b58c36c510f86dbb5f4b58f3ee2c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459559d278a69f3d8669f8b246a19f01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a459559d278a69f3d8669f8b246a19f01"></a>
See SpatialNarrowAs Gradient of forward&#160;</td><td class="memItemRight" valign="bottom"><b>dA</b></td></tr>
<tr class="separator:a459559d278a69f3d8669f8b246a19f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2016-present, Facebook, Inc. </p>
<p>Copyright (c) 2018-present, Facebook, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A global dictionary that holds information about what Caffe2 modules have been loaded in the current runtime, and also utility functions to load modules.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Simple registry implementation in Caffe2 that uses static variables to register object creators during program initialization time.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Copyright 2016 Facebook </p><dl class="section author"><dt>Author</dt><dd>Tudor Bosman (<a href="#" onclick="location.href='mai'+'lto:'+'tud'+'or'+'b@f'+'b.'+'com'; return false;">tudor<span style="display: none;">.nosp@m.</span>b@fb<span style="display: none;">.nosp@m.</span>.com</a>)</dd></dl>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Copyright (c) 2016, NVIDIA CORPORATION, All rights reserved</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a3c84075c5d69ce9499450fbbb3f72965"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputTypes , class Context , class Functor , class OutputType  = SameTypeAsInput&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">caffe2::UnaryElementwiseOp</a> = typedef <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>&lt; InputTypes, Context, <a class="el" href="structcaffe2_1_1_with_default_constructor.html">WithDefaultConstructor</a>&lt;Functor&gt;, OutputType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UnaryElementwiseOp is a wrapper around <a class="el" href="classcaffe2_1_1_unary_elementwise_with_args_op.html">UnaryElementwiseWithArgsOp</a>, with the difference that it takes a functor with default constructor, e.g. </p>
<p>that does not need to take into consideration any arguments during operator creation. </p>

<p>Definition at line <a class="el" href="elementwise__op_8h_source.html#l00109">109</a> of file <a class="el" href="elementwise__op_8h_source.html">elementwise_op.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af6850a4a5f4298a5c825238cfb0de688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int caffe2::CaffeCudaGetDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current GPU id. </p>
<p>This is a simple wrapper around cudaGetDevice(). </p>

<p>Definition at line <a class="el" href="common__gpu_8cc_source.html#l00125">125</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aff145698c872153a4e117f0e2101f09a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::CaffeCudaSetDevice </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current GPU id. </p>
<p>This is a simple wrapper around cudaGetDevice(). </p>

<p>Definition at line <a class="el" href="common__gpu_8cc_source.html#l00138">138</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa9463003c6ef9000d089ffeaf9296c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classcaffe2_1_1_net_base.html">NetBase</a> &gt; caffe2::CreateNet </td>
          <td>(</td>
          <td class="paramtype">const NetDef &amp;&#160;</td>
          <td class="paramname"><em>net_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a network, accessing / creating blobs in the given workspace. </p>
<p>Note that this is different from <a class="el" href="classcaffe2_1_1_workspace.html#ac8c465ceb6cecbd5a2311f3d5bf4c35e" title="Creates a network with the given NetDef, and returns the pointer to the network. ">Workspace::CreateNet</a>. The latter adds the created net object to the workspace's net map, while this function returns a standalone net object. </p>

<p>Definition at line <a class="el" href="net_8cc_source.html#l00117">117</a> of file <a class="el" href="net_8cc_source.html">net.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af626e8bd4defd97004472e4618071467"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcaffe2_1_1_recurrent_network_executor_base.html">RecurrentNetworkExecutorBase</a>&gt; caffe2::createRNNExecutor&lt; <a class="el" href="classcaffe2_1_1_c_p_u_context.html">CPUContext</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const NetDef &amp;&#160;</td>
          <td class="paramname"><em>step_net_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>recurrent_input_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestep_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1_argument_helper.html">ArgumentHelper</a>&#160;</td>
          <td class="paramname"><em>rnn_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of RecurrentNetworkExecutor that uses thread pool for multithreaded execution of RNNs. </p>
<p>Used with CPU. </p>

<p>Definition at line <a class="el" href="recurrent__network__executor_8cc_source.html#l00029">29</a> of file <a class="el" href="recurrent__network__executor_8cc_source.html">recurrent_network_executor.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5bab26d8f00817d54cb0d975ea633123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::createSharedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1_workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mutex and shared buffer in the workspace. </p>
<p>Not thread-safe, must be called from the constructor. </p>

</div>
</div>
<a class="anchor" id="a2015a66b1fe9fccf95985a1b9de6d31c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CaffeMap&lt; string, const <a class="el" href="classcaffe2_1_1_module_schema.html">ModuleSchema</a> * &gt; &amp; caffe2::CurrentModules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current Modules present in the Caffe2 runtime. </p>
<p>Returns: map: a map of modules and (optionally) their description. The key is the module name, and the value is the description for that module. The module name is recommended to be the part that constitutes the trunk of the dynamic library: for example, a module called libcaffe2_db_rocksdb.so should have the name "caffe2_db_rocksdb". The reason we do not use "lib" is because it's somewhat redundant, and the reason we do not include ".so" is for cross-platform compatibility on platforms like mac os. </p>

<p>Definition at line <a class="el" href="module_8cc_source.html#l00043">43</a> of file <a class="el" href="module_8cc_source.html">module.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5df473adce0513ec1ed647ed7673fab5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename InType , typename OutType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::EmbeddingLookup </td>
          <td>(</td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InType *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>scale_bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize_by_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutType *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Embedding lookup with reduction. </p>
<p><code>input</code> of size data_size * block_size <code>indices</code> of size index_size <code>lengths</code> of size output_size <code>weights</code> nullptr or array of size index_size <code>out</code> of size output_size * block_size sum(lengths[i]) == index_size</p>
<p>Behavior is roughly equivalent to pseudocode:</p>
<p>pos = 0 for (i = 0..index_size-1) for (k = 0..block_size-1) out[i*block_size + k] = 0 for (j = 0..lengths[i]-1) for (k = 0..block_size-1) out[i*block_size + k] += input[indices[pos]*block_size + k] * (weights ? weights[pos] : 1.0) pos += 1 if (normalize_weights &amp;&amp; lengths[i] &gt; 0) for (k = 0..block_size-1) out[i*block_size + k] /= lengths[i] </p>

</div>
</div>
<a class="anchor" id="a3aaf346b2578e6a4300823adc211ca26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename InType , typename OutType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::Fused8BitRowwiseEmbeddingLookup </td>
          <td>(</td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InType *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize_by_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutType *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Embedding lookup with reduction. </p>
<p><code>input</code> of size data_size * (block_size + 8B) <code>indices</code> of size index_size <code>lengths</code> of size output_size <code>weights</code> nullptr or array of size index_size <code>out</code> of size output_size * block_size sum(lengths[i]) == index_size</p>
<p>Note that block_size should be the number of quantized values per row in the data, i.e. excluding the scale and bias. The total (fused) block size is assumed to be this block_size, plus 4 bytes for scale and 4 bytes for bias.</p>
<p>Behavior is roughly equivalent to pseudocode:</p>
<p>pos = 0 fused_block_size = block_size + 8B // quantized values and scale and bias for (i = 0..index_size-1) for (k = 0..block_size-1) out[i*block_size + k] = 0 for (j = 0..lengths[i]-1) for (k = 0..block_size-1) out[i*block_size + k] += input[indices[pos]*(fused_block_size) + k] * (weights ? weights[pos] : 1.0) pos += 1 if (normalize_weights &amp;&amp; lengths[i] &gt; 0) for (k = 0..block_size-1) out[i*block_size + k] /= lengths[i] </p>

</div>
</div>
<a class="anchor" id="ad37066071313fa865f8b2d22b900b3a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CudaMemoryPoolType caffe2::GetCudaMemoryPoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current memory pool type used by Caffe2. </p>
<p>The memory pool is set up during <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>'s global initialization time. </p>

</div>
</div>
<a class="anchor" id="a446da244aca2a8c6808963912cd5cdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::GetCudaPeerAccessPattern </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt; &gt; *&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a peer access pattern by returning a matrix (in the format of a nested vector) of boolean values specifying whether peer access is possible. </p>
<p>This function returns false if anything wrong happens during the query of the GPU access pattern. </p>

<p>Definition at line <a class="el" href="common__gpu_8cc_source.html#l00234">234</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad461b286b4d2322c82a6f43fa00c8034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cudaDeviceProp &amp; caffe2::GetDeviceProperty </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the device property for the given device. </p>
<p>This function is thread safe. </p>

<p>Definition at line <a class="el" href="common__gpu_8cc_source.html#l00182">182</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af70b04a01a1779ddd61f9ef1e0a141b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::GlobalInit </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global environment of <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>. </p>
<p>Caffe2 uses a registration pattern for initialization functions. Custom initialization functions should take the signature bool (<em>func)(int</em>, char***) where the pointers to argc and argv are passed in. Caffe2 then runs the initialization in three phases: (1) Functions registered with REGISTER_CAFFE2_EARLY_INIT_FUNCTION. Note that since it is possible the logger is not initialized yet, any logging in such early init functions may not be printed correctly. (2) Parses Caffe-specific commandline flags, and initializes caffe logging. (3) Functions registered with REGISTER_CAFFE2_INIT_FUNCTION. If there is something wrong at each stage, the function returns false. If the global initialization has already been run, the function returns false as well. </p>

<p>Definition at line <a class="el" href="init_8cc_source.html#l00034">34</a> of file <a class="el" href="init_8cc_source.html">init.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aca313bd69abda6cc82792348e1d64cc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm caffe2::GlobalMPIComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the global MPI communicator used by Caffe2. </p>
<p>In default, this is MPI_COMM_WORLD unless you call <a class="el" href="namespacecaffe2.html#a1eaa1a07583fa2d94c3e66a7496f4790" title="Sets the global MPI communicator. ">SetGlobalMPIComm()</a>. </p>

<p>Definition at line <a class="el" href="mpi__common_8cc_source.html#l00036">36</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a48638afbef9a25309bf7ef40a6e97919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::HasCudaGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the current running session has a cuda gpu present. </p>
<p>Note that this is different from having <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a> built with cuda. Building Caffe2 with cuda only guarantees that this function exists. If there are no cuda gpus present in the machine, or there are hardware configuration problems like an insufficient driver, this function will still return false, meaning that there is no usable GPU present.</p>
<p>In the open source build, it is possible that Caffe2's GPU code is dynamically loaded, and as a result a library could be only linked to the CPU code, but want to test if cuda is later available or not. In this case, one should use HasCudaRuntime() from common.h. </p>

<p>Definition at line <a class="el" href="common__gpu_8h_source.html#l00115">115</a> of file <a class="el" href="common__gpu_8h_source.html">common_gpu.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae721966f8a4a41ea13ac717698e09672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">caffe2::IdenticalTypeAndShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= alpha * (exp(x) - 1.) for x &lt;</div><div class="line">0`, `f(x) = x for x &gt;= 0`.</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad9f3bdc17d263b9070079af7c9248b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::LoadModule </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a module. </p>
<p>Inputs: name: a module name or a path name. It is recommended that you use the name of the module, and leave the full path option to only experimental modules. filename: (optional) a filename that serves as a hint to load the module. </p>

<p>Definition at line <a class="el" href="module_8cc_source.html#l00068">68</a> of file <a class="el" href="module_8cc_source.html">module.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0ca6146615d44e0893a020304848c3d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe2_1_1detail_1_1_scope_guard_impl.html">detail::ScopeGuardImplDecay</a>&lt;F&gt; caffe2::MakeGuard </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ScopeGuard is a general implementation of the "Initialization is
Resource Acquisition" idiom. </p>
<p>Basically, it guarantees that a function is executed upon leaving the currrent scope unless otherwise told.</p>
<p>The <a class="el" href="namespacecaffe2.html#a0ca6146615d44e0893a020304848c3d1" title="ScopeGuard is a general implementation of the &quot;Initialization is Resource Acquisition&quot; idiom...">MakeGuard()</a> function is used to create a new ScopeGuard object. It can be instantiated with a lambda function, a std::function&lt;void()&gt;, a functor, or a void(*)() function pointer.</p>
<p>Usage example: Add a friend to memory iff it is also added to the db.</p>
<p>void User::addFriend(User&amp; newFriend) { // add the friend to memory friends_.push_back(&amp;newFriend);</p>
<p>// If the db insertion that follows fails, we should // remove it from memory. auto guard = MakeGuard([&amp;] { friends_.pop_back(); });</p>
<p>// this will throw an exception upon error, which // makes the ScopeGuard execute UserCont::pop_back() // once the Guard's destructor is called. db_-&gt;addFriend(GetName(), newFriend.GetName());</p>
<p>// an exception was not thrown, so don't execute // the Guard. guard.dismiss(); }</p>
<p>Examine ScopeGuardTest.cpp for some more sample usage.</p>
<p>Stolen from: Andrei's and Petru Marginean's CUJ article: <a href="http://drdobbs.com/184403758">http://drdobbs.com/184403758</a> and the loki library: <a href="http://loki-lib.sourceforge.net/index.php?n=Idioms.ScopeGuardPointer">http://loki-lib.sourceforge.net/index.php?n=Idioms.ScopeGuardPointer</a> and triendl.kj article: <a href="http://www.codeproject.com/KB/cpp/scope_guard.aspx">http://www.codeproject.com/KB/cpp/scope_guard.aspx</a> </p>

<p>Definition at line <a class="el" href="scope__guard_8h_source.html#l00169">169</a> of file <a class="el" href="scope__guard_8h_source.html">scope_guard.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0b7e581ccd292b6b16296966cfbd7ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::MatchStrings </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This allows for the use of * and | to match operator types, engines, or any other property that is represented by strings. </p>
<p>For example, if we wanted to match an operator to Conv or FC, we can give: "Conv|FC" as the type() of that op. </p>

<p>Definition at line <a class="el" href="graph_8cc_source.html#l00230">230</a> of file <a class="el" href="graph_8cc_source.html">graph.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a4dc2404153d4045abf87562f016a7fa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::MPISetupPeers </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>replicas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>job_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function used to perform peer setup so one does not need to use mpirun / mpiexec to run the binary. </p>
<p>Note that if you use mpirun or mpiexec to set up the common world, do not use this function - MPI_Init would have already set that up.</p>
<p>This also assumes that you have a common path (like NFS) that multiple instances can read from.</p>
<p>Inputs: replicas (int): the number of replicas that mpi will run with. role (string): the role of this process, "server" or "client". job_path (string): a file name that the server will write its port into and the clients will read the server's port from. </p>

<p>Definition at line <a class="el" href="mpi__common_8cc_source.html#l00110">110</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a658a8d4d5b33a86502f0fbc5d2b82541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::ParseCaffeCommandLineFlags </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>pargv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the commandline flags. </p>
<p>This command parses all the commandline arguments passed in via pargc and argv. Once it is finished, partc and argv will contain the remaining commandline args that <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a> does not deal with. Note that following convention, argv[0] contains the binary name and is not parsed. </p>

<p>Definition at line <a class="el" href="flags_8cc_source.html#l00071">71</a> of file <a class="el" href="flags_8cc_source.html">flags.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1eaa1a07583fa2d94c3e66a7496f4790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::SetGlobalMPIComm </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>new_comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the global MPI communicator. </p>
<p>Caffe2 takes over the ownership of the passed in communicator. </p>

<p>Definition at line <a class="el" href="mpi__common_8cc_source.html#l00040">40</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3123faf5c57e6b67b0d01cd2daa05bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::ShowLogInfoToStderr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility to allow one to show log info to stderr after the program starts. </p>
<p>This is similar to calling GLOG's &ndash;logtostderr, or setting caffe2_log_level to smaller than INFO. You are recommended to only use this in a few sparse cases, such as when you want to write a tutorial or something. Normally, use the commandline flags to set the log level. </p>

<p>Definition at line <a class="el" href="logging_8cc_source.html#l00212">212</a> of file <a class="el" href="logging_8cc_source.html">logging.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a34174f2652b1ceed8b21e82dc5401de4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have caffe2::a_0</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= N and a_1 * ... * a_{n-1} = D.</div><div class="line">Each of these dimensions must be matched correctly</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="operators_2softmax__op_8cc_source.html#l00114">114</a> of file <a class="el" href="operators_2softmax__op_8cc_source.html">softmax_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a33b67d7c8ded06316eb76184a46bd2b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">where indicates that the corresponding sample should be ignored caffe2::and</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{0, 1} correspond to the binary classes 0 and 1. By</div><div class="line"><span class="keywordflow">default</span> the loss is divided by the number of targets &gt; -1 and then multiplied by</div><div class="line">the `scale` op argument. The divisive normalization may be disable by setting</div><div class="line">the op argument `normalize` to 0 (the multiplication by `scale` still takes</div><div class="line">effect).</div><div class="line"></div><div class="line">This op fuses sigmoid and cross entropy <span class="keywordflow">for</span> numerical stability in both forward</div><div class="line">and gradient computation.</div><div class="line">)DOC<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Arg(</span></div><div class="line"><span class="stringliteral">        &quot;</span>scale<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span>(float) <span class="keywordflow">default</span> 1.0</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="sigmoid__cross__entropy__loss__op_8cc_source.html#l00034">34</a> of file <a class="el" href="sigmoid__cross__entropy__loss__op_8cc_source.html">sigmoid_cross_entropy_loss_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a544e450c246510c64c62fefbe3af76c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number of replicas The input tensor optional Axis to replicate <a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> that will contain input replicated along the given caffe2::axis</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=1</div><div class="line">  shape(A) = (2, 3, 2, 5)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="concat__split__op_8cc_source.html#l00029">29</a> of file <a class="el" href="concat__split__op_8cc_source.html">concat_split_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="addad4c4cf84d667f963d2f34365f3fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::batch_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">              size_to_dim_(canonical_axis, GetDimsVector(logits))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="elementwise__linear__op_8cc_source.html#l00118">118</a> of file <a class="el" href="elementwise__linear__op_8cc_source.html">elementwise_linear_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a833087f682593970e7914e0992e5d3df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto caffe2::canonical_axis</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">          canonical_axis_index_(axis, in[0].dims().size())</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="layer__norm__op_8cc_source.html#l00185">185</a> of file <a class="el" href="layer__norm__op_8cc_source.html">layer_norm_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8729390024d322768e469410ead75913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number of replicas caffe2::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= slope * x <span class="keywordflow">for</span> x &lt; 0`,</div><div class="line">`f(x) = x <span class="keywordflow">for</span> x &gt;= 0`.</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="image__input__op_8cc_source.html#l00117">117</a> of file <a class="el" href="image__input__op_8cc_source.html">image_input_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a84e9aac7255302feac18b3cd49a3a05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int caffe2::default</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=\<span class="stringliteral">&quot;\&quot;) characters in the provided blob &quot;</span></div><div class="line">        <span class="stringliteral">&quot; names that match strip_prefix will be removed prior to loading.&quot;</span></div><div class="line">        <span class="stringliteral">&quot; Also, characters that precede strip_prefix will be removed. Useful &quot;</span></div><div class="line">        <span class="stringliteral">&quot; for removing device scope from blob names.&quot;</span>)</div><div class="line">    .Arg(<span class="stringliteral">&quot;db&quot;</span>, <span class="stringliteral">&quot;(string) the path to the db to load.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;dbs&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(list of strings) the paths to the dbs to load. This is used for loading&quot;</span></div><div class="line">        <span class="stringliteral">&quot; blobs from multiple databases. If it is set, argument in \&quot;db\&quot; will be&quot;</span></div><div class="line">        <span class="stringliteral">&quot; ignored.&quot;</span>)</div><div class="line">    .Arg(<span class="stringliteral">&quot;db_type&quot;</span>, <span class="stringliteral">&quot;(string) the type of the db.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;keep_device&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(int, default 0) if nonzero, the blobs are loaded into the device that &quot;</span></div><div class="line">        <span class="stringliteral">&quot;is specified in the serialized BlobProto. Otherwise, the device will be &quot;</span></div><div class="line">        <span class="stringliteral">&quot;set as the one that the Load operator is being run under.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;load_all&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(int, default 0) if nonzero, will load all blobs pointed to by the db &quot;</span></div><div class="line">        <span class="stringliteral">&quot;to the workspace overwriting/creating blobs as needed.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;allow_incomplete&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(bool, default false) if true, will allow not loading all the output &quot;</span></div><div class="line">        <span class="stringliteral">&quot;blobs specified in the outputs&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;source_blob_names&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(list of strings) if set, used instead of output &quot;</span></div><div class="line">        <span class="stringliteral">&quot;blob names, to specify which blobs in the db shall be loaded. Must be &quot;</span></div><div class="line">        <span class="stringliteral">&quot;the same length as number of output blobs.&quot;</span>)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="load__save__op_8cc_source.html#l00064">64</a> of file <a class="el" href="load__save__op_8cc_source.html">load_save_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6813549291034e22b8c23512190e36e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::dilation_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;dilation_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;dilation&quot;</span>, 1))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00056">56</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0a8bd7d72a9b3c36434015674bc13cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::dilation_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;dilation_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;dilation&quot;</span>, 1))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00058">58</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abc042919e612ec50e763098e9a6a10c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">given param caffe2::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">            CAFFE_ENFORCE_EQ(</div><div class="line">                totalSize,</div><div class="line">                size,</div><div class="line">                <span class="stringliteral">&quot;Argument `shape` does not agree with the input data.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot; (&quot;</span>,</div><div class="line">                totalSize,</div><div class="line">                <span class="stringliteral">&quot; != &quot;</span>,</div><div class="line">                size,</div><div class="line">                <span class="stringliteral">&quot;)&quot;</span>)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="operators_2reshape__op_8cc_source.html#l00104">104</a> of file <a class="el" href="operators_2reshape__op_8cc_source.html">reshape_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6e20361269928187b6a5625204805051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; TensorShape &gt; &amp; caffe2::in</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">      vector&lt;TensorShape&gt; out(1)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="batch__gather__ops_8cc_source.html#l00028">28</a> of file <a class="el" href="batch__gather__ops_8cc_source.html">batch_gather_ops.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a0efa4ede07f3852f506f974ae6bc276b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Focal Loss s gamma hyper parameter tensor of softmax caffe2::inputs</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= X_{nd} * w_d + b_d</div><div class="line">  )DOC<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(0, &quot;</span>X<span class="stringliteral">&quot;, &quot;</span>2D input tensor of size (N X D) data<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(1, &quot;</span>w<span class="stringliteral">&quot;, &quot;</span>1D scaling factors of size D<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(2, &quot;</span>b<span class="stringliteral">&quot;, &quot;</span>1D biases of size D<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(0, &quot;</span>Y<span class="stringliteral">&quot;, &quot;</span>2D output tensor<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Arg(</span></div><div class="line"><span class="stringliteral">        &quot;</span>axis<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span><span class="keywordflow">default</span> to 1</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="elementwise__linear__op_8cc_source.html#l00108">108</a> of file <a class="el" href="elementwise__linear__op_8cc_source.html">elementwise_linear_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aa771dd5c684177749fac98017f820793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kAveragePoolDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">consumes an input blob X and applies average pooling across the</span></div><div class="line"><span class="stringliteral">the blob according to kernel sizes, stride sizes, and pad lengths defined by the</span></div><div class="line"><span class="stringliteral">ConvPoolOpBase operator. Average pooling consisting of averaging all values of a</span></div><div class="line"><span class="stringliteral">subset of the input tensor according to the kernel size and downsampling the</span></div><div class="line"><span class="stringliteral">data into the output blob Y for further processing.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p>Definition at line <a class="el" href="operators_2pool__op_8cc_source.html#l00746">746</a> of file <a class="el" href="operators_2pool__op_8cc_source.html">pool_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6e0c33ee34c77cd3e3e16734e5991d87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kBroadcastDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">If necessary the right-hand-side argument will be broadcasted to match the</span></div><div class="line"><span class="stringliteral">shape of left-hand-side argument. When broadcasting is specified, the second</span></div><div class="line"><span class="stringliteral">tensor can either be of size 1 (a scalar value), or having its shape as a</span></div><div class="line"><span class="stringliteral">contiguous subset of the first tensor&#39;s shape. The starting of the mutually</span></div><div class="line"><span class="stringliteral">equal shape is specified by the argument &quot;axis&quot;, and if it is not set, suffix</span></div><div class="line"><span class="stringliteral">matching is assumed. 1-dim expansion doesn&#39;t work yet.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">For example, the following tensor shapes are supported (with broadcast=1):</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (5,)</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Argument `broadcast=1` needs to be passed to enable broadcasting.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p>Definition at line <a class="el" href="elementwise__op__schema_8cc_source.html#l00023">23</a> of file <a class="el" href="elementwise__op__schema_8cc_source.html">elementwise_op_schema.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab5c2938a533274cb9b74a72e0428d419"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kConvDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">Note that other parameters, such as the stride and</span></div><div class="line"><span class="stringliteral">kernel size, or the pads&#39; sizes in each direction are not necessary for input</span></div><div class="line"><span class="stringliteral">because they are provided by the ConvPoolOpBase operator. Various dimension</span></div><div class="line"><span class="stringliteral">checks are done implicitly, and the sizes are specified in the Input docs for</span></div><div class="line"><span class="stringliteral">this operator. As is expected, the filter is convolved with a subset of the</span></div><div class="line"><span class="stringliteral">image and the bias is added; this is done throughout the image data and the</span></div><div class="line"><span class="stringliteral">output is computed. As a side note on the implementation layout:</span></div><div class="line"><span class="stringliteral">conv_op_impl.h is the templated implementation of the conv_op.h file, which is</span></div><div class="line"><span class="stringliteral">why they are separate files.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p>Definition at line <a class="el" href="operators_2conv__op_8cc_source.html#l00023">23</a> of file <a class="el" href="operators_2conv__op_8cc_source.html">conv_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b9abe1c69fb306a265046144f3c385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::kernel_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;kernel_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;kernel&quot;</span>, 0))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00052">52</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aaaed860c253cc3623218f5e049f56807"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::kernel_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;kernel_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;kernel&quot;</span>, 0))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00054">54</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af8a955b975554d5a59f51b580ac5ca05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kMaxPoolDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">consumes an input blob X and applies max pooling across the</span></div><div class="line"><span class="stringliteral">the blob according to kernel sizes, stride sizes, and pad lengths defined by the</span></div><div class="line"><span class="stringliteral">ConvPoolOpBase operator. Max pooling consisting of taking the maximum value of a</span></div><div class="line"><span class="stringliteral">subset of the input tensor according to the kernel size and downsampling the</span></div><div class="line"><span class="stringliteral">data into the output blob Y for further processing.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p>Definition at line <a class="el" href="operators_2pool__op_8cc_source.html#l00754">754</a> of file <a class="el" href="operators_2pool__op_8cc_source.html">pool_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a22ec3d8b4f17b4e26fdfd0f339e64089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::num_classes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">              <a class="code" href="namespacecaffe2.html#add14fa17af46b7f9a8a81cd9651456d6">size_from_dim_</a>(canonical_axis, GetDimsVector(logits))</div><div class="ttc" id="namespacecaffe2_html_add14fa17af46b7f9a8a81cd9651456d6"><div class="ttname"><a href="namespacecaffe2.html#add14fa17af46b7f9a8a81cd9651456d6">caffe2::size_from_dim_</a></div><div class="ttdeci">TIndex size_from_dim_(int k, const vector&lt; TIndex &gt; &amp;dims)</div><div class="ttdoc">Return product of all dimensions starting from K. </div><div class="ttdef"><b>Definition:</b> <a href="tensor_8h_source.html#l00056">tensor.h:56</a></div></div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="softmax__with__loss__op_8cc_source.html#l00044">44</a> of file <a class="el" href="softmax__with__loss__op_8cc_source.html">softmax_with_loss_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afb2a34a424811068acf175bd0272749c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::order</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= StringToStorageOrder(</div><div class="line">              helper.GetSingleArgument&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;order&quot;</span>, <span class="stringliteral">&quot;NCHW&quot;</span>))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="do__op_8cc_source.html#l00033">33</a> of file <a class="el" href="do__op_8cc_source.html">do_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a874a9ae2d0b766057b51924dd6afc7ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">See SoftmaxFocalLoss See SoftmaxFocalLoss Gradient of forward caffe2::output</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= net.BooleanUnmask([mask1, values1, mask2, values2], [<span class="stringliteral">&quot;output&quot;</span>])</div><div class="line"></div><div class="line">We <span class="keyword">get</span>:</div><div class="line">  output = 1.0</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="abs__op_8cc_source.html#l00061">61</a> of file <a class="el" href="abs__op_8cc_source.html">abs_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af04e8baeca5dcb4f675a99f815264363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe2_1_1_tensor.html">Tensor</a> of rank caffe2::r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 2.<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(1, &quot;</span>INDICES<span class="stringliteral">&quot;, &quot;</span><a class="code" href="struct_tensor.html">Tensor</a> of int32/int64 indices</div><div class="ttc" id="struct_tensor_html"><div class="ttname"><a href="struct_tensor.html">Tensor</a></div><div class="ttdoc">Copyright (c) 2016-present, Facebook, Inc. </div><div class="ttdef"><b>Definition:</b> <a href="ios__caffe__predictor_8h_source.html#l00025">ios_caffe_predictor.h:25</a></div></div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="batch__gather__ops_8cc_source.html#l00045">45</a> of file <a class="el" href="batch__gather__ops_8cc_source.html">batch_gather_ops.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afc9b7cc28c1e368ab79d928e9ae438f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element caffe2::r_</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{ij} as</div><div class="line">0 &lt;= round(r_ij - bias_i) / scale_i) &lt; 256. Instead of input tensor</div><div class="line">we obtain uint8 tensor and auxiliary information as scale and bias to</div><div class="line">restore input tensor (with losses).</div><div class="line">)DOC<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(0, &quot;</span>input<span class="stringliteral">&quot;, &quot;</span>input<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(0, &quot;</span>quantized_input<span class="stringliteral">&quot;, &quot;</span>quantized_input<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(</span></div><div class="line"><span class="stringliteral">        1,</span></div><div class="line"><span class="stringliteral">        &quot;</span>scale_bias<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span>Matrix of floats</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html#l00192">192</a> of file <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html">lengths_reducer_rowwise_8bit_ops.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a984c2d4fbe3b1b9e1602f2ec24fe135f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">A tensor of caffe2::rank</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= axis.<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(</span></div><div class="line"><span class="stringliteral">        0,</span></div><div class="line"><span class="stringliteral">        &quot;</span>output<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span>A 2D tensor with the contents of the input tensor</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="flatten__op_8cc_source.html#l00048">48</a> of file <a class="el" href="flatten__op_8cc_source.html">flatten_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a2535a732c1ece7df1aaf184b8c9089de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reshape it into matrix of we compute caffe2::scale_i</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (min_i - max_i) / 255 and  bias_i = min_i <span class="keywordflow">for</span></div><div class="line">i-th row r_i of reshaped matrix</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html#l00190">190</a> of file <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html">lengths_reducer_rowwise_8bit_ops.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a433ab69df61deb5e78008f2017514433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::stride_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;stride_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;stride&quot;</span>, 1))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00060">60</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a28f24cb994d9da9475e824cc5715772d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::stride_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;stride_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;stride&quot;</span>, 1))</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="im2col__op_8cc_source.html#l00062">62</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a45b77424afcbc65c3b1971194b6c5e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::valid_axes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">            std::all_of(axes.begin(), axes.end(), [&amp;tensor_size](<span class="keywordtype">int</span>&amp; axis) {</div><div class="line">              <span class="keywordflow">return</span> axis &gt;= 0 &amp;&amp; axis &lt; tensor_size;</div><div class="line">            })</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="transpose__op_8cc_source.html#l00051">51</a> of file <a class="el" href="transpose__op_8cc_source.html">transpose_op.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acc6bf36770de6197a0500da244b4d49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True we will accept the first value For False False False True caffe2::values2</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 2.0</div><div class="line">  mask3   = False</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="boolean__unmask__ops_8cc_source.html#l00085">85</a> of file <a class="el" href="boolean__unmask__ops_8cc_source.html">boolean_unmask_ops.cc</a>.</p>

</div>
</div>
<a class="anchor" id="af27fa78c467fba5c61c550605162022c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">caffe2::y</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== 1 then it assumed the first input should be ranked higher</div><div class="line">(have a larger value) than the second input</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="margin__ranking__criterion__op_8cc_source.html#l00096">96</a> of file <a class="el" href="margin__ranking__criterion__op_8cc_source.html">margin_ranking_criterion_op.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 13 2018 13:03:52 for Caffe2 - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<div class="footerContainer">
  <div id="footer_wrap" class="wrapper footerWrapper">
    <div class="footerBlocks">
      <div id="fb_oss" class="footerSection fbOpenSourceFooter">
          <svg class="facebookOSSLogoSvg" viewBox="0 0 1133.9 1133.9" x="0px" y="0px" height=50 width=50>
            <g>
              <path class="logoRing outerRing" d="M 498.3 3.7 c 153.6 88.9 307.3 177.7 461.1 266.2 c 7.6 4.4 10.3 9.1 10.3 17.8 c -0.3 179.1 -0.2 358.3 0 537.4 c 0 8.1 -2.4 12.8 -9.7 17.1 c -154.5 88.9 -308.8 178.1 -462.9 267.5 c -9 5.2 -15.5 5.3 -24.6 0.1 c -153.9 -89.2 -307.9 -178 -462.1 -266.8 C 3 838.8 0 833.9 0 825.1 c 0.3 -179.1 0.2 -358.3 0 -537.4 c 0 -8.6 2.6 -13.6 10.2 -18 C 164.4 180.9 318.4 92 472.4 3 C 477 -1.5 494.3 -0.7 498.3 3.7 Z M 48.8 555.3 c 0 79.9 0.2 159.9 -0.2 239.8 c -0.1 10 3 15.6 11.7 20.6 c 137.2 78.8 274.2 157.8 411 237.3 c 9.9 5.7 17 5.7 26.8 0.1 c 137.5 -79.8 275.2 -159.2 412.9 -238.5 c 7.4 -4.3 10.5 -8.9 10.5 -17.8 c -0.3 -160.2 -0.3 -320.5 0 -480.7 c 0 -8.8 -2.8 -13.6 -10.3 -18 C 772.1 218 633.1 137.8 494.2 57.4 c -6.5 -3.8 -11.5 -4.5 -18.5 -0.5 C 336.8 137.4 197.9 217.7 58.8 297.7 c -7.7 4.4 -10.2 9.2 -10.2 17.9 C 48.9 395.5 48.8 475.4 48.8 555.3 Z" />
              <path class="logoRing middleRing" d="M 184.4 555.9 c 0 -33.3 -1 -66.7 0.3 -100 c 1.9 -48 24.1 -86 64.7 -110.9 c 54.8 -33.6 110.7 -65.5 167 -96.6 c 45.7 -25.2 92.9 -24.7 138.6 1 c 54.4 30.6 108.7 61.5 162.2 93.7 c 44 26.5 67.3 66.8 68 118.4 c 0.9 63.2 0.9 126.5 0 189.7 c -0.7 50.6 -23.4 90.7 -66.6 116.9 c -55 33.4 -110.8 65.4 -167.1 96.5 c -43.4 24 -89 24.2 -132.3 0.5 c -57.5 -31.3 -114.2 -64 -170 -98.3 c -41 -25.1 -62.9 -63.7 -64.5 -112.2 C 183.5 621.9 184.3 588.9 184.4 555.9 Z M 232.9 556.3 c 0 29.5 0.5 59.1 -0.1 88.6 c -0.8 39.2 16.9 67.1 50.2 86.2 c 51.2 29.4 102.2 59.2 153.4 88.4 c 31.4 17.9 63.6 18.3 95 0.6 c 53.7 -30.3 107.1 -61.2 160.3 -92.5 c 29.7 -17.5 45 -44.5 45.3 -78.8 c 0.6 -61.7 0.5 -123.5 0 -185.2 c -0.3 -34.4 -15.3 -61.5 -44.9 -79 C 637.7 352.6 583 320.8 527.9 290 c -27.5 -15.4 -57.2 -16.1 -84.7 -0.7 c -56.9 31.6 -113.4 64 -169.1 97.6 c -26.4 15.9 -40.7 41.3 -41.1 72.9 C 232.6 491.9 232.9 524.1 232.9 556.3 Z" />
              <path class="logoRing innerRing" d="M 484.9 424.4 c 69.8 -2.8 133.2 57.8 132.6 132 C 617 630 558.5 688.7 484.9 689.1 c -75.1 0.4 -132.6 -63.6 -132.7 -132.7 C 352.1 485 413.4 421.5 484.9 424.4 Z M 401.3 556.7 c -3.4 37.2 30.5 83.6 83 84.1 c 46.6 0.4 84.8 -37.6 84.9 -84 c 0.1 -46.6 -37.2 -84.4 -84.2 -84.6 C 432.2 472.1 397.9 518.3 401.3 556.7 Z" />
            </g>
          </svg>
        <h2>Facebook Open Source</h2>
      </div>
      <div class="footerSection">
        <a class="footerLink" href="https://code.facebook.com/projects/" target="_blank">Open Source Projects</a>
        <a class="footerLink" href="https://github.com/facebook/" target="_blank">GitHub</a>
        <a class="footerLink" href="https://twitter.com/fbOpenSource" target="_blank">Twitter</a>
      </div>
      <div class="footerSection rightAlign">
        <a class="footerLink" href="https://github.com/caffe2/caffe2" target="_blank">Contribute to this project on GitHub</a>
      </div>
    </div>
  </div>
</div>
<script type="text/javascript" src="/js/jekyll-link-anchors.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '{{ site.gacode }}', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
